/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/engine.io-client";
exports.ids = ["vendor-chunks/engine.io-client"];
exports.modules = {

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/debug/src/browser.js":
/*!**************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/debug/src/browser.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ exports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    let m;\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === \"%%\") {\n            return;\n        }\n        index++;\n        if (match === \"%c\") {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem(\"debug\", namespaces);\n        } else {\n            exports.storage.removeItem(\"debug\");\n        }\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem(\"debug\");\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(ssr)/../node_modules/engine.io-client/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNCQUFzQixHQUV0Qjs7Q0FFQyxHQUVEQSxrQkFBa0IsR0FBR0M7QUFDckJELFlBQVksR0FBR0U7QUFDZkYsWUFBWSxHQUFHRztBQUNmSCxpQkFBaUIsR0FBR0k7QUFDcEJKLGVBQWUsR0FBR007QUFDbEJOLGVBQWUsR0FBRyxDQUFDO0lBQ2xCLElBQUlRLFNBQVM7SUFFYixPQUFPO1FBQ04sSUFBSSxDQUFDQSxRQUFRO1lBQ1pBLFNBQVM7WUFDVEMsUUFBUUMsSUFBSSxDQUFDO1FBQ2Q7SUFDRDtBQUNEO0FBRUE7O0NBRUMsR0FFRFYsY0FBYyxHQUFHO0lBQ2hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0E7QUFFRDs7Ozs7O0NBTUMsR0FFRCxzQ0FBc0M7QUFDdEMsU0FBU0k7SUFDUiw0RUFBNEU7SUFDNUUsMEVBQTBFO0lBQzFFLGFBQWE7SUFDYixJQUFJLEtBQWdILEVBQUUsRUFFckg7SUFFRCxvREFBb0Q7SUFDcEQsSUFBSSxPQUFPWSxjQUFjLGVBQWVBLFVBQVVD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dkcsMkRBQTJEO1FBQzNELE9BQU80QztJQUNSLEVBQUUsT0FBT0wsT0FBTztJQUNmLFVBQVU7SUFDViwwQ0FBMEM7SUFDM0M7QUFDRDtBQUVBZCxPQUFPL0IsT0FBTyxHQUFHbUQsbUJBQU9BLENBQUMsMkZBQVluRDtBQUVyQyxNQUFNLEVBQUNvRCxVQUFVLEVBQUMsR0FBR3JCLE9BQU8vQixPQUFPO0FBRW5DOztDQUVDLEdBRURvRCxXQUFXQyxDQUFDLEdBQUcsU0FBVUMsQ0FBQztJQUN6QixJQUFJO1FBQ0gsT0FBT0MsS0FBS0MsU0FBUyxDQUFDRjtJQUN2QixFQUFFLE9BQU9ULE9BQU87UUFDZixPQUFPLGlDQUFpQ0EsTUFBTVksT0FBTztJQUN0RDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdHNhcHAtYWktY3JtLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcz81MzhmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgbTtcblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pKSAmJiBwYXJzZUludChtWzFdLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJmb3JtYXRBcmdzIiwic2F2ZSIsImxvYWQiLCJ1c2VDb2xvcnMiLCJzdG9yYWdlIiwibG9jYWxzdG9yYWdlIiwiZGVzdHJveSIsIndhcm5lZCIsImNvbnNvbGUiLCJ3YXJuIiwiY29sb3JzIiwid2luZG93IiwicHJvY2VzcyIsInR5cGUiLCJfX253anMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwibSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJXZWJraXRBcHBlYXJhbmNlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsInRhYmxlIiwicGFyc2VJbnQiLCJhcmdzIiwibmFtZXNwYWNlIiwibW9kdWxlIiwiaHVtYW5pemUiLCJkaWZmIiwiYyIsImNvbG9yIiwic3BsaWNlIiwiaW5kZXgiLCJsYXN0QyIsInJlcGxhY2UiLCJsb2ciLCJkZWJ1ZyIsIm5hbWVzcGFjZXMiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImVycm9yIiwiciIsImdldEl0ZW0iLCJlbnYiLCJERUJVRyIsImxvY2FsU3RvcmFnZSIsInJlcXVpcmUiLCJmb3JtYXR0ZXJzIiwiaiIsInYiLCJKU09OIiwic3RyaW5naWZ5IiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/debug/src/common.js":
/*!*************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/debug/src/common.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ function setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"(ssr)/../node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== \"string\") {\n                // Anything else let's inspect with %O\n                args.unshift(\"%O\");\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === \"%%\") {\n                    return \"%\";\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === \"function\") {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, \"enabled\", {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === \"function\") {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for(i = 0; i < len; i++){\n            if (!split[i]) {\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, \".*?\");\n            if (namespaces[0] === \"-\") {\n                createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n            } else {\n                createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n            }\n        }\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map((namespace)=>\"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n            return true;\n        }\n        let i;\n        let len;\n        for(i = 0, len = createDebug.skips.length; i < len; i++){\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for(i = 0, len = createDebug.names.length; i < len; i++){\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/ function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQ0E7OztDQUdDLEdBRUQsU0FBU0EsTUFBTUMsR0FBRztJQUNqQkMsWUFBWUMsS0FBSyxHQUFHRDtJQUNwQkEsWUFBWUUsT0FBTyxHQUFHRjtJQUN0QkEsWUFBWUcsTUFBTSxHQUFHQTtJQUNyQkgsWUFBWUksT0FBTyxHQUFHQTtJQUN0QkosWUFBWUssTUFBTSxHQUFHQTtJQUNyQkwsWUFBWU0sT0FBTyxHQUFHQTtJQUN0Qk4sWUFBWU8sUUFBUSxHQUFHQyxtQkFBT0EsQ0FBQztJQUMvQlIsWUFBWVMsT0FBTyxHQUFHQTtJQUV0QkMsT0FBT0MsSUFBSSxDQUFDWixLQUFLYSxPQUFPLENBQUNDLENBQUFBO1FBQ3hCYixXQUFXLENBQUNhLElBQUksR0FBR2QsR0FBRyxDQUFDYyxJQUFJO0lBQzVCO0lBRUE7O0NBRUEsR0FFQWIsWUFBWWMsS0FBSyxHQUFHLEVBQUU7SUFDdEJkLFlBQVllLEtBQUssR0FBRyxFQUFFO0lBRXRCOzs7O0NBSUEsR0FDQWYsWUFBWWdCLFVBQVUsR0FBRyxDQUFDO0lBRTFCOzs7OztDQUtBLEdBQ0EsU0FBU0MsWUFBWUMsU0FBUztRQUM3QixJQUFJQyxPQUFPO1FBRVgsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFVBQVVHLE1BQU0sRUFBRUQsSUFBSztZQUMxQ0QsT0FBTyxDQUFFQSxRQUFRLEtBQUtBLE9BQVFELFVBQVVJLFVBQVUsQ0FBQ0Y7WUFDbkRELFFBQVEsR0FBRywyQkFBMkI7UUFDdkM7UUFFQSxPQUFPbkIsWUFBWXVCLE1BQU0sQ0FBQ0MsS0FBS0MsR0FBRyxDQUFDTixRQUFRbkIsWUFBWXVCLE1BQU0sQ0FBQ0YsTUFBTSxDQUFDO0lBQ3RFO0lBQ0FyQixZQUFZaUIsV0FBVyxHQUFHQTtJQUUxQjs7Ozs7O0NBTUEsR0FDQSxTQUFTakIsWUFBWWtCLFNBQVM7UUFDN0Is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QUFHOEMsTUFBTWxFLFlBQVllLEtBQUssQ0FBQ00sTUFBTSxFQUFFRCxJQUFJOEMsS0FBSzlDLElBQUs7WUFDekQsSUFBSXBCLFlBQVllLEtBQUssQ0FBQ0ssRUFBRSxDQUFDc0QsSUFBSSxDQUFDRCxPQUFPO2dCQUNwQyxPQUFPO1lBQ1I7UUFDRDtRQUVBLElBQUtyRCxJQUFJLEdBQUc4QyxNQUFNbEUsWUFBWWMsS0FBSyxDQUFDTyxNQUFNLEVBQUVELElBQUk4QyxLQUFLOUMsSUFBSztZQUN6RCxJQUFJcEIsWUFBWWMsS0FBSyxDQUFDTSxFQUFFLENBQUNzRCxJQUFJLENBQUNELE9BQU87Z0JBQ3BDLE9BQU87WUFDUjtRQUNEO1FBRUEsT0FBTztJQUNSO0lBRUE7Ozs7OztDQU1BLEdBQ0EsU0FBU0YsWUFBWUksTUFBTTtRQUMxQixPQUFPQSxPQUFPQyxRQUFRLEdBQ3BCQyxTQUFTLENBQUMsR0FBR0YsT0FBT0MsUUFBUSxHQUFHdkQsTUFBTSxHQUFHLEdBQ3hDbUIsT0FBTyxDQUFDLFdBQVc7SUFDdEI7SUFFQTs7Ozs7O0NBTUEsR0FDQSxTQUFTckMsT0FBT3lDLEdBQUc7UUFDbEIsSUFBSUEsZUFBZWtDLE9BQU87WUFDekIsT0FBT2xDLElBQUltQyxLQUFLLElBQUluQyxJQUFJb0MsT0FBTztRQUNoQztRQUNBLE9BQU9wQztJQUNSO0lBRUE7OztDQUdBLEdBQ0EsU0FBU25DO1FBQ1J3RSxRQUFRQyxJQUFJLENBQUM7SUFDZDtJQUVBbEYsWUFBWUssTUFBTSxDQUFDTCxZQUFZbUYsSUFBSTtJQUVuQyxPQUFPbkY7QUFDUjtBQUVBb0YsT0FBT0MsT0FBTyxHQUFHdkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanM/NzAwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIl0sIm5hbWVzIjpbInNldHVwIiwiZW52IiwiY3JlYXRlRGVidWciLCJkZWJ1ZyIsImRlZmF1bHQiLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiZW5hYmxlZCIsImh1bWFuaXplIiwicmVxdWlyZSIsImRlc3Ryb3kiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsIm5hbWVzIiwic2tpcHMiLCJmb3JtYXR0ZXJzIiwic2VsZWN0Q29sb3IiLCJuYW1lc3BhY2UiLCJoYXNoIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjb2xvcnMiLCJNYXRoIiwiYWJzIiwicHJldlRpbWUiLCJlbmFibGVPdmVycmlkZSIsIm5hbWVzcGFjZXNDYWNoZSIsImVuYWJsZWRDYWNoZSIsImFyZ3MiLCJzZWxmIiwiY3VyciIsIk51bWJlciIsIkRhdGUiLCJtcyIsImRpZmYiLCJwcmV2IiwidW5zaGlmdCIsImluZGV4IiwicmVwbGFjZSIsIm1hdGNoIiwiZm9ybWF0IiwiZm9ybWF0dGVyIiwidmFsIiwiY2FsbCIsInNwbGljZSIsImZvcm1hdEFyZ3MiLCJsb2dGbiIsImxvZyIsImFwcGx5IiwidXNlQ29sb3JzIiwiY29sb3IiLCJleHRlbmQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiLCJuYW1lc3BhY2VzIiwic2V0IiwidiIsImluaXQiLCJkZWxpbWl0ZXIiLCJuZXdEZWJ1ZyIsInNhdmUiLCJzcGxpdCIsImxlbiIsInB1c2giLCJSZWdFeHAiLCJzbGljZSIsIm1hcCIsInRvTmFtZXNwYWNlIiwiam9pbiIsIm5hbWUiLCJ0ZXN0IiwicmVnZXhwIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJFcnJvciIsInN0YWNrIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwibG9hZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/debug/src/index.js":
/*!************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/debug/src/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */ if (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(ssr)/../node_modules/engine.io-client/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(ssr)/../node_modules/engine.io-client/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0MsR0FFRCxJQUFJLE9BQU9BLFlBQVksZUFBZUEsUUFBUUMsSUFBSSxLQUFLLGNBQWNELEtBQWUsS0FBSyxRQUFRQSxRQUFRRyxNQUFNLEVBQUU7SUFDaEhDLG9JQUF5QjtBQUMxQixPQUFPO0lBQ05BLDhIQUF5QjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3doYXRzYXBwLWFpLWNybS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzPzFmZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgLyBud2pzIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCBwcm9jZXNzLmJyb3dzZXIgPT09IHRydWUgfHwgcHJvY2Vzcy5fX253anMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIuanMnKTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsInR5cGUiLCJicm93c2VyIiwiX19ud2pzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/debug/src/node.js":
/*!***********************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/debug/src/node.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */ const tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */ exports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(()=>{}, \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\ntry {\n    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    const supportsColor = __webpack_require__(/*! supports-color */ \"(ssr)/../node_modules/supports-color/index.js\");\n    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n            20,\n            21,\n            26,\n            27,\n            32,\n            33,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            56,\n            57,\n            62,\n            63,\n            68,\n            69,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            92,\n            93,\n            98,\n            99,\n            112,\n            113,\n            128,\n            129,\n            134,\n            135,\n            148,\n            149,\n            160,\n            161,\n            162,\n            163,\n            164,\n            165,\n            166,\n            167,\n            168,\n            169,\n            170,\n            171,\n            172,\n            173,\n            178,\n            179,\n            184,\n            185,\n            196,\n            197,\n            198,\n            199,\n            200,\n            201,\n            202,\n            203,\n            204,\n            205,\n            206,\n            207,\n            208,\n            209,\n            214,\n            215,\n            220,\n            221\n        ];\n    }\n} catch (error) {\n// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{\n    return /^debug_/i.test(key);\n}).reduce((obj, key)=>{\n    // Camel-case\n    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{\n        return k.toUpperCase();\n    });\n    // Coerce string value into JS value\n    let val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n    } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n    } else if (val === \"null\") {\n        val = null;\n    } else {\n        val = Number(val);\n    }\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    const { namespace: name, useColors } = this;\n    if (useColors) {\n        const c = this.color;\n        const colorCode = \"\\x1b[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module.exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = getDate() + name + \" \" + args[0];\n    }\n}\nfunction getDate() {\n    if (exports.inspectOpts.hideDate) {\n        return \"\";\n    }\n    return new Date().toISOString() + \" \";\n}\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */ function log(...args) {\n    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (namespaces) {\n        process.env.DEBUG = namespaces;\n    } else {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    const keys = Object.keys(exports.inspectOpts);\n    for(let i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(ssr)/../node_modules/engine.io-client/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map((str)=>str.trim()).join(\" \");\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */ formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUMsT0FBT0QsbUJBQU9BLENBQUM7QUFFckI7O0NBRUMsR0FFREUsWUFBWSxHQUFHQztBQUNmRCxXQUFXLEdBQUdFO0FBQ2RGLGtCQUFrQixHQUFHRztBQUNyQkgsWUFBWSxHQUFHSTtBQUNmSixZQUFZLEdBQUdLO0FBQ2ZMLGlCQUFpQixHQUFHTTtBQUNwQk4sZUFBZSxHQUFHRCxLQUFLUyxTQUFTLENBQy9CLEtBQU8sR0FDUDtBQUdEOztDQUVDLEdBRURSLGNBQWMsR0FBRztJQUFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztDQUFFO0FBRW5DLElBQUk7SUFDSCwyR0FBMkc7SUFDM0csNkRBQTZEO0lBQzdELE1BQU1VLGdCQUFnQlosbUJBQU9BLENBQUM7SUFFOUIsSUFBSVksaUJBQWlCLENBQUNBLGNBQWNDLE1BQU0sSUFBSUQsYUFBWSxFQUFHRSxLQUFLLElBQUksR0FBRztRQUN4RVosY0FBYyxHQUFHO1lBQ2hCO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZ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TUFBTTNDLFdBQVcsR0FBRyxDQUFDO0lBRXJCLE1BQU1FLE9BQU9ELE9BQU9DLElBQUksQ0FBQ2hCLFFBQVFjLFdBQVc7SUFDNUMsSUFBSyxJQUFJNEMsSUFBSSxHQUFHQSxJQUFJMUMsS0FBSzJDLE1BQU0sRUFBRUQsSUFBSztRQUNyQ0QsTUFBTTNDLFdBQVcsQ0FBQ0UsSUFBSSxDQUFDMEMsRUFBRSxDQUFDLEdBQUcxRCxRQUFRYyxXQUFXLENBQUNFLElBQUksQ0FBQzBDLEVBQUUsQ0FBQztJQUMxRDtBQUNEO0FBRUFaLE9BQU85QyxPQUFPLEdBQUdGLG1CQUFPQSxDQUFDLDJGQUFZRTtBQUVyQyxNQUFNLEVBQUM0RCxVQUFVLEVBQUMsR0FBR2QsT0FBTzlDLE9BQU87QUFFbkM7O0NBRUMsR0FFRDRELFdBQVdDLENBQUMsR0FBRyxTQUFVQyxDQUFDO0lBQ3pCLElBQUksQ0FBQ2hELFdBQVcsQ0FBQ0wsTUFBTSxHQUFHLElBQUksQ0FBQ0gsU0FBUztJQUN4QyxPQUFPUCxLQUFLZ0UsT0FBTyxDQUFDRCxHQUFHLElBQUksQ0FBQ2hELFdBQVcsRUFDckM2QixLQUFLLENBQUMsTUFDTnFCLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSUMsSUFBSSxJQUNuQnRCLElBQUksQ0FBQztBQUNSO0FBRUE7O0NBRUMsR0FFRGdCLFdBQVdPLENBQUMsR0FBRyxTQUFVTCxDQUFDO0lBQ3pCLElBQUksQ0FBQ2hELFdBQVcsQ0FBQ0wsTUFBTSxHQUFHLElBQUksQ0FBQ0gsU0FBUztJQUN4QyxPQUFPUCxLQUFLZ0UsT0FBTyxDQUFDRCxHQUFHLElBQUksQ0FBQ2hELFdBQVc7QUFDeEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzPzA2NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuZGVzdHJveSA9IHV0aWwuZGVwcmVjYXRlKFxuXHQoKSA9PiB7fSxcblx0J0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nXG4pO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFs2LCAyLCAzLCA0LCA1LCAxXTtcblxudHJ5IHtcblx0Ly8gT3B0aW9uYWwgZGVwZW5kZW5jeSAoYXMgaW4sIGRvZXNuJ3QgbmVlZCB0byBiZSBpbnN0YWxsZWQsIE5PVCBsaWtlIG9wdGlvbmFsRGVwZW5kZW5jaWVzIGluIHBhY2thZ2UuanNvbilcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuXHRjb25zdCBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcblxuXHRpZiAoc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMikge1xuXHRcdGV4cG9ydHMuY29sb3JzID0gW1xuXHRcdFx0MjAsXG5cdFx0XHQyMSxcblx0XHRcdDI2LFxuXHRcdFx0MjcsXG5cdFx0XHQzMixcblx0XHRcdDMzLFxuXHRcdFx0MzgsXG5cdFx0XHQzOSxcblx0XHRcdDQwLFxuXHRcdFx0NDEsXG5cdFx0XHQ0Mixcblx0XHRcdDQzLFxuXHRcdFx0NDQsXG5cdFx0XHQ0NSxcblx0XHRcdDU2LFxuXHRcdFx0NTcsXG5cdFx0XHQ2Mixcblx0XHRcdDYzLFxuXHRcdFx0NjgsXG5cdFx0XHQ2OSxcblx0XHRcdDc0LFxuXHRcdFx0NzUsXG5cdFx0XHQ3Nixcblx0XHRcdDc3LFxuXHRcdFx0NzgsXG5cdFx0XHQ3OSxcblx0XHRcdDgwLFxuXHRcdFx0ODEsXG5cdFx0XHQ5Mixcblx0XHRcdDkzLFxuXHRcdFx0OTgsXG5cdFx0XHQ5OSxcblx0XHRcdDExMixcblx0XHRcdDExMyxcblx0XHRcdDEyOCxcblx0XHRcdDEyOSxcblx0XHRcdDEzNCxcblx0XHRcdDEzNSxcblx0XHRcdDE0OCxcblx0XHRcdDE0OSxcblx0XHRcdDE2MCxcblx0XHRcdDE2MSxcblx0XHRcdDE2Mixcblx0XHRcdDE2Myxcblx0XHRcdDE2NCxcblx0XHRcdDE2NSxcblx0XHRcdDE2Nixcblx0XHRcdDE2Nyxcblx0XHRcdDE2OCxcblx0XHRcdDE2OSxcblx0XHRcdDE3MCxcblx0XHRcdDE3MSxcblx0XHRcdDE3Mixcblx0XHRcdDE3Myxcblx0XHRcdDE3OCxcblx0XHRcdDE3OSxcblx0XHRcdDE4NCxcblx0XHRcdDE4NSxcblx0XHRcdDE5Nixcblx0XHRcdDE5Nyxcblx0XHRcdDE5OCxcblx0XHRcdDE5OSxcblx0XHRcdDIwMCxcblx0XHRcdDIwMSxcblx0XHRcdDIwMixcblx0XHRcdDIwMyxcblx0XHRcdDIwNCxcblx0XHRcdDIwNSxcblx0XHRcdDIwNixcblx0XHRcdDIwNyxcblx0XHRcdDIwOCxcblx0XHRcdDIwOSxcblx0XHRcdDIxNCxcblx0XHRcdDIxNSxcblx0XHRcdDIyMCxcblx0XHRcdDIyMVxuXHRcdF07XG5cdH1cbn0gY2F0Y2ggKGVycm9yKSB7XG5cdC8vIFN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbn1cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoa2V5ID0+IHtcblx0cmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKChvYmosIGtleSkgPT4ge1xuXHQvLyBDYW1lbC1jYXNlXG5cdGNvbnN0IHByb3AgPSBrZXlcblx0XHQuc3Vic3RyaW5nKDYpXG5cdFx0LnRvTG93ZXJDYXNlKClcblx0XHQucmVwbGFjZSgvXyhbYS16XSkvZywgKF8sIGspID0+IHtcblx0XHRcdHJldHVybiBrLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cblx0Ly8gQ29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG5cdGxldCB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuXHRpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gdHJ1ZTtcblx0fSBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkge1xuXHRcdHZhbCA9IGZhbHNlO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB7XG5cdFx0dmFsID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSBOdW1iZXIodmFsKTtcblx0fVxuXG5cdG9ialtwcm9wXSA9IHZhbDtcblx0cmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHRyZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/XG5cdFx0Qm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycykgOlxuXHRcdHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xufVxuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRjb25zdCB7bmFtZXNwYWNlOiBuYW1lLCB1c2VDb2xvcnN9ID0gdGhpcztcblxuXHRpZiAodXNlQ29sb3JzKSB7XG5cdFx0Y29uc3QgYyA9IHRoaXMuY29sb3I7XG5cdFx0Y29uc3QgY29sb3JDb2RlID0gJ1xcdTAwMUJbMycgKyAoYyA8IDggPyBjIDogJzg7NTsnICsgYyk7XG5cdFx0Y29uc3QgcHJlZml4ID0gYCAgJHtjb2xvckNvZGV9OzFtJHtuYW1lfSBcXHUwMDFCWzBtYDtcblxuXHRcdGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcblx0XHRhcmdzLnB1c2goY29sb3JDb2RlICsgJ20rJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxQlswbScpO1xuXHR9IGVsc2Uge1xuXHRcdGFyZ3NbMF0gPSBnZXREYXRlKCkgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXREYXRlKCkge1xuXHRpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXHRyZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0V2l0aE9wdGlvbnMoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIHN0ZGVyci5cbiAqL1xuXG5mdW5jdGlvbiBsb2coLi4uYXJncykge1xuXHRyZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhleHBvcnRzLmluc3BlY3RPcHRzLCAuLi5hcmdzKSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHRpZiAobmFtZXNwYWNlcykge1xuXHRcdHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcblx0fSBlbHNlIHtcblx0XHQvLyBJZiB5b3Ugc2V0IGEgcHJvY2Vzcy5lbnYgZmllbGQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGl0IGdldHMgY2FzdCB0byB0aGVcblx0XHQvLyBzdHJpbmcgJ251bGwnIG9yICd1bmRlZmluZWQnLiBKdXN0IGRlbGV0ZSBpbnN0ZWFkLlxuXHRcdGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbn1cblxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBpbml0KGRlYnVnKSB7XG5cdGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuaW5zcGVjdE9wdHMpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24gKHYpIHtcblx0dGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblx0cmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKVxuXHRcdC5zcGxpdCgnXFxuJylcblx0XHQubWFwKHN0ciA9PiBzdHIudHJpbSgpKVxuXHRcdC5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIE1hcCAlTyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGxvd2luZyBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQuXG4gKi9cblxuZm9ybWF0dGVycy5PID0gZnVuY3Rpb24gKHYpIHtcblx0dGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblx0cmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG4iXSwibmFtZXMiOlsidHR5IiwicmVxdWlyZSIsInV0aWwiLCJleHBvcnRzIiwiaW5pdCIsImxvZyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsImRlc3Ryb3kiLCJkZXByZWNhdGUiLCJjb2xvcnMiLCJzdXBwb3J0c0NvbG9yIiwic3RkZXJyIiwibGV2ZWwiLCJlcnJvciIsImluc3BlY3RPcHRzIiwiT2JqZWN0Iiwia2V5cyIsInByb2Nlc3MiLCJlbnYiLCJmaWx0ZXIiLCJrZXkiLCJ0ZXN0IiwicmVkdWNlIiwib2JqIiwicHJvcCIsInN1YnN0cmluZyIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsIl8iLCJrIiwidG9VcHBlckNhc2UiLCJ2YWwiLCJOdW1iZXIiLCJCb29sZWFuIiwiaXNhdHR5IiwiZmQiLCJhcmdzIiwibmFtZXNwYWNlIiwibmFtZSIsImMiLCJjb2xvciIsImNvbG9yQ29kZSIsInByZWZpeCIsInNwbGl0Iiwiam9pbiIsInB1c2giLCJtb2R1bGUiLCJodW1hbml6ZSIsImRpZmYiLCJnZXREYXRlIiwiaGlkZURhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ3cml0ZSIsImZvcm1hdFdpdGhPcHRpb25zIiwibmFtZXNwYWNlcyIsIkRFQlVHIiwiZGVidWciLCJpIiwibGVuZ3RoIiwiZm9ybWF0dGVycyIsIm8iLCJ2IiwiaW5zcGVjdCIsIm1hcCIsInN0ciIsInRyaW0iLCJPIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/buffer-util.js":
/*!***************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/buffer-util.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */ function concat(list, totalLength) {\n    if (list.length === 0) return EMPTY_BUFFER;\n    if (list.length === 1) return list[0];\n    const target = Buffer.allocUnsafe(totalLength);\n    let offset = 0;\n    for(let i = 0; i < list.length; i++){\n        const buf = list[i];\n        target.set(buf, offset);\n        offset += buf.length;\n    }\n    if (offset < totalLength) {\n        return new FastBuffer(target.buffer, target.byteOffset, offset);\n    }\n    return target;\n}\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */ function _mask(source, mask, output, offset, length) {\n    for(let i = 0; i < length; i++){\n        output[offset + i] = source[i] ^ mask[i & 3];\n    }\n}\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */ function _unmask(buffer, mask) {\n    for(let i = 0; i < buffer.length; i++){\n        buffer[i] ^= mask[i & 3];\n    }\n}\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */ function toArrayBuffer(buf) {\n    if (buf.length === buf.buffer.byteLength) {\n        return buf.buffer;\n    }\n    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */ function toBuffer(data) {\n    toBuffer.readOnly = true;\n    if (Buffer.isBuffer(data)) return data;\n    let buf;\n    if (data instanceof ArrayBuffer) {\n        buf = new FastBuffer(data);\n    } else if (ArrayBuffer.isView(data)) {\n        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n    } else {\n        buf = Buffer.from(data);\n        toBuffer.readOnly = false;\n    }\n    return buf;\n}\nmodule.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n};\n/* istanbul ignore else  */ if (!process.env.WS_NO_BUFFER_UTIL) {\n    try {\n        const bufferUtil = __webpack_require__(/*! bufferutil */ \"?8355\");\n        module.exports.mask = function(source, mask, output, offset, length) {\n            if (length < 48) _mask(source, mask, output, offset, length);\n            else bufferUtil.mask(source, mask, output, offset, length);\n        };\n        module.exports.unmask = function(buffer, mask) {\n            if (buffer.length < 32) _unmask(buffer, mask);\n            else bufferUtil.unmask(buffer, mask);\n        };\n    } catch (e) {\n    // Continue regardless of the error.\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsWUFBWSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRWpDLE1BQU1DLGFBQWFDLE1BQU0sQ0FBQ0MsT0FBT0MsT0FBTyxDQUFDO0FBRXpDOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxPQUFPQyxJQUFJLEVBQUVDLFdBQVc7SUFDL0IsSUFBSUQsS0FBS0UsTUFBTSxLQUFLLEdBQUcsT0FBT1Q7SUFDOUIsSUFBSU8sS0FBS0UsTUFBTSxLQUFLLEdBQUcsT0FBT0YsSUFBSSxDQUFDLEVBQUU7SUFFckMsTUFBTUcsU0FBU1AsT0FBT1EsV0FBVyxDQUFDSDtJQUNsQyxJQUFJSSxTQUFTO0lBRWIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLEtBQUtFLE1BQU0sRUFBRUksSUFBSztRQUNwQyxNQUFNQyxNQUFNUCxJQUFJLENBQUNNLEVBQUU7UUFDbkJILE9BQU9LLEdBQUcsQ0FBQ0QsS0FBS0Y7UUFDaEJBLFVBQVVFLElBQUlMLE1BQU07SUFDdEI7SUFFQSxJQUFJRyxTQUFTSixhQUFhO1FBQ3hCLE9BQU8sSUFBSU4sV0FBV1EsT0FBT00sTUFBTSxFQUFFTixPQUFPTyxVQUFVLEVBQUVMO0lBQzFEO0lBRUEsT0FBT0Y7QUFDVDtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNRLE1BQU1DLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVULE1BQU0sRUFBRUgsTUFBTTtJQUNqRCxJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUosUUFBUUksSUFBSztRQUMvQlEsTUFBTSxDQUFDVCxTQUFTQyxFQUFFLEdBQUdNLE1BQU0sQ0FBQ04sRUFBRSxHQUFHTyxJQUFJLENBQUNQLElBQUksRUFBRTtJQUM5QztBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1MsUUFBUU4sTUFBTSxFQUFFSSxJQUFJO0lBQzNCLElBQUssSUFBSVAsSUFBSSxHQUFHQSxJQUFJRyxPQUFPUCxNQUFNLEVBQUVJLElBQUs7UUFDdENHLE1BQU0sQ0FBQ0gsRUFBRSxJQUFJTyxJQUFJLENBQUNQLElBQUksRUFBRTtJQUMxQjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1UsY0FBY1QsR0FBRztJQUN4QixJQUFJQSxJQUFJTCxNQUFNLEtBQUtLLElBQUlFLE1BQU0sQ0FBQ1EsVUFBVSxFQUFFO1FBQ3hDLE9BQU9WLElBQUlFLE1BQU07SUFDbkI7SUFFQSxPQUFPRixJQUFJRSxNQUFNLENBQUNTLEtBQUssQ0FBQ1gsSUFBSUcsVUFBVSxFQUFFSCxJQUFJRyxVQUFVLEdBQUdILElBQUlMLE1BQU07QUFDckU7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU2lCLFNBQVNDLElBQUk7SUFDcEJELFNBQVNFLFFBQVEsR0FBRztJQUVwQixJQUFJekIsT0FBTzBCLFFBQVEsQ0FBQ0YsT0FBTyxPQUFPQTtJQUVsQyxJQUFJYjtJQUVKLElBQUlhLGdCQUFnQkcsYUFBYTtRQUMvQmhCLE1BQU0sSUFBSVosV0FBV3lCO0lBQ3ZCLE9BQU8sSUFBSUcsWUFBWUMsTUFBTSxDQUFDSixPQUFPO1FBQ25DYixNQUFNLElBQUlaLFdBQVd5QixLQUFLWCxNQUFNLEVBQUVXLEtBQUtWLFVBQVUsRUFBRVUsS0FBS0gsVUFBVTtJQUNwRSxPQUFPO1FBQ0xWLE1BQU1YLE9BQU82QixJQUFJLENBQUNMO1FBQ2xCRCxTQUFTRSxRQUFRLEdBQUc7SUFDdEI7SUFFQSxPQUFPZDtBQUNUO0FBRUFtQixPQUFPQyxPQUFPLEdBQUc7SUFDZjVCO0lBQ0FjLE1BQU1GO0lBQ05LO0lBQ0FHO0lBQ0FTLFFBQVFiO0FBQ1Y7QUFFQSx5QkFBeUIsR0FDekIsSUFBSSxDQUFDYyxRQUFRQyxHQUFHLENBQUNDLGlCQUFpQixFQUFFO0lBQ2xDLElBQUk7UUFDRixNQUFNQyxhQUFhdEMsbUJBQU9BLENBQUM7UUFFM0JnQyxtQkFBbUIsR0FBRyxTQUFVZCxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFVCxNQUFNLEVBQUVILE1BQU07WUFDbEUsSUFBSUEsU0FBUyxJQUFJUyxNQUFNQyxRQUFRQyxNQUFNQyxRQUFRVCxRQUFRSDtpQkFDaEQ4QixXQUFXbkIsSUFBSSxDQUFDRCxRQUFRQyxNQUFNQyxRQUFRVCxRQUFRSDtRQUNyRDtRQUVBd0IscUJBQXFCLEdBQUcsU0FBVWpCLE1BQU0sRUFBRUksSUFBSTtZQUM1QyxJQUFJSixPQUFPUCxNQUFNLEdBQUcsSUFBSWEsUUFBUU4sUUFBUUk7aUJBQ25DbUIsV0FBV0osTUFBTSxDQUFDbkIsUUFBUUk7UUFDakM7SUFDRixFQUFFLE9BQU9vQixHQUFHO0lBQ1Ysb0NBQW9DO0lBQ3RDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcz80NGQ2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcih0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgb2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSByZXR1cm4gZGF0YTtcblxuICBsZXQgYnVmO1xuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uY2F0LFxuICBtYXNrOiBfbWFzayxcbiAgdG9BcnJheUJ1ZmZlcixcbiAgdG9CdWZmZXIsXG4gIHVubWFzazogX3VubWFza1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG5pZiAoIXByb2Nlc3MuZW52LldTX05PX0JVRkZFUl9VVElMKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJ2J1ZmZlcnV0aWwnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLm1hc2sgPSBmdW5jdGlvbiAoc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cy51bm1hc2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGVycm9yLlxuICB9XG59XG4iXSwibmFtZXMiOlsiRU1QVFlfQlVGRkVSIiwicmVxdWlyZSIsIkZhc3RCdWZmZXIiLCJCdWZmZXIiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uY2F0IiwibGlzdCIsInRvdGFsTGVuZ3RoIiwibGVuZ3RoIiwidGFyZ2V0IiwiYWxsb2NVbnNhZmUiLCJvZmZzZXQiLCJpIiwiYnVmIiwic2V0IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsIl9tYXNrIiwic291cmNlIiwibWFzayIsIm91dHB1dCIsIl91bm1hc2siLCJ0b0FycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsInNsaWNlIiwidG9CdWZmZXIiLCJkYXRhIiwicmVhZE9ubHkiLCJpc0J1ZmZlciIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiZnJvbSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ1bm1hc2siLCJwcm9jZXNzIiwiZW52IiwiV1NfTk9fQlVGRkVSX1VUSUwiLCJidWZmZXJVdGlsIiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/constants.js":
/*!*************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/constants.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {\n    BINARY_TYPES: [\n        \"nodebuffer\",\n        \"arraybuffer\",\n        \"fragments\"\n    ],\n    EMPTY_BUFFER: Buffer.alloc(0),\n    GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n    kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\n    kListener: Symbol(\"kListener\"),\n    kStatusCode: Symbol(\"status-code\"),\n    kWebSocket: Symbol(\"websocket\"),\n    NOOP: ()=>{}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZDLGNBQWM7UUFBQztRQUFjO1FBQWU7S0FBWTtJQUN4REMsY0FBY0MsT0FBT0MsS0FBSyxDQUFDO0lBQzNCQyxNQUFNO0lBQ05DLHNCQUFzQkMsT0FBTztJQUM3QkMsV0FBV0QsT0FBTztJQUNsQkUsYUFBYUYsT0FBTztJQUNwQkcsWUFBWUgsT0FBTztJQUNuQkksTUFBTSxLQUFPO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanM/ZWNkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVM6IFsnbm9kZWJ1ZmZlcicsICdhcnJheWJ1ZmZlcicsICdmcmFnbWVudHMnXSxcbiAgRU1QVFlfQlVGRkVSOiBCdWZmZXIuYWxsb2MoMCksXG4gIEdVSUQ6ICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnLFxuICBrRm9yT25FdmVudEF0dHJpYnV0ZTogU3ltYm9sKCdrSXNGb3JPbkV2ZW50QXR0cmlidXRlJyksXG4gIGtMaXN0ZW5lcjogU3ltYm9sKCdrTGlzdGVuZXInKSxcbiAga1N0YXR1c0NvZGU6IFN5bWJvbCgnc3RhdHVzLWNvZGUnKSxcbiAga1dlYlNvY2tldDogU3ltYm9sKCd3ZWJzb2NrZXQnKSxcbiAgTk9PUDogKCkgPT4ge31cbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkJJTkFSWV9UWVBFUyIsIkVNUFRZX0JVRkZFUiIsIkJ1ZmZlciIsImFsbG9jIiwiR1VJRCIsImtGb3JPbkV2ZW50QXR0cmlidXRlIiwiU3ltYm9sIiwia0xpc3RlbmVyIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiTk9PUCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/event-target.js":
/*!****************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/event-target.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/constants.js\");\nconst kCode = Symbol(\"kCode\");\nconst kData = Symbol(\"kData\");\nconst kError = Symbol(\"kError\");\nconst kMessage = Symbol(\"kMessage\");\nconst kReason = Symbol(\"kReason\");\nconst kTarget = Symbol(\"kTarget\");\nconst kType = Symbol(\"kType\");\nconst kWasClean = Symbol(\"kWasClean\");\n/**\n * Class representing an event.\n */ class Event {\n    /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */ constructor(type){\n        this[kTarget] = null;\n        this[kType] = type;\n    }\n    /**\n   * @type {*}\n   */ get target() {\n        return this[kTarget];\n    }\n    /**\n   * @type {String}\n   */ get type() {\n        return this[kType];\n    }\n}\nObject.defineProperty(Event.prototype, \"target\", {\n    enumerable: true\n});\nObject.defineProperty(Event.prototype, \"type\", {\n    enumerable: true\n});\n/**\n * Class representing a close event.\n *\n * @extends Event\n */ class CloseEvent extends Event {\n    /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */ constructor(type, options = {}){\n        super(type);\n        this[kCode] = options.code === undefined ? 0 : options.code;\n        this[kReason] = options.reason === undefined ? \"\" : options.reason;\n        this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n    }\n    /**\n   * @type {Number}\n   */ get code() {\n        return this[kCode];\n    }\n    /**\n   * @type {String}\n   */ get reason() {\n        return this[kReason];\n    }\n    /**\n   * @type {Boolean}\n   */ get wasClean() {\n        return this[kWasClean];\n    }\n}\nObject.defineProperty(CloseEvent.prototype, \"code\", {\n    enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"reason\", {\n    enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"wasClean\", {\n    enumerable: true\n});\n/**\n * Class representing an error event.\n *\n * @extends Event\n */ class ErrorEvent extends Event {\n    /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */ constructor(type, options = {}){\n        super(type);\n        this[kError] = options.error === undefined ? null : options.error;\n        this[kMessage] = options.message === undefined ? \"\" : options.message;\n    }\n    /**\n   * @type {*}\n   */ get error() {\n        return this[kError];\n    }\n    /**\n   * @type {String}\n   */ get message() {\n        return this[kMessage];\n    }\n}\nObject.defineProperty(ErrorEvent.prototype, \"error\", {\n    enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, \"message\", {\n    enumerable: true\n});\n/**\n * Class representing a message event.\n *\n * @extends Event\n */ class MessageEvent extends Event {\n    /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */ constructor(type, options = {}){\n        super(type);\n        this[kData] = options.data === undefined ? null : options.data;\n    }\n    /**\n   * @type {*}\n   */ get data() {\n        return this[kData];\n    }\n}\nObject.defineProperty(MessageEvent.prototype, \"data\", {\n    enumerable: true\n});\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */ const EventTarget = {\n    /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */ addEventListener (type, handler, options = {}) {\n        for (const listener of this.listeners(type)){\n            if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n                return;\n            }\n        }\n        let wrapper;\n        if (type === \"message\") {\n            wrapper = function onMessage(data, isBinary) {\n                const event = new MessageEvent(\"message\", {\n                    data: isBinary ? data : data.toString()\n                });\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else if (type === \"close\") {\n            wrapper = function onClose(code, message) {\n                const event = new CloseEvent(\"close\", {\n                    code,\n                    reason: message.toString(),\n                    wasClean: this._closeFrameReceived && this._closeFrameSent\n                });\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else if (type === \"error\") {\n            wrapper = function onError(error) {\n                const event = new ErrorEvent(\"error\", {\n                    error,\n                    message: error.message\n                });\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else if (type === \"open\") {\n            wrapper = function onOpen() {\n                const event = new Event(\"open\");\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else {\n            return;\n        }\n        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n        wrapper[kListener] = handler;\n        if (options.once) {\n            this.once(type, wrapper);\n        } else {\n            this.on(type, wrapper);\n        }\n    },\n    /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */ removeEventListener (type, handler) {\n        for (const listener of this.listeners(type)){\n            if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n                this.removeListener(type, listener);\n                break;\n            }\n        }\n    }\n};\nmodule.exports = {\n    CloseEvent,\n    ErrorEvent,\n    Event,\n    EventTarget,\n    MessageEvent\n};\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */ function callListener(listener, thisArg, event) {\n    if (typeof listener === \"object\" && listener.handleEvent) {\n        listener.handleEvent.call(listener, event);\n    } else {\n        listener.call(thisArg, event);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLG9CQUFvQixFQUFFQyxTQUFTLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFcEQsTUFBTUMsUUFBUUMsT0FBTztBQUNyQixNQUFNQyxRQUFRRCxPQUFPO0FBQ3JCLE1BQU1FLFNBQVNGLE9BQU87QUFDdEIsTUFBTUcsV0FBV0gsT0FBTztBQUN4QixNQUFNSSxVQUFVSixPQUFPO0FBQ3ZCLE1BQU1LLFVBQVVMLE9BQU87QUFDdkIsTUFBTU0sUUFBUU4sT0FBTztBQUNyQixNQUFNTyxZQUFZUCxPQUFPO0FBRXpCOztDQUVDLEdBQ0QsTUFBTVE7SUFDSjs7Ozs7R0FLQyxHQUNEQyxZQUFZQyxJQUFJLENBQUU7UUFDaEIsSUFBSSxDQUFDTCxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUdJO0lBQ2hCO0lBRUE7O0dBRUMsR0FDRCxJQUFJQyxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUNOLFFBQVE7SUFDdEI7SUFFQTs7R0FFQyxHQUNELElBQUlLLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQ0osTUFBTTtJQUNwQjtBQUNGO0FBRUFNLE9BQU9DLGNBQWMsQ0FBQ0wsTUFBTU0sU0FBUyxFQUFFLFVBQVU7SUFBRUMsWUFBWTtBQUFLO0FBQ3BFSCxPQUFPQyxjQUFjLENBQUNMLE1BQU1NLFNBQVMsRUFBRSxRQUFRO0lBQUVDLFlBQVk7QUFBSztBQUVsRTs7OztDQUlDLEdBQ0QsTUFBTUMsbUJBQW1CUjtJQUN2Qjs7Ozs7Ozs7Ozs7O0dBWUMsR0FDREMsWUFBWUMsSUFBSSxFQUFFTyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQzlCLEtBQUssQ0FBQ1A7UUFFTixJQUFJLENBQUNYLE1BQU0sR0FBR2tCLFFBQVFDLElBQUksS0FBS0MsWUFBWSxJQUFJRixRQUFRQyxJQUFJ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QUFJLEVBQUVtQixPQUFPO1FBQy9CLEtBQUssTUFBTUMsWUFBWSxJQUFJLENBQUNDLFNBQVMsQ0FBQ3JCLE1BQU87WUFDM0MsSUFBSW9CLFFBQVEsQ0FBQ2pDLFVBQVUsS0FBS2dDLFdBQVcsQ0FBQ0MsUUFBUSxDQUFDbEMscUJBQXFCLEVBQUU7Z0JBQ3RFLElBQUksQ0FBQ2tELGNBQWMsQ0FBQ3BDLE1BQU1vQjtnQkFDMUI7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBaUIsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZoQztJQUNBTTtJQUNBZDtJQUNBbUI7SUFDQUY7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTWSxhQUFhUCxRQUFRLEVBQUVtQixPQUFPLEVBQUVkLEtBQUs7SUFDNUMsSUFBSSxPQUFPTCxhQUFhLFlBQVlBLFNBQVNvQixXQUFXLEVBQUU7UUFDeERwQixTQUFTb0IsV0FBVyxDQUFDQyxJQUFJLENBQUNyQixVQUFVSztJQUN0QyxPQUFPO1FBQ0xMLFNBQVNxQixJQUFJLENBQUNGLFNBQVNkO0lBQ3pCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanM/MmEzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsga0Zvck9uRXZlbnRBdHRyaWJ1dGUsIGtMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga0NvZGUgPSBTeW1ib2woJ2tDb2RlJyk7XG5jb25zdCBrRGF0YSA9IFN5bWJvbCgna0RhdGEnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgna0Vycm9yJyk7XG5jb25zdCBrTWVzc2FnZSA9IFN5bWJvbCgna01lc3NhZ2UnKTtcbmNvbnN0IGtSZWFzb24gPSBTeW1ib2woJ2tSZWFzb24nKTtcbmNvbnN0IGtUYXJnZXQgPSBTeW1ib2woJ2tUYXJnZXQnKTtcbmNvbnN0IGtUeXBlID0gU3ltYm9sKCdrVHlwZScpO1xuY29uc3Qga1dhc0NsZWFuID0gU3ltYm9sKCdrV2FzQ2xlYW4nKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICB0aGlzW2tUYXJnZXRdID0gbnVsbDtcbiAgICB0aGlzW2tUeXBlXSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2tUYXJnZXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3RhcmdldCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0eXBlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2RlPTBdIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxuICAgKiAgICAgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndhc0NsZWFuPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tDb2RlXSA9IG9wdGlvbnMuY29kZSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuY29kZTtcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5yZWFzb247XG4gICAgdGhpc1trV2FzQ2xlYW5dID0gb3B0aW9ucy53YXNDbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLndhc0NsZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29kZV07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgd2FzQ2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXNba1dhc0NsZWFuXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdjb2RlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAncmVhc29uJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnd2FzQ2xlYW4nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2U9JyddIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0Vycm9yXSA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmVycm9yO1xuICAgIHRoaXNba01lc3NhZ2VdID0gb3B0aW9ucy5tZXNzYWdlID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMubWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpc1trRXJyb3JdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnZXJyb3InLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdtZXNzYWdlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZGF0YT1udWxsXSBUaGUgbWVzc2FnZSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXNba0RhdGFdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlRXZlbnQucHJvdG90eXBlLCAnZGF0YScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdICYmXG4gICAgICAgIGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiZcbiAgICAgICAgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScsIHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHJlYXNvbjogbWVzc2FnZS50b1N0cmluZygpLFxuICAgICAgICAgIHdhc0NsZWFuOiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGhpcy5fY2xvc2VGcmFtZVNlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3JhcHBlcltrRm9yT25FdmVudEF0dHJpYnV0ZV0gPSAhIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdO1xuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGhhbmRsZXI7XG5cbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnQsXG4gIEV2ZW50LFxuICBFdmVudFRhcmdldCxcbiAgTWVzc2FnZUV2ZW50XG59O1xuXG4vKipcbiAqIENhbGwgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbFxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgYCB3aGVuIGNhbGxpbmcgdGhlIGxpc3RlbmVyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc0FyZywgZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCcgJiYgbGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcbiAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKGxpc3RlbmVyLCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJnLCBldmVudCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJrRm9yT25FdmVudEF0dHJpYnV0ZSIsImtMaXN0ZW5lciIsInJlcXVpcmUiLCJrQ29kZSIsIlN5bWJvbCIsImtEYXRhIiwia0Vycm9yIiwia01lc3NhZ2UiLCJrUmVhc29uIiwia1RhcmdldCIsImtUeXBlIiwia1dhc0NsZWFuIiwiRXZlbnQiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJ0YXJnZXQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsImVudW1lcmFibGUiLCJDbG9zZUV2ZW50Iiwib3B0aW9ucyIsImNvZGUiLCJ1bmRlZmluZWQiLCJyZWFzb24iLCJ3YXNDbGVhbiIsIkVycm9yRXZlbnQiLCJlcnJvciIsIm1lc3NhZ2UiLCJNZXNzYWdlRXZlbnQiLCJkYXRhIiwiRXZlbnRUYXJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwiaGFuZGxlciIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwid3JhcHBlciIsIm9uTWVzc2FnZSIsImlzQmluYXJ5IiwiZXZlbnQiLCJ0b1N0cmluZyIsImNhbGxMaXN0ZW5lciIsIm9uQ2xvc2UiLCJfY2xvc2VGcmFtZVJlY2VpdmVkIiwiX2Nsb3NlRnJhbWVTZW50Iiwib25FcnJvciIsIm9uT3BlbiIsIm9uY2UiLCJvbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0aGlzQXJnIiwiaGFuZGxlRXZlbnQiLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/extension.js":
/*!*************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/extension.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/validation.js\");\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */ function push(dest, name, elem) {\n    if (dest[name] === undefined) dest[name] = [\n        elem\n    ];\n    else dest[name].push(elem);\n}\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */ function parse(header) {\n    const offers = Object.create(null);\n    let params = Object.create(null);\n    let mustUnescape = false;\n    let isEscaping = false;\n    let inQuotes = false;\n    let extensionName;\n    let paramName;\n    let start = -1;\n    let code = -1;\n    let end = -1;\n    let i = 0;\n    for(; i < header.length; i++){\n        code = header.charCodeAt(i);\n        if (extensionName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b /* ';' */  || code === 0x2c /* ',' */ ) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                const name = header.slice(start, end);\n                if (code === 0x2c) {\n                    push(offers, name, params);\n                    params = Object.create(null);\n                } else {\n                    extensionName = name;\n                }\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        } else if (paramName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (code === 0x20 || code === 0x09) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                push(params, header.slice(start, end), true);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = Object.create(null);\n                    extensionName = undefined;\n                }\n                start = end = -1;\n            } else if (code === 0x3d /* '=' */  && start !== -1 && end === -1) {\n                paramName = header.slice(start, i);\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        } else {\n            //\n            // The value of a quoted-string after unescaping must conform to the\n            // token ABNF, so only token characters are valid.\n            // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n            //\n            if (isEscaping) {\n                if (tokenChars[code] !== 1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (start === -1) start = i;\n                else if (!mustUnescape) mustUnescape = true;\n                isEscaping = false;\n            } else if (inQuotes) {\n                if (tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (code === 0x22 /* '\"' */  && start !== -1) {\n                    inQuotes = false;\n                    end = i;\n                } else if (code === 0x5c /* '\\' */ ) {\n                    isEscaping = true;\n                } else {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n            } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n                inQuotes = true;\n            } else if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n                if (end === -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                let value = header.slice(start, end);\n                if (mustUnescape) {\n                    value = value.replace(/\\\\/g, \"\");\n                    mustUnescape = false;\n                }\n                push(params, paramName, value);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = Object.create(null);\n                    extensionName = undefined;\n                }\n                paramName = undefined;\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        }\n    }\n    if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    if (end === -1) end = i;\n    const token = header.slice(start, end);\n    if (extensionName === undefined) {\n        push(offers, token, params);\n    } else {\n        if (paramName === undefined) {\n            push(params, token, true);\n        } else if (mustUnescape) {\n            push(params, paramName, token.replace(/\\\\/g, \"\"));\n        } else {\n            push(params, paramName, token);\n        }\n        push(offers, extensionName, params);\n    }\n    return offers;\n}\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */ function format(extensions) {\n    return Object.keys(extensions).map((extension)=>{\n        let configurations = extensions[extension];\n        if (!Array.isArray(configurations)) configurations = [\n            configurations\n        ];\n        return configurations.map((params)=>{\n            return [\n                extension\n            ].concat(Object.keys(params).map((k)=>{\n                let values = params[k];\n                if (!Array.isArray(values)) values = [\n                    values\n                ];\n                return values.map((v)=>v === true ? k : `${k}=${v}`).join(\"; \");\n            })).join(\"; \");\n        }).join(\", \");\n    }).join(\", \");\n}\nmodule.exports = {\n    format,\n    parse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUUvQjs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUM1QixJQUFJRixJQUFJLENBQUNDLEtBQUssS0FBS0UsV0FBV0gsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFBQ0M7S0FBSztTQUM1Q0YsSUFBSSxDQUFDQyxLQUFLLENBQUNGLElBQUksQ0FBQ0c7QUFDdkI7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTRSxNQUFNQyxNQUFNO0lBQ25CLE1BQU1DLFNBQVNDLE9BQU9DLE1BQU0sQ0FBQztJQUM3QixJQUFJQyxTQUFTRixPQUFPQyxNQUFNLENBQUM7SUFDM0IsSUFBSUUsZUFBZTtJQUNuQixJQUFJQyxhQUFhO0lBQ2pCLElBQUlDLFdBQVc7SUFDZixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUMsUUFBUSxDQUFDO0lBQ2IsSUFBSUMsT0FBTyxDQUFDO0lBQ1osSUFBSUMsTUFBTSxDQUFDO0lBQ1gsSUFBSUMsSUFBSTtJQUVSLE1BQU9BLElBQUliLE9BQU9jLE1BQU0sRUFBRUQsSUFBSztRQUM3QkYsT0FBT1gsT0FBT2UsVUFBVSxDQUFDRjtRQUV6QixJQUFJTCxrQkFBa0JWLFdBQVc7WUFDL0IsSUFBSWMsUUFBUSxDQUFDLEtBQUtwQixVQUFVLENBQUNtQixLQUFLLEtBQUssR0FBRztnQkFDeEMsSUFBSUQsVUFBVSxDQUFDLEdBQUdBLFFBQVFHO1lBQzVCLE9BQU8sSUFDTEEsTUFBTSxLQUNMRixDQUFBQSxTQUFTLEtBQUssT0FBTyxPQUFNQSxTQUFTLElBQUcsR0FDeEM7Z0JBQ0EsSUFBSUMsUUFBUSxDQUFDLEtBQUtGLFVBQVUsQ0FBQyxHQUFHRSxNQUFNQztZ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bW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzP2Q1MjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIEFkZHMgYW4gb2ZmZXIgdG8gdGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIGEgcGFyYW1ldGVyIHRvIHRoZSBtYXAgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3QgVGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBleHRlbnNpb24gb3IgcGFyYW1ldGVyIG5hbWVcbiAqIEBwYXJhbSB7KE9iamVjdHxCb29sZWFufFN0cmluZyl9IGVsZW0gVGhlIGV4dGVuc2lvbiBwYXJhbWV0ZXJzIG9yIHRoZVxuICogICAgIHBhcmFtZXRlciB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVzaChkZXN0LCBuYW1lLCBlbGVtKSB7XG4gIGlmIChkZXN0W25hbWVdID09PSB1bmRlZmluZWQpIGRlc3RbbmFtZV0gPSBbZWxlbV07XG4gIGVsc2UgZGVzdFtuYW1lXS5wdXNoKGVsZW0pO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHBhcnNlZCBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IG9mZmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gIGxldCBpc0VzY2FwaW5nID0gZmFsc2U7XG4gIGxldCBpblF1b3RlcyA9IGZhbHNlO1xuICBsZXQgZXh0ZW5zaW9uTmFtZTtcbiAgbGV0IHBhcmFtTmFtZTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBjb2RlID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpICE9PSAwICYmXG4gICAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICAgKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiAvKiAnOycgKi8gfHwgY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBwdXNoKHBhcmFtcywgaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNkIC8qICc9JyAqLyAmJiBzdGFydCAhPT0gLTEgJiYgZW5kID09PSAtMSkge1xuICAgICAgICBwYXJhbU5hbWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgdmFsdWUgb2YgYSBxdW90ZWQtc3RyaW5nIGFmdGVyIHVuZXNjYXBpbmcgbXVzdCBjb25mb3JtIHRvIHRoZVxuICAgICAgLy8gdG9rZW4gQUJORiwgc28gb25seSB0b2tlbiBjaGFyYWN0ZXJzIGFyZSB2YWxpZC5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICAgIC8vXG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZSBpZiAoIW11c3RVbmVzY2FwZSkgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyIC8qICdcIicgKi8gJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NWMgLyogJ1xcJyAqLykge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSAweDNkKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgIT09IC0xICYmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgaW5RdW90ZXMgfHwgY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gIGNvbnN0IHRva2VuID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcHVzaChvZmZlcnMsIHRva2VuLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG9mZmVycztcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBmaWVsZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChleHRlbnNpb25zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhleHRlbnNpb25zKVxuICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgbGV0IGNvbmZpZ3VyYXRpb25zID0gZXh0ZW5zaW9uc1tleHRlbnNpb25dO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3VyYXRpb25zKSkgY29uZmlndXJhdGlvbnMgPSBbY29uZmlndXJhdGlvbnNdO1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIC5tYXAoKHBhcmFtcykgPT4ge1xuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXVxuICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gcGFyYW1zW2tdO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiAodiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkpXG4gICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICB9KVxuICAgIC5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZm9ybWF0LCBwYXJzZSB9O1xuIl0sIm5hbWVzIjpbInRva2VuQ2hhcnMiLCJyZXF1aXJlIiwicHVzaCIsImRlc3QiLCJuYW1lIiwiZWxlbSIsInVuZGVmaW5lZCIsInBhcnNlIiwiaGVhZGVyIiwib2ZmZXJzIiwiT2JqZWN0IiwiY3JlYXRlIiwicGFyYW1zIiwibXVzdFVuZXNjYXBlIiwiaXNFc2NhcGluZyIsImluUXVvdGVzIiwiZXh0ZW5zaW9uTmFtZSIsInBhcmFtTmFtZSIsInN0YXJ0IiwiY29kZSIsImVuZCIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiU3ludGF4RXJyb3IiLCJzbGljZSIsInZhbHVlIiwicmVwbGFjZSIsInRva2VuIiwiZm9ybWF0IiwiZXh0ZW5zaW9ucyIsImtleXMiLCJtYXAiLCJleHRlbnNpb24iLCJjb25maWd1cmF0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImNvbmNhdCIsImsiLCJ2YWx1ZXMiLCJ2Iiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/limiter.js":
/*!***********************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/limiter.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst kDone = Symbol(\"kDone\");\nconst kRun = Symbol(\"kRun\");\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */ class Limiter {\n    /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */ constructor(concurrency){\n        this[kDone] = ()=>{\n            this.pending--;\n            this[kRun]();\n        };\n        this.concurrency = concurrency || Infinity;\n        this.jobs = [];\n        this.pending = 0;\n    }\n    /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */ add(job) {\n        this.jobs.push(job);\n        this[kRun]();\n    }\n    /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */ [kRun]() {\n        if (this.pending === this.concurrency) return;\n        if (this.jobs.length) {\n            const job = this.jobs.shift();\n            this.pending++;\n            job(this[kDone]);\n        }\n    }\n}\nmodule.exports = Limiter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9saW1pdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsUUFBUUMsT0FBTztBQUNyQixNQUFNQyxPQUFPRCxPQUFPO0FBRXBCOzs7Q0FHQyxHQUNELE1BQU1FO0lBQ0o7Ozs7O0dBS0MsR0FDREMsWUFBWUMsV0FBVyxDQUFFO1FBQ3ZCLElBQUksQ0FBQ0wsTUFBTSxHQUFHO1lBQ1osSUFBSSxDQUFDTSxPQUFPO1lBQ1osSUFBSSxDQUFDSixLQUFLO1FBQ1o7UUFDQSxJQUFJLENBQUNHLFdBQVcsR0FBR0EsZUFBZUU7UUFDbEMsSUFBSSxDQUFDQyxJQUFJLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBQ0YsT0FBTyxHQUFHO0lBQ2pCO0lBRUE7Ozs7O0dBS0MsR0FDREcsSUFBSUMsR0FBRyxFQUFFO1FBQ1AsSUFBSSxDQUFDRixJQUFJLENBQUNHLElBQUksQ0FBQ0Q7UUFDZixJQUFJLENBQUNSLEtBQUs7SUFDWjtJQUVBOzs7O0dBSUMsR0FDRCxDQUFDQSxLQUFLLEdBQUc7UUFDUCxJQUFJLElBQUksQ0FBQ0ksT0FBTyxLQUFLLElBQUksQ0FBQ0QsV0FBVyxFQUFFO1FBRXZDLElBQUksSUFBSSxDQUFDRyxJQUFJLENBQUNJLE1BQU0sRUFBRTtZQUNwQixNQUFNRixNQUFNLElBQUksQ0FBQ0YsSUFBSSxDQUFDSyxLQUFLO1lBRTNCLElBQUksQ0FBQ1AsT0FBTztZQUNaSSxJQUFJLElBQUksQ0FBQ1YsTUFBTTtRQUNqQjtJQUNGO0FBQ0Y7QUFFQWMsT0FBT0MsT0FBTyxHQUFHWiIsInNvdXJjZXMiOlsid2VicGFjazovL3doYXRzYXBwLWFpLWNybS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanM/OTA3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xuXG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvYXN5bmMtbGltaXRlclxuICovXG5jbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygam9icyBhbGxvd2VkXG4gICAqICAgICB0byBydW4gY29uY3VycmVudGx5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeSkge1xuICAgIHRoaXNba0RvbmVdID0gKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nLS07XG4gICAgICB0aGlzW2tSdW5dKCk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XG4gICAgdGhpcy5qb2JzID0gW107XG4gICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgam9iIHRvIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gam9iIFRoZSBqb2IgdG8gcnVuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIHRoaXNba1J1bl0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcblxuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XG4iXSwibmFtZXMiOlsia0RvbmUiLCJTeW1ib2wiLCJrUnVuIiwiTGltaXRlciIsImNvbnN0cnVjdG9yIiwiY29uY3VycmVuY3kiLCJwZW5kaW5nIiwiSW5maW5pdHkiLCJqb2JzIiwiYWRkIiwiam9iIiwicHVzaCIsImxlbmd0aCIsInNoaWZ0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/permessage-deflate.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/permessage-deflate.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([\n    0x00,\n    0x00,\n    0xff,\n    0xff\n]);\nconst kPerMessageDeflate = Symbol(\"permessage-deflate\");\nconst kTotalLength = Symbol(\"total-length\");\nconst kCallback = Symbol(\"callback\");\nconst kBuffers = Symbol(\"buffers\");\nconst kError = Symbol(\"error\");\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n/**\n * permessage-deflate implementation.\n */ class PerMessageDeflate {\n    /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */ constructor(options, isServer, maxPayload){\n        this._maxPayload = maxPayload | 0;\n        this._options = options || {};\n        this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n        this._isServer = !!isServer;\n        this._deflate = null;\n        this._inflate = null;\n        this.params = null;\n        if (!zlibLimiter) {\n            const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n            zlibLimiter = new Limiter(concurrency);\n        }\n    }\n    /**\n   * @type {String}\n   */ static get extensionName() {\n        return \"permessage-deflate\";\n    }\n    /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */ offer() {\n        const params = {};\n        if (this._options.serverNoContextTakeover) {\n            params.server_no_context_takeover = true;\n        }\n        if (this._options.clientNoContextTakeover) {\n            params.client_no_context_takeover = true;\n        }\n        if (this._options.serverMaxWindowBits) {\n            params.server_max_window_bits = this._options.serverMaxWindowBits;\n        }\n        if (this._options.clientMaxWindowBits) {\n            params.client_max_window_bits = this._options.clientMaxWindowBits;\n        } else if (this._options.clientMaxWindowBits == null) {\n            params.client_max_window_bits = true;\n        }\n        return params;\n    }\n    /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */ accept(configurations) {\n        configurations = this.normalizeParams(configurations);\n        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n        return this.params;\n    }\n    /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */ cleanup() {\n        if (this._inflate) {\n            this._inflate.close();\n            this._inflate = null;\n        }\n        if (this._deflate) {\n            const callback = this._deflate[kCallback];\n            this._deflate.close();\n            this._deflate = null;\n            if (callback) {\n                callback(new Error(\"The deflate stream was closed while data was being processed\"));\n            }\n        }\n    }\n    /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsServer(offers) {\n        const opts = this._options;\n        const accepted = offers.find((params)=>{\n            if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n                return false;\n            }\n            return true;\n        });\n        if (!accepted) {\n            throw new Error(\"None of the extension offers can be accepted\");\n        }\n        if (opts.serverNoContextTakeover) {\n            accepted.server_no_context_takeover = true;\n        }\n        if (opts.clientNoContextTakeover) {\n            accepted.client_no_context_takeover = true;\n        }\n        if (typeof opts.serverMaxWindowBits === \"number\") {\n            accepted.server_max_window_bits = opts.serverMaxWindowBits;\n        }\n        if (typeof opts.clientMaxWindowBits === \"number\") {\n            accepted.client_max_window_bits = opts.clientMaxWindowBits;\n        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n            delete accepted.client_max_window_bits;\n        }\n        return accepted;\n    }\n    /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsClient(response) {\n        const params = response[0];\n        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n            throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n        }\n        if (!params.client_max_window_bits) {\n            if (typeof this._options.clientMaxWindowBits === \"number\") {\n                params.client_max_window_bits = this._options.clientMaxWindowBits;\n            }\n        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n            throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n        }\n        return params;\n    }\n    /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */ normalizeParams(configurations) {\n        configurations.forEach((params)=>{\n            Object.keys(params).forEach((key)=>{\n                let value = params[key];\n                if (value.length > 1) {\n                    throw new Error(`Parameter \"${key}\" must have only a single value`);\n                }\n                value = value[0];\n                if (key === \"client_max_window_bits\") {\n                    if (value !== true) {\n                        const num = +value;\n                        if (!Number.isInteger(num) || num < 8 || num > 15) {\n                            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                        }\n                        value = num;\n                    } else if (!this._isServer) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                } else if (key === \"server_max_window_bits\") {\n                    const num = +value;\n                    if (!Number.isInteger(num) || num < 8 || num > 15) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                    value = num;\n                } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n                    if (value !== true) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                } else {\n                    throw new Error(`Unknown parameter \"${key}\"`);\n                }\n                params[key] = value;\n            });\n        });\n        return configurations;\n    }\n    /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ decompress(data, fin, callback) {\n        zlibLimiter.add((done)=>{\n            this._decompress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ compress(data, fin, callback) {\n        zlibLimiter.add((done)=>{\n            this._compress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _decompress(data, fin, callback) {\n        const endpoint = this._isServer ? \"client\" : \"server\";\n        if (!this._inflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._inflate = zlib.createInflateRaw({\n                ...this._options.zlibInflateOptions,\n                windowBits\n            });\n            this._inflate[kPerMessageDeflate] = this;\n            this._inflate[kTotalLength] = 0;\n            this._inflate[kBuffers] = [];\n            this._inflate.on(\"error\", inflateOnError);\n            this._inflate.on(\"data\", inflateOnData);\n        }\n        this._inflate[kCallback] = callback;\n        this._inflate.write(data);\n        if (fin) this._inflate.write(TRAILER);\n        this._inflate.flush(()=>{\n            const err = this._inflate[kError];\n            if (err) {\n                this._inflate.close();\n                this._inflate = null;\n                callback(err);\n                return;\n            }\n            const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n            if (this._inflate._readableState.endEmitted) {\n                this._inflate.close();\n                this._inflate = null;\n            } else {\n                this._inflate[kTotalLength] = 0;\n                this._inflate[kBuffers] = [];\n                if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                    this._inflate.reset();\n                }\n            }\n            callback(null, data);\n        });\n    }\n    /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _compress(data, fin, callback) {\n        const endpoint = this._isServer ? \"server\" : \"client\";\n        if (!this._deflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._deflate = zlib.createDeflateRaw({\n                ...this._options.zlibDeflateOptions,\n                windowBits\n            });\n            this._deflate[kTotalLength] = 0;\n            this._deflate[kBuffers] = [];\n            this._deflate.on(\"data\", deflateOnData);\n        }\n        this._deflate[kCallback] = callback;\n        this._deflate.write(data);\n        this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{\n            if (!this._deflate) {\n                //\n                // The deflate stream was closed while data was being processed.\n                //\n                return;\n            }\n            let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n            if (fin) {\n                data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n            }\n            //\n            // Ensure that the callback will not be called again in\n            // `PerMessageDeflate#cleanup()`.\n            //\n            this._deflate[kCallback] = null;\n            this._deflate[kTotalLength] = 0;\n            this._deflate[kBuffers] = [];\n            if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                this._deflate.reset();\n            }\n            callback(null, data);\n        });\n    }\n}\nmodule.exports = PerMessageDeflate;\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function deflateOnData(chunk) {\n    this[kBuffers].push(chunk);\n    this[kTotalLength] += chunk.length;\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function inflateOnData(chunk) {\n    this[kTotalLength] += chunk.length;\n    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n        this[kBuffers].push(chunk);\n        return;\n    }\n    this[kError] = new RangeError(\"Max payload size exceeded\");\n    this[kError].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n    this[kError][kStatusCode] = 1009;\n    this.removeListener(\"data\", inflateOnData);\n    this.reset();\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */ function inflateOnError(err) {\n    //\n    // There is no need to call `Zlib#close()` as the handle is automatically\n    // closed when an error is emitted.\n    //\n    this[kPerMessageDeflate]._inflate = null;\n    err[kStatusCode] = 1007;\n    this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVyQixNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQztBQUN4QixNQUFNLEVBQUVHLFdBQVcsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUVoQyxNQUFNSSxhQUFhQyxNQUFNLENBQUNDLE9BQU9DLE9BQU8sQ0FBQztBQUN6QyxNQUFNQyxVQUFVSCxPQUFPSSxJQUFJLENBQUM7SUFBQztJQUFNO0lBQU07SUFBTTtDQUFLO0FBQ3BELE1BQU1DLHFCQUFxQkosT0FBTztBQUNsQyxNQUFNSyxlQUFlTCxPQUFPO0FBQzVCLE1BQU1NLFlBQVlOLE9BQU87QUFDekIsTUFBTU8sV0FBV1AsT0FBTztBQUN4QixNQUFNUSxTQUFTUixPQUFPO0FBRXRCLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUscUZBQXFGO0FBQ3JGLG1EQUFtRDtBQUNuRCxFQUFFO0FBQ0YscUVBQXFFO0FBQ3JFLEVBQUU7QUFDRixJQUFJUztBQUVKOztDQUVDLEdBQ0QsTUFBTUM7SUFDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1QkMsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsQ0FBRTtRQUN6QyxJQUFJLENBQUNDLFdBQVcsR0FBR0QsYUFBYTtRQUNoQyxJQUFJLENBQUNFLFFBQVEsR0FBR0osV0FBVyxDQUFDO1FBQzVCLElBQUksQ0FBQ0ssVUFBVSxHQUNiLElBQUksQ0FBQ0QsUUFBUSxDQUFDRSxTQUFTLEtBQUtDLFlBQVksSUFBSSxDQUFDSCxRQUFRLENBQUNFLFNBQVMsR0FBRztRQUNwRSxJQUFJLENBQUNFLFNBQVMsR0FBRyxDQUFDLENBQUNQO1FBQ25CLElBQUksQ0FBQ1EsUUFBUSxHQUFH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SUFBSSxDQUFDRDtRQUNwQjtJQUNGO0lBRUEsSUFBSSxDQUFDcEYsT0FBTyxHQUFHLElBQUlzRixXQUFXO0lBQzlCLElBQUksQ0FBQ3RGLE9BQU8sQ0FBQ3VGLElBQUksR0FBRztJQUNwQixJQUFJLENBQUN2RixPQUFPLENBQUNYLFlBQVksR0FBRztJQUM1QixJQUFJLENBQUNtRyxjQUFjLENBQUMsUUFBUW5CO0lBQzVCLElBQUksQ0FBQ00sS0FBSztBQUNaO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTUCxlQUFlVixHQUFHO0lBQ3pCLEVBQUU7SUFDRix5RUFBeUU7SUFDekUsbUNBQW1DO0lBQ25DLEVBQUU7SUFDRixJQUFJLENBQUM5RCxtQkFBbUIsQ0FBQ2tCLFFBQVEsR0FBRztJQUNwQzRDLEdBQUcsQ0FBQ3JFLFlBQVksR0FBRztJQUNuQixJQUFJLENBQUNTLFVBQVUsQ0FBQzREO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdHNhcHAtYWktY3JtLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy93cy9saWIvcGVybWVzc2FnZS1kZWZsYXRlLmpzP2I3OWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5jb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgTGltaXRlciA9IHJlcXVpcmUoJy4vbGltaXRlcicpO1xuY29uc3QgeyBrU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcbmNvbnN0IGtQZXJNZXNzYWdlRGVmbGF0ZSA9IFN5bWJvbCgncGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woJ2J1ZmZlcnMnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcblxuLy9cbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG4vL1xuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXG4vL1xubGV0IHpsaWJMaW1pdGVyO1xuXG4vKipcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHNdIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXG4gICAqICAgICBhY2tub3dsZWRnZSBkaXNhYmxpbmcgb2YgY2xpZW50IGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbmN1cnJlbmN5TGltaXQ9MTBdIFRoZSBudW1iZXIgb2YgY29uY3VycmVudFxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHNdIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcbiAgICogICAgIGRpc2FibGluZyBvZiBzZXJ2ZXIgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTEwMjRdIFNpemUgKGluIGJ5dGVzKSBiZWxvdyB3aGljaFxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGRlZmxhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGluZmxhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTZXJ2ZXI9ZmFsc2VdIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvclxuICAgKiAgICAgY2xpZW50IG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxuICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgZXh0ZW5zaW9uIG9mZmVycyBjYW4gYmUgYWNjZXB0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIG9yIGludmFsaWQgcGFyYW1ldGVyIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdlcnJvcicsIGluZmxhdGVPbkVycm9yKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcblxuICAgIHRoaXMuX2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5faW5mbGF0ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xuXG4gICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdkYXRhJywgZGVmbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikge1xuICAgICAgICBkYXRhID0gbmV3IEZhc3RCdWZmZXIoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5sZW5ndGggLSA0KTtcbiAgICAgIH1cblxuICAgICAgLy9cbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW4gaW5cbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlck1lc3NhZ2VEZWZsYXRlO1xuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuRGVmbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xuXG4gIGlmIChcbiAgICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8XG4gICAgdGhpc1trVG90YWxMZW5ndGhdIDw9IHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZFxuICApIHtcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzW2tFcnJvcl0gPSBuZXcgUmFuZ2VFcnJvcignTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcpO1xuICB0aGlzW2tFcnJvcl0uY29kZSA9ICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnO1xuICB0aGlzW2tFcnJvcl1ba1N0YXR1c0NvZGVdID0gMTAwOTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IoZXJyKSB7XG4gIC8vXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcbiAgLy8gY2xvc2VkIHdoZW4gYW4gZXJyb3IgaXMgZW1pdHRlZC5cbiAgLy9cbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IDEwMDc7XG4gIHRoaXNba0NhbGxiYWNrXShlcnIpO1xufVxuIl0sIm5hbWVzIjpbInpsaWIiLCJyZXF1aXJlIiwiYnVmZmVyVXRpbCIsIkxpbWl0ZXIiLCJrU3RhdHVzQ29kZSIsIkZhc3RCdWZmZXIiLCJCdWZmZXIiLCJTeW1ib2wiLCJzcGVjaWVzIiwiVFJBSUxFUiIsImZyb20iLCJrUGVyTWVzc2FnZURlZmxhdGUiLCJrVG90YWxMZW5ndGgiLCJrQ2FsbGJhY2siLCJrQnVmZmVycyIsImtFcnJvciIsInpsaWJMaW1pdGVyIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJpc1NlcnZlciIsIm1heFBheWxvYWQiLCJfbWF4UGF5bG9hZCIsIl9vcHRpb25zIiwiX3RocmVzaG9sZCIsInRocmVzaG9sZCIsInVuZGVmaW5lZCIsIl9pc1NlcnZlciIsIl9kZWZsYXRlIiwiX2luZmxhdGUiLCJwYXJhbXMiLCJjb25jdXJyZW5jeSIsImNvbmN1cnJlbmN5TGltaXQiLCJleHRlbnNpb25OYW1lIiwib2ZmZXIiLCJzZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciIsInNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyIiwiY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIiLCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciIsInNlcnZlck1heFdpbmRvd0JpdHMiLCJzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzIiwiY2xpZW50TWF4V2luZG93Qml0cyIsImNsaWVudF9tYXhfd2luZG93X2JpdHMiLCJhY2NlcHQiLCJjb25maWd1cmF0aW9ucyIsIm5vcm1hbGl6ZVBhcmFtcyIsImFjY2VwdEFzU2VydmVyIiwiYWNjZXB0QXNDbGllbnQiLCJjbGVhbnVwIiwiY2xvc2UiLCJjYWxsYmFjayIsIkVycm9yIiwib2ZmZXJzIiwib3B0cyIsImFjY2VwdGVkIiwiZmluZCIsInJlc3BvbnNlIiwiZm9yRWFjaCIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJ2YWx1ZSIsImxlbmd0aCIsIm51bSIsIk51bWJlciIsImlzSW50ZWdlciIsIlR5cGVFcnJvciIsImRlY29tcHJlc3MiLCJkYXRhIiwiZmluIiwiYWRkIiwiZG9uZSIsIl9kZWNvbXByZXNzIiwiZXJyIiwicmVzdWx0IiwiY29tcHJlc3MiLCJfY29tcHJlc3MiLCJlbmRwb2ludCIsIndpbmRvd0JpdHMiLCJaX0RFRkFVTFRfV0lORE9XQklUUyIsImNyZWF0ZUluZmxhdGVSYXciLCJ6bGliSW5mbGF0ZU9wdGlvbnMiLCJvbiIsImluZmxhdGVPbkVycm9yIiwiaW5mbGF0ZU9uRGF0YSIsIndyaXRlIiwiZmx1c2giLCJjb25jYXQiLCJfcmVhZGFibGVTdGF0ZSIsImVuZEVtaXR0ZWQiLCJyZXNldCIsImNyZWF0ZURlZmxhdGVSYXciLCJ6bGliRGVmbGF0ZU9wdGlvbnMiLCJkZWZsYXRlT25EYXRhIiwiWl9TWU5DX0ZMVVNIIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsIm1vZHVsZSIsImV4cG9ydHMiLCJjaHVuayIsInB1c2giLCJSYW5nZUVycm9yIiwiY29kZSIsInJlbW92ZUxpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/receiver.js":
/*!************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/receiver.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/permessage-deflate.js\");\nconst { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/validation.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */ class Receiver extends Writable {\n    /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */ constructor(options = {}){\n        super();\n        this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;\n        this._binaryType = options.binaryType || BINARY_TYPES[0];\n        this._extensions = options.extensions || {};\n        this._isServer = !!options.isServer;\n        this._maxPayload = options.maxPayload | 0;\n        this._skipUTF8Validation = !!options.skipUTF8Validation;\n        this[kWebSocket] = undefined;\n        this._bufferedBytes = 0;\n        this._buffers = [];\n        this._compressed = false;\n        this._payloadLength = 0;\n        this._mask = undefined;\n        this._fragmented = 0;\n        this._masked = false;\n        this._fin = false;\n        this._opcode = 0;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragments = [];\n        this._errored = false;\n        this._loop = false;\n        this._state = GET_INFO;\n    }\n    /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */ _write(chunk, encoding, cb) {\n        if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n        this._bufferedBytes += chunk.length;\n        this._buffers.push(chunk);\n        this.startLoop(cb);\n    }\n    /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */ consume(n) {\n        this._bufferedBytes -= n;\n        if (n === this._buffers[0].length) return this._buffers.shift();\n        if (n < this._buffers[0].length) {\n            const buf = this._buffers[0];\n            this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n            return new FastBuffer(buf.buffer, buf.byteOffset, n);\n        }\n        const dst = Buffer.allocUnsafe(n);\n        do {\n            const buf = this._buffers[0];\n            const offset = dst.length - n;\n            if (n >= buf.length) {\n                dst.set(this._buffers.shift(), offset);\n            } else {\n                dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n                this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n            }\n            n -= buf.length;\n        }while (n > 0);\n        return dst;\n    }\n    /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ startLoop(cb) {\n        this._loop = true;\n        do {\n            switch(this._state){\n                case GET_INFO:\n                    this.getInfo(cb);\n                    break;\n                case GET_PAYLOAD_LENGTH_16:\n                    this.getPayloadLength16(cb);\n                    break;\n                case GET_PAYLOAD_LENGTH_64:\n                    this.getPayloadLength64(cb);\n                    break;\n                case GET_MASK:\n                    this.getMask();\n                    break;\n                case GET_DATA:\n                    this.getData(cb);\n                    break;\n                case INFLATING:\n                case DEFER_EVENT:\n                    this._loop = false;\n                    return;\n            }\n        }while (this._loop);\n        if (!this._errored) cb();\n    }\n    /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ getInfo(cb) {\n        if (this._bufferedBytes < 2) {\n            this._loop = false;\n            return;\n        }\n        const buf = this.consume(2);\n        if ((buf[0] & 0x30) !== 0x00) {\n            const error = this.createError(RangeError, \"RSV2 and RSV3 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_2_3\");\n            cb(error);\n            return;\n        }\n        const compressed = (buf[0] & 0x40) === 0x40;\n        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n            const error = this.createError(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n            cb(error);\n            return;\n        }\n        this._fin = (buf[0] & 0x80) === 0x80;\n        this._opcode = buf[0] & 0x0f;\n        this._payloadLength = buf[1] & 0x7f;\n        if (this._opcode === 0x00) {\n            if (compressed) {\n                const error = this.createError(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n                cb(error);\n                return;\n            }\n            if (!this._fragmented) {\n                const error = this.createError(RangeError, \"invalid opcode 0\", true, 1002, \"WS_ERR_INVALID_OPCODE\");\n                cb(error);\n                return;\n            }\n            this._opcode = this._fragmented;\n        } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n            if (this._fragmented) {\n                const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n                cb(error);\n                return;\n            }\n            this._compressed = compressed;\n        } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n            if (!this._fin) {\n                const error = this.createError(RangeError, \"FIN must be set\", true, 1002, \"WS_ERR_EXPECTED_FIN\");\n                cb(error);\n                return;\n            }\n            if (compressed) {\n                const error = this.createError(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n                cb(error);\n                return;\n            }\n            if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {\n                const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\");\n                cb(error);\n                return;\n            }\n        } else {\n            const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n            cb(error);\n            return;\n        }\n        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n        this._masked = (buf[1] & 0x80) === 0x80;\n        if (this._isServer) {\n            if (!this._masked) {\n                const error = this.createError(RangeError, \"MASK must be set\", true, 1002, \"WS_ERR_EXPECTED_MASK\");\n                cb(error);\n                return;\n            }\n        } else if (this._masked) {\n            const error = this.createError(RangeError, \"MASK must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_MASK\");\n            cb(error);\n            return;\n        }\n        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n        else this.haveLength(cb);\n    }\n    /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ getPayloadLength16(cb) {\n        if (this._bufferedBytes < 2) {\n            this._loop = false;\n            return;\n        }\n        this._payloadLength = this.consume(2).readUInt16BE(0);\n        this.haveLength(cb);\n    }\n    /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ getPayloadLength64(cb) {\n        if (this._bufferedBytes < 8) {\n            this._loop = false;\n            return;\n        }\n        const buf = this.consume(8);\n        const num = buf.readUInt32BE(0);\n        //\n        // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n        // if payload length is greater than this number.\n        //\n        if (num > Math.pow(2, 53 - 32) - 1) {\n            const error = this.createError(RangeError, \"Unsupported WebSocket frame: payload length > 2^53 - 1\", false, 1009, \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\");\n            cb(error);\n            return;\n        }\n        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n        this.haveLength(cb);\n    }\n    /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ haveLength(cb) {\n        if (this._payloadLength && this._opcode < 0x08) {\n            this._totalPayloadLength += this._payloadLength;\n            if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n                const error = this.createError(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\");\n                cb(error);\n                return;\n            }\n        }\n        if (this._masked) this._state = GET_MASK;\n        else this._state = GET_DATA;\n    }\n    /**\n   * Reads mask bytes.\n   *\n   * @private\n   */ getMask() {\n        if (this._bufferedBytes < 4) {\n            this._loop = false;\n            return;\n        }\n        this._mask = this.consume(4);\n        this._state = GET_DATA;\n    }\n    /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ getData(cb) {\n        let data = EMPTY_BUFFER;\n        if (this._payloadLength) {\n            if (this._bufferedBytes < this._payloadLength) {\n                this._loop = false;\n                return;\n            }\n            data = this.consume(this._payloadLength);\n            if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n                unmask(data, this._mask);\n            }\n        }\n        if (this._opcode > 0x07) {\n            this.controlMessage(data, cb);\n            return;\n        }\n        if (this._compressed) {\n            this._state = INFLATING;\n            this.decompress(data, cb);\n            return;\n        }\n        if (data.length) {\n            //\n            // This message is not compressed so its length is the sum of the payload\n            // length of all fragments.\n            //\n            this._messageLength = this._totalPayloadLength;\n            this._fragments.push(data);\n        }\n        this.dataMessage(cb);\n    }\n    /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */ decompress(data, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        perMessageDeflate.decompress(data, this._fin, (err, buf)=>{\n            if (err) return cb(err);\n            if (buf.length) {\n                this._messageLength += buf.length;\n                if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n                    const error = this.createError(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\");\n                    cb(error);\n                    return;\n                }\n                this._fragments.push(buf);\n            }\n            this.dataMessage(cb);\n            if (this._state === GET_INFO) this.startLoop(cb);\n        });\n    }\n    /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ dataMessage(cb) {\n        if (!this._fin) {\n            this._state = GET_INFO;\n            return;\n        }\n        const messageLength = this._messageLength;\n        const fragments = this._fragments;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragmented = 0;\n        this._fragments = [];\n        if (this._opcode === 2) {\n            let data;\n            if (this._binaryType === \"nodebuffer\") {\n                data = concat(fragments, messageLength);\n            } else if (this._binaryType === \"arraybuffer\") {\n                data = toArrayBuffer(concat(fragments, messageLength));\n            } else {\n                data = fragments;\n            }\n            if (this._allowSynchronousEvents) {\n                this.emit(\"message\", data, true);\n                this._state = GET_INFO;\n            } else {\n                this._state = DEFER_EVENT;\n                setImmediate(()=>{\n                    this.emit(\"message\", data, true);\n                    this._state = GET_INFO;\n                    this.startLoop(cb);\n                });\n            }\n        } else {\n            const buf = concat(fragments, messageLength);\n            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                const error = this.createError(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                cb(error);\n                return;\n            }\n            if (this._state === INFLATING || this._allowSynchronousEvents) {\n                this.emit(\"message\", buf, false);\n                this._state = GET_INFO;\n            } else {\n                this._state = DEFER_EVENT;\n                setImmediate(()=>{\n                    this.emit(\"message\", buf, false);\n                    this._state = GET_INFO;\n                    this.startLoop(cb);\n                });\n            }\n        }\n    }\n    /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */ controlMessage(data, cb) {\n        if (this._opcode === 0x08) {\n            if (data.length === 0) {\n                this._loop = false;\n                this.emit(\"conclude\", 1005, EMPTY_BUFFER);\n                this.end();\n            } else {\n                const code = data.readUInt16BE(0);\n                if (!isValidStatusCode(code)) {\n                    const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, \"WS_ERR_INVALID_CLOSE_CODE\");\n                    cb(error);\n                    return;\n                }\n                const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);\n                if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                    const error = this.createError(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                    cb(error);\n                    return;\n                }\n                this._loop = false;\n                this.emit(\"conclude\", code, buf);\n                this.end();\n            }\n            this._state = GET_INFO;\n            return;\n        }\n        if (this._allowSynchronousEvents) {\n            this.emit(this._opcode === 0x09 ? \"ping\" : \"pong\", data);\n            this._state = GET_INFO;\n        } else {\n            this._state = DEFER_EVENT;\n            setImmediate(()=>{\n                this.emit(this._opcode === 0x09 ? \"ping\" : \"pong\", data);\n                this._state = GET_INFO;\n                this.startLoop(cb);\n            });\n        }\n    }\n    /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */ createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n        this._loop = false;\n        this._errored = true;\n        const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n        Error.captureStackTrace(err, this.createError);\n        err.code = errorCode;\n        err[kStatusCode] = statusCode;\n        return err;\n    }\n}\nmodule.exports = Receiver;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsUUFBUSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTdCLE1BQU1DLG9CQUFvQkQsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUNKRSxZQUFZLEVBQ1pDLFlBQVksRUFDWkMsV0FBVyxFQUNYQyxVQUFVLEVBQ1gsR0FBR0wsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVNLE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxNQUFNLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFDbEQsTUFBTSxFQUFFUyxpQkFBaUIsRUFBRUMsV0FBVyxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBRW5ELE1BQU1XLGFBQWFDLE1BQU0sQ0FBQ0MsT0FBT0MsT0FBTyxDQUFDO0FBRXpDLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLHdCQUF3QjtBQUM5QixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxjQUFjO0FBRXBCOzs7O0NBSUMsR0FDRCxNQUFNQyxpQkFBaUJ2QjtJQUNyQjs7Ozs7Ozs7Ozs7Ozs7O0dBZUMsR0FDRHdCLFlBQVlDLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDeEIsS0FBSztRQUVMLElBQUksQ0FBQ0MsdUJBQXVCLEdBQzFCRCxRQUFRRSxzQkFBc0IsS0FBS0MsWUFDL0JILFFBQVFFLHNCQUFzQixHQUM5QjtRQUNOLElBQUksQ0FBQ0UsV0FBVyxHQUFHSixRQUFRSyxVQUFVLElBQUkzQixZQUFZLENBQUMsRUFBRTtRQUN4RCxJQUFJLENBQUM0QixXQUFXLEdBQUdOLFFBQVFPLFVBQVUsSUFBSSxDQUFDO1FBQzFDLElBQUksQ0FBQ0MsU0FBUyxHQUFHLENBQUMsQ0FBQ1IsUUFBUVMsUUFBUTtRQUNuQyxJ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LElBQUksQ0FBQ3JELEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0QsUUFBUSxHQUFHO1FBRWhCLE1BQU0wQyxNQUFNLElBQUlRLFVBQ2RFLFNBQVMsQ0FBQyx5QkFBeUIsRUFBRUQsUUFBUSxDQUFDLEdBQUdBO1FBR25ESixNQUFNUSxpQkFBaUIsQ0FBQ2IsS0FBSyxJQUFJLENBQUNmLFdBQVc7UUFDN0NlLElBQUlPLElBQUksR0FBR0s7UUFDWFosR0FBRyxDQUFDeEYsWUFBWSxHQUFHbUc7UUFDbkIsT0FBT1g7SUFDVDtBQUNGO0FBRUFjLE9BQU9DLE9BQU8sR0FBR3JGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdHNhcHAtYWktY3JtLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy93cy9saWIvcmVjZWl2ZXIuanM/N2M4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBrU3RhdHVzQ29kZSxcbiAga1dlYlNvY2tldFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGNvbmNhdCwgdG9BcnJheUJ1ZmZlciwgdW5tYXNrIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlLCBpc1ZhbGlkVVRGOCB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuXG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5jb25zdCBERUZFUl9FVkVOVCA9IDY7XG5cbi8qKlxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBXcml0YWJsZVxuICovXG5jbGFzcyBSZWNlaXZlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXJcbiAgICogICAgIGFueSBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5iaW5hcnlUeXBlPW5vZGVidWZmZXJdIFRoZSB0eXBlIGZvciBiaW5hcnkgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWRcbiAgICogICAgIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1NlcnZlcj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdG8gb3BlcmF0ZSBpblxuICAgKiAgICAgY2xpZW50IG9yIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMgPVxuICAgICAgb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHNcbiAgICAgICAgOiB0cnVlO1xuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBvcHRpb25zLmJpbmFyeVR5cGUgfHwgQklOQVJZX1RZUEVTWzBdO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBvcHRpb25zLmV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIW9wdGlvbnMuaXNTZXJ2ZXI7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG9wdGlvbnMubWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uID0gISFvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbjtcbiAgICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fYnVmZmVycyA9IFtdO1xuXG4gICAgdGhpcy5fY29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21hc2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgdGhpcy5fbWFza2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZmluID0gZmFsc2U7XG4gICAgdGhpcy5fb3Bjb2RlID0gMDtcblxuICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICB0aGlzLl9lcnJvcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyBgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIFRoZSBjaHVuayBvZiBkYXRhIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIGBjaHVua2BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9zdGF0ZSA9PSBHRVRfSU5GTykgcmV0dXJuIGNiKCk7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLl9idWZmZXJzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdW1lKG4pIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XG5cbiAgICBpZiAobiA9PT0gdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XG5cbiAgICBpZiAobiA8IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICBidWYuYnVmZmVyLFxuICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXG4gICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pO1xuICAgIH1cblxuICAgIGNvbnN0IGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICBjb25zdCBvZmZzZXQgPSBkc3QubGVuZ3RoIC0gbjtcblxuICAgICAgaWYgKG4gPj0gYnVmLmxlbmd0aCkge1xuICAgICAgICBkc3Quc2V0KHRoaXMuX2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRzdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJzWzBdID0gbmV3IEZhc3RCdWZmZXIoXG4gICAgICAgICAgYnVmLmJ1ZmZlcixcbiAgICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXG4gICAgICAgICAgYnVmLmxlbmd0aCAtIG5cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSBidWYubGVuZ3RoO1xuICAgIH0gd2hpbGUgKG4gPiAwKTtcblxuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBwYXJzaW5nIGxvb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydExvb3AoY2IpIHtcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgY2FzZSBHRVRfSU5GTzpcbiAgICAgICAgICB0aGlzLmdldEluZm8oY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF8xNjpcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGgxNihjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzY0OlxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfTUFTSzpcbiAgICAgICAgICB0aGlzLmdldE1hc2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfREFUQTpcbiAgICAgICAgICB0aGlzLmdldERhdGEoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIElORkxBVElORzpcbiAgICAgICAgY2FzZSBERUZFUl9FVkVOVDpcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRoaXMuX2xvb3ApO1xuXG4gICAgaWYgKCF0aGlzLl9lcnJvcmVkKSBjYigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBmaXJzdCB0d28gYnl0ZXMgb2YgYSBmcmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEluZm8oY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoMik7XG5cbiAgICBpZiAoKGJ1ZlswXSAmIDB4MzApICE9PSAweDAwKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YyIGFuZCBSU1YzIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzJfMydcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9maW4gPSAoYnVmWzBdICYgMHg4MCkgPT09IDB4ODA7XG4gICAgdGhpcy5fb3Bjb2RlID0gYnVmWzBdICYgMHgwZjtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gYnVmWzFdICYgMHg3ZjtcblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDApIHtcbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBvcGNvZGUgMCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29wY29kZSA9IHRoaXMuX2ZyYWdtZW50ZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDEgfHwgdGhpcy5fb3Bjb2RlID09PSAweDAyKSB7XG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29tcHJlc3NlZCA9IGNvbXByZXNzZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3ICYmIHRoaXMuX29wY29kZSA8IDB4MGIpIHtcbiAgICAgIGlmICghdGhpcy5fZmluKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdGSU4gbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX0ZJTidcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID4gMHg3ZCB8fFxuICAgICAgICAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgcGF5bG9hZCBsZW5ndGggJHt0aGlzLl9wYXlsb2FkTGVuZ3RofWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DT05UUk9MX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcblxuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xuICAgICAgaWYgKCF0aGlzLl9tYXNrZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ01BU0sgbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX01BU0snXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9tYXNrZWQpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ01BU0sgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9NQVNLJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjYpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzE2O1xuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNykgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XG4gICAgZWxzZSB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrMTYpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDE2KGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XG4gICAgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzY0KS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGg2NChjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgOCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSg4KTtcbiAgICBjb25zdCBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgbWF4aW11bSBzYWZlIGludGVnZXIgaW4gSmF2YVNjcmlwdCBpcyAyXjUzIC0gMS4gQW4gZXJyb3IgaXMgcmV0dXJuZWRcbiAgICAvLyBpZiBwYXlsb2FkIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhpcyBudW1iZXIuXG4gICAgLy9cbiAgICBpZiAobnVtID4gTWF0aC5wb3coMiwgNTMgLSAzMikgLSAxKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdVbnN1cHBvcnRlZCBXZWJTb2NrZXQgZnJhbWU6IHBheWxvYWQgbGVuZ3RoID4gMl41MyAtIDEnLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgMTAwOSxcbiAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9EQVRBX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBudW0gKiBNYXRoLnBvdygyLCAzMikgKyBidWYucmVhZFVJbnQzMkJFKDQpO1xuICAgIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogUGF5bG9hZCBsZW5ndGggaGFzIGJlZW4gcmVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhdmVMZW5ndGgoY2IpIHtcbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCAmJiB0aGlzLl9vcGNvZGUgPCAweDA4KSB7XG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggKz0gdGhpcy5fcGF5bG9hZExlbmd0aDtcbiAgICAgIGlmICh0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAxMDA5LFxuICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2tlZCkgdGhpcy5fc3RhdGUgPSBHRVRfTUFTSztcbiAgICBlbHNlIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgbWFzayBieXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1hc2soKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA0KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzayA9IHRoaXMuY29uc3VtZSg0KTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXREYXRhKGNiKSB7XG4gICAgbGV0IGRhdGEgPSBFTVBUWV9CVUZGRVI7XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCB0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gdGhpcy5jb25zdW1lKHRoaXMuX3BheWxvYWRMZW5ndGgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX21hc2tlZCAmJlxuICAgICAgICAodGhpcy5fbWFza1swXSB8IHRoaXMuX21hc2tbMV0gfCB0aGlzLl9tYXNrWzJdIHwgdGhpcy5fbWFza1szXSkgIT09IDBcbiAgICAgICkge1xuICAgICAgICB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHtcbiAgICAgIHRoaXMuY29udHJvbE1lc3NhZ2UoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb21wcmVzc2VkKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IElORkxBVElORztcbiAgICAgIHRoaXMuZGVjb21wcmVzcyhkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBtZXNzYWdlIGlzIG5vdCBjb21wcmVzc2VkIHNvIGl0cyBsZW5ndGggaXMgdGhlIHN1bSBvZiB0aGUgcGF5bG9hZFxuICAgICAgLy8gbGVuZ3RoIG9mIGFsbCBmcmFnbWVudHMuXG4gICAgICAvL1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YU1lc3NhZ2UoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3NlcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5kZWNvbXByZXNzKGRhdGEsIHRoaXMuX2ZpbiwgKGVyciwgYnVmKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgaWYgKGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fbWVzc2FnZUxlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICAgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAxMDA5LFxuICAgICAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YU1lc3NhZ2UoY2IpO1xuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBHRVRfSU5GTykgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkYXRhTWVzc2FnZShjYikge1xuICAgIGlmICghdGhpcy5fZmluKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRoaXMuX2ZyYWdtZW50cztcblxuICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICBsZXQgZGF0YTtcblxuICAgICAgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdub2RlYnVmZmVyJykge1xuICAgICAgICBkYXRhID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgZGF0YSA9IHRvQXJyYXlCdWZmZXIoY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnVmID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG5cbiAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDA3LFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IElORkxBVElORyB8fCB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gaGFuZGxlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsIEVNUFRZX0JVRkZFUik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWYgPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgICAgICBkYXRhLmJ5dGVPZmZzZXQgKyAyLFxuICAgICAgICAgIGRhdGEubGVuZ3RoIC0gMlxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwNyxcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW4gZXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpFcnJvcnxSYW5nZUVycm9yKX0gRXJyb3JDdG9yIFRoZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAgICogICAgIGBtZXNzYWdlYFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzQ29kZSBUaGUgc3RhdHVzIGNvZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVFcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSwgZXJyb3JDb2RlKSB7XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yZWQgPSB0cnVlO1xuXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yQ3RvcihcbiAgICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICAgKTtcblxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdGhpcy5jcmVhdGVFcnJvcik7XG4gICAgZXJyLmNvZGUgPSBlcnJvckNvZGU7XG4gICAgZXJyW2tTdGF0dXNDb2RlXSA9IHN0YXR1c0NvZGU7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuIl0sIm5hbWVzIjpbIldyaXRhYmxlIiwicmVxdWlyZSIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiQklOQVJZX1RZUEVTIiwiRU1QVFlfQlVGRkVSIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiY29uY2F0IiwidG9BcnJheUJ1ZmZlciIsInVubWFzayIsImlzVmFsaWRTdGF0dXNDb2RlIiwiaXNWYWxpZFVURjgiLCJGYXN0QnVmZmVyIiwiQnVmZmVyIiwiU3ltYm9sIiwic3BlY2llcyIsIkdFVF9JTkZPIiwiR0VUX1BBWUxPQURfTEVOR1RIXzE2IiwiR0VUX1BBWUxPQURfTEVOR1RIXzY0IiwiR0VUX01BU0siLCJHRVRfREFUQSIsIklORkxBVElORyIsIkRFRkVSX0VWRU5UIiwiUmVjZWl2ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfYWxsb3dTeW5jaHJvbm91c0V2ZW50cyIsImFsbG93U3luY2hyb25vdXNFdmVudHMiLCJ1bmRlZmluZWQiLCJfYmluYXJ5VHlwZSIsImJpbmFyeVR5cGUiLCJfZXh0ZW5zaW9ucyIsImV4dGVuc2lvbnMiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlciIsIl9tYXhQYXlsb2FkIiwibWF4UGF5bG9hZCIsIl9za2lwVVRGOFZhbGlkYXRpb24iLCJza2lwVVRGOFZhbGlkYXRpb24iLCJfYnVmZmVyZWRCeXRlcyIsIl9idWZmZXJzIiwiX2NvbXByZXNzZWQiLCJfcGF5bG9hZExlbmd0aCIsIl9tYXNrIiwiX2ZyYWdtZW50ZWQiLCJfbWFza2VkIiwiX2ZpbiIsIl9vcGNvZGUiLCJfdG90YWxQYXlsb2FkTGVuZ3RoIiwiX21lc3NhZ2VMZW5ndGgiLCJfZnJhZ21lbnRzIiwiX2Vycm9yZWQiLCJfbG9vcCIsIl9zdGF0ZSIsIl93cml0ZSIsImNodW5rIiwiZW5jb2RpbmciLCJjYiIsImxlbmd0aCIsInB1c2giLCJzdGFydExvb3AiLCJjb25zdW1lIiwibiIsInNoaWZ0IiwiYnVmIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImRzdCIsImFsbG9jVW5zYWZlIiwib2Zmc2V0Iiwic2V0IiwiVWludDhBcnJheSIsImdldEluZm8iLCJnZXRQYXlsb2FkTGVuZ3RoMTYiLCJnZXRQYXlsb2FkTGVuZ3RoNjQiLCJnZXRNYXNrIiwiZ2V0RGF0YSIsImVycm9yIiwiY3JlYXRlRXJyb3IiLCJSYW5nZUVycm9yIiwiY29tcHJlc3NlZCIsImV4dGVuc2lvbk5hbWUiLCJoYXZlTGVuZ3RoIiwicmVhZFVJbnQxNkJFIiwibnVtIiwicmVhZFVJbnQzMkJFIiwiTWF0aCIsInBvdyIsImRhdGEiLCJjb250cm9sTWVzc2FnZSIsImRlY29tcHJlc3MiLCJkYXRhTWVzc2FnZSIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZXJyIiwibWVzc2FnZUxlbmd0aCIsImZyYWdtZW50cyIsImVtaXQiLCJzZXRJbW1lZGlhdGUiLCJFcnJvciIsImVuZCIsImNvZGUiLCJFcnJvckN0b3IiLCJtZXNzYWdlIiwicHJlZml4Iiwic3RhdHVzQ29kZSIsImVycm9yQ29kZSIsImNhcHR1cmVTdGFja1RyYWNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/sender.js":
/*!**********************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/sender.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ \nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\n/**\n * HyBi Sender implementation.\n */ class Sender {\n    /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._deflating = false;\n        this._queue = [];\n    }\n    /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                    /* istanbul ignore else  */ if (randomPool === undefined) {\n                        //\n                        // This is lazily initialized because server-sent frames must not\n                        // be masked so it may never be used.\n                        //\n                        randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                    }\n                    randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                    randomPoolPointer = 0;\n                }\n                mask[0] = randomPool[randomPoolPointer++];\n                mask[1] = randomPool[randomPoolPointer++];\n                mask[2] = randomPool[randomPoolPointer++];\n                mask[3] = randomPool[randomPoolPointer++];\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === \"string\") {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n            throw new TypeError(\"First argument must be a valid error code number\");\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError(\"The message must not be greater than 123 bytes\");\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === \"string\") {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._deflating) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (this._deflating) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (this._deflating) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        if (perMessageDeflate) {\n            const opts = {\n                [kByteLength]: byteLength,\n                fin: options.fin,\n                generateMask: this._generateMask,\n                mask: options.mask,\n                maskBuffer: this._maskBuffer,\n                opcode,\n                readOnly,\n                rsv1\n            };\n            if (this._deflating) {\n                this.enqueue([\n                    this.dispatch,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.dispatch(data, this._compress, opts, cb);\n            }\n        } else {\n            this.sendFrame(Sender.frame(data, {\n                [kByteLength]: byteLength,\n                fin: options.fin,\n                generateMask: this._generateMask,\n                mask: options.mask,\n                maskBuffer: this._maskBuffer,\n                opcode,\n                readOnly,\n                rsv1: false\n            }), cb);\n        }\n    }\n    /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._deflating = true;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while data was being compressed\");\n                if (typeof cb === \"function\") cb(err);\n                for(let i = 0; i < this._queue.length; i++){\n                    const params = this._queue[i];\n                    const callback = params[params.length - 1];\n                    if (typeof callback === \"function\") callback(err);\n                }\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._deflating = false;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\n   * Executes queued send operations.\n   *\n   * @private\n   */ dequeue() {\n        while(!this._deflating && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsd0VBQXdFLEdBRXhFO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFQyxjQUFjLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFbkMsTUFBTUUsb0JBQW9CRixtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVHLFlBQVksRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUNqQyxNQUFNLEVBQUVJLGlCQUFpQixFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQ3RDLE1BQU0sRUFBRUssTUFBTUMsU0FBUyxFQUFFQyxRQUFRLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFFOUMsTUFBTVEsY0FBY0MsT0FBTztBQUMzQixNQUFNQyxhQUFhQyxPQUFPQyxLQUFLLENBQUM7QUFDaEMsTUFBTUMsbUJBQW1CLElBQUk7QUFDN0IsSUFBSUM7QUFDSixJQUFJQyxvQkFBb0JGO0FBRXhCOztDQUVDLEdBQ0QsTUFBTUc7SUFDSjs7Ozs7OztHQU9DLEdBQ0RDLFlBQVlDLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxZQUFZLENBQUU7UUFDNUMsSUFBSSxDQUFDQyxXQUFXLEdBQUdGLGNBQWMsQ0FBQztRQUVsQyxJQUFJQyxjQUFjO1lBQ2hCLElBQUksQ0FBQ0UsYUFBYSxHQUFHRjtZQUNyQixJQUFJLENBQUNHLFdBQVcsR0FBR1osT0FBT0MsS0FBSyxDQUFDO1FBQ2xDO1FBRUEsSUFBSSxDQUFDWSxPQUFPLEdBQUdOO1FBRWYsSUFBSSxDQUFDTyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFFakIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtJQUNsQjtJQUVB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QUksQ0FBQyxFQUFFLEVBQUVqQztZQUM1QixJQUFJLENBQUMzQixPQUFPLENBQUM4RCxNQUFNO1FBQ3JCLE9BQU87WUFDTCxJQUFJLENBQUM5RCxPQUFPLENBQUNnQyxLQUFLLENBQUM0QixJQUFJLENBQUMsRUFBRSxFQUFFakM7UUFDOUI7SUFDRjtBQUNGO0FBRUFvQyxPQUFPQyxPQUFPLEdBQUd4RSIsInNvdXJjZXMiOlsid2VicGFjazovL3doYXRzYXBwLWFpLWNybS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcz9kZjBkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5jb25zdCB7IG1hc2s6IGFwcGx5TWFzaywgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3Qga0J5dGVMZW5ndGggPSBTeW1ib2woJ2tCeXRlTGVuZ3RoJyk7XG5jb25zdCBtYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuY29uc3QgUkFORE9NX1BPT0xfU0laRSA9IDggKiAxMDI0O1xubGV0IHJhbmRvbVBvb2w7XG5sZXQgcmFuZG9tUG9vbFBvaW50ZXIgPSBSQU5ET01fUE9PTF9TSVpFO1xuXG4vKipcbiAqIEh5QmkgU2VuZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBTZW5kZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvY2tldCwgZXh0ZW5zaW9ucywgZ2VuZXJhdGVNYXNrKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG5cbiAgICBpZiAoZ2VuZXJhdGVNYXNrKSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZU1hc2sgPSBnZW5lcmF0ZU1hc2s7XG4gICAgICB0aGlzLl9tYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9kZWZsYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhIHBpZWNlIG9mIGRhdGEgYWNjb3JkaW5nIHRvIHRoZSBIeUJpIFdlYlNvY2tldCBwcm90b2NvbC5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIGRhdGEgdG8gZnJhbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEByZXR1cm4geyhCdWZmZXJ8U3RyaW5nKVtdfSBUaGUgZnJhbWVkIGRhdGFcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc3RhdGljIGZyYW1lKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFzaztcbiAgICBsZXQgbWVyZ2UgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICBsZXQgc2tpcE1hc2tpbmcgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLm1hc2spIHtcbiAgICAgIG1hc2sgPSBvcHRpb25zLm1hc2tCdWZmZXIgfHwgbWFza0J1ZmZlcjtcblxuICAgICAgaWYgKG9wdGlvbnMuZ2VuZXJhdGVNYXNrKSB7XG4gICAgICAgIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKG1hc2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJhbmRvbVBvb2xQb2ludGVyID09PSBSQU5ET01fUE9PTF9TSVpFKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG4gICAgICAgICAgaWYgKHJhbmRvbVBvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbGF6aWx5IGluaXRpYWxpemVkIGJlY2F1c2Ugc2VydmVyLXNlbnQgZnJhbWVzIG11c3Qgbm90XG4gICAgICAgICAgICAvLyBiZSBtYXNrZWQgc28gaXQgbWF5IG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgcmFuZG9tUG9vbCA9IEJ1ZmZlci5hbGxvYyhSQU5ET01fUE9PTF9TSVpFKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByYW5kb21GaWxsU3luYyhyYW5kb21Qb29sLCAwLCBSQU5ET01fUE9PTF9TSVpFKTtcbiAgICAgICAgICByYW5kb21Qb29sUG9pbnRlciA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBtYXNrWzBdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1sxXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbMl0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzNdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgIH1cblxuICAgICAgc2tpcE1hc2tpbmcgPSAobWFza1swXSB8IG1hc2tbMV0gfCBtYXNrWzJdIHwgbWFza1szXSkgPT09IDA7XG4gICAgICBvZmZzZXQgPSA2O1xuICAgIH1cblxuICAgIGxldCBkYXRhTGVuZ3RoO1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKFxuICAgICAgICAoIW9wdGlvbnMubWFzayB8fCBza2lwTWFza2luZykgJiZcbiAgICAgICAgb3B0aW9uc1trQnl0ZUxlbmd0aF0gIT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIGRhdGFMZW5ndGggPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICBtZXJnZSA9IG9wdGlvbnMubWFzayAmJiBvcHRpb25zLnJlYWRPbmx5ICYmICFza2lwTWFza2luZztcbiAgICB9XG5cbiAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAoZGF0YUxlbmd0aCA+PSA2NTUzNikge1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3O1xuICAgIH0gZWxzZSBpZiAoZGF0YUxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2O1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXJnZSA/IGRhdGFMZW5ndGggKyBvZmZzZXQgOiBvZmZzZXQpO1xuXG4gICAgdGFyZ2V0WzBdID0gb3B0aW9ucy5maW4gPyBvcHRpb25zLm9wY29kZSB8IDB4ODAgOiBvcHRpb25zLm9wY29kZTtcbiAgICBpZiAob3B0aW9ucy5yc3YxKSB0YXJnZXRbMF0gfD0gMHg0MDtcblxuICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGg7XG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MTZCRShkYXRhTGVuZ3RoLCAyKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgdGFyZ2V0WzJdID0gdGFyZ2V0WzNdID0gMDtcbiAgICAgIHRhcmdldC53cml0ZVVJbnRCRShkYXRhTGVuZ3RoLCA0LCA2KTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMubWFzaykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG4gICAgdGFyZ2V0WzFdIHw9IDB4ODA7XG4gICAgdGFyZ2V0W29mZnNldCAtIDRdID0gbWFza1swXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gM10gPSBtYXNrWzFdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAyXSA9IG1hc2tbMl07XG4gICAgdGFyZ2V0W29mZnNldCAtIDFdID0gbWFza1szXTtcblxuICAgIGlmIChza2lwTWFza2luZykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG4gICAgaWYgKG1lcmdlKSB7XG4gICAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgdGFyZ2V0LCBvZmZzZXQsIGRhdGFMZW5ndGgpO1xuICAgICAgcmV0dXJuIFt0YXJnZXRdO1xuICAgIH1cblxuICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCBkYXRhLCAwLCBkYXRhTGVuZ3RoKTtcbiAgICByZXR1cm4gW3RhcmdldCwgZGF0YV07XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFRoZSBzdGF0dXMgY29kZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgbWVzc2FnZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBidWY7XG5cbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWYgPSBFTVBUWV9CVUZGRVI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQgZXJyb3IgY29kZSBudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlcycpO1xuICAgICAgfVxuXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWYud3JpdGUoZGF0YSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYuc2V0KGRhdGEsIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBidWYubGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwOCxcbiAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgYnVmLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA5LFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwb25nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDBhLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5XG4gICAqICAgICBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZpcnN0RnJhZ21lbnQpIHtcbiAgICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSBmYWxzZTtcbiAgICAgIGlmIChcbiAgICAgICAgcnN2MSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5wYXJhbXNbXG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuX2lzU2VydmVyXG4gICAgICAgICAgICA/ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgICAgIDogJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICBdXG4gICAgICApIHtcbiAgICAgICAgcnN2MSA9IGJ5dGVMZW5ndGggPj0gcGVyTWVzc2FnZURlZmxhdGUuX3RocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbXByZXNzID0gcnN2MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnN2MSA9IGZhbHNlO1xuICAgICAgb3Bjb2RlID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maW4pIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuXG4gICAgaWYgKHBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgICBvcGNvZGUsXG4gICAgICAgIHJlYWRPbmx5LFxuICAgICAgICByc3YxXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgICBTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgICAgICBvcGNvZGUsXG4gICAgICAgICAgcmVhZE9ubHksXG4gICAgICAgICAgcnN2MTogZmFsc2VcbiAgICAgICAgfSksXG4gICAgICAgIGNiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gdHJ1ZTtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5jb21wcmVzcyhkYXRhLCBvcHRpb25zLmZpbiwgKF8sIGJ1ZikgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgY29tcHJlc3NlZCdcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBjYihlcnIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9xdWV1ZVtpXTtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgICBvcHRpb25zLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgcXVldWVkIHNlbmQgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlcXVldWUoKSB7XG4gICAgd2hpbGUgKCF0aGlzLl9kZWZsYXRpbmcgJiYgdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG4gICAgICBSZWZsZWN0LmFwcGx5KHBhcmFtc1swXSwgdGhpcywgcGFyYW1zLnNsaWNlKDEpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzZW5kIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIFNlbmQgb3BlcmF0aW9uIHBhcmFtZXRlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbnF1ZXVlKHBhcmFtcykge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBmcmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJbXX0gbGlzdCBUaGUgZnJhbWUgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZW5kRnJhbWUobGlzdCwgY2IpIHtcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuX3NvY2tldC5jb3JrKCk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFsxXSwgY2IpO1xuICAgICAgdGhpcy5fc29ja2V0LnVuY29yaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlcjtcbiJdLCJuYW1lcyI6WyJEdXBsZXgiLCJyZXF1aXJlIiwicmFuZG9tRmlsbFN5bmMiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsIkVNUFRZX0JVRkZFUiIsImlzVmFsaWRTdGF0dXNDb2RlIiwibWFzayIsImFwcGx5TWFzayIsInRvQnVmZmVyIiwia0J5dGVMZW5ndGgiLCJTeW1ib2wiLCJtYXNrQnVmZmVyIiwiQnVmZmVyIiwiYWxsb2MiLCJSQU5ET01fUE9PTF9TSVpFIiwicmFuZG9tUG9vbCIsInJhbmRvbVBvb2xQb2ludGVyIiwiU2VuZGVyIiwiY29uc3RydWN0b3IiLCJzb2NrZXQiLCJleHRlbnNpb25zIiwiZ2VuZXJhdGVNYXNrIiwiX2V4dGVuc2lvbnMiLCJfZ2VuZXJhdGVNYXNrIiwiX21hc2tCdWZmZXIiLCJfc29ja2V0IiwiX2ZpcnN0RnJhZ21lbnQiLCJfY29tcHJlc3MiLCJfYnVmZmVyZWRCeXRlcyIsIl9kZWZsYXRpbmciLCJfcXVldWUiLCJmcmFtZSIsImRhdGEiLCJvcHRpb25zIiwibWVyZ2UiLCJvZmZzZXQiLCJza2lwTWFza2luZyIsInVuZGVmaW5lZCIsImRhdGFMZW5ndGgiLCJmcm9tIiwibGVuZ3RoIiwicmVhZE9ubHkiLCJwYXlsb2FkTGVuZ3RoIiwidGFyZ2V0IiwiYWxsb2NVbnNhZmUiLCJmaW4iLCJvcGNvZGUiLCJyc3YxIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludEJFIiwiY2xvc2UiLCJjb2RlIiwiY2IiLCJidWYiLCJUeXBlRXJyb3IiLCJieXRlTGVuZ3RoIiwiUmFuZ2VFcnJvciIsIndyaXRlIiwic2V0IiwiZW5xdWV1ZSIsImRpc3BhdGNoIiwic2VuZEZyYW1lIiwicGluZyIsInBvbmciLCJzZW5kIiwicGVyTWVzc2FnZURlZmxhdGUiLCJleHRlbnNpb25OYW1lIiwiYmluYXJ5IiwiY29tcHJlc3MiLCJwYXJhbXMiLCJfaXNTZXJ2ZXIiLCJfdGhyZXNob2xkIiwib3B0cyIsIl8iLCJkZXN0cm95ZWQiLCJlcnIiLCJFcnJvciIsImkiLCJjYWxsYmFjayIsImRlcXVldWUiLCJzaGlmdCIsIlJlZmxlY3QiLCJhcHBseSIsInNsaWNlIiwicHVzaCIsImxpc3QiLCJjb3JrIiwidW5jb3JrIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/stream.js":
/*!**********************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/stream.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */ function emitClose(stream) {\n    stream.emit(\"close\");\n}\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */ function duplexOnEnd() {\n    if (!this.destroyed && this._writableState.finished) {\n        this.destroy();\n    }\n}\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */ function duplexOnError(err) {\n    this.removeListener(\"error\", duplexOnError);\n    this.destroy();\n    if (this.listenerCount(\"error\") === 0) {\n        // Do not suppress the throwing behavior.\n        this.emit(\"error\", err);\n    }\n}\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */ function createWebSocketStream(ws, options) {\n    let terminateOnDestroy = true;\n    const duplex = new Duplex({\n        ...options,\n        autoDestroy: false,\n        emitClose: false,\n        objectMode: false,\n        writableObjectMode: false\n    });\n    ws.on(\"message\", function message(msg, isBinary) {\n        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n        if (!duplex.push(data)) ws.pause();\n    });\n    ws.once(\"error\", function error(err) {\n        if (duplex.destroyed) return;\n        // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n        //\n        // - If the `'error'` event is emitted before the `'open'` event, then\n        //   `ws.terminate()` is a noop as no socket is assigned.\n        // - Otherwise, the error is re-emitted by the listener of the `'error'`\n        //   event of the `Receiver` object. The listener already closes the\n        //   connection by calling `ws.close()`. This allows a close frame to be\n        //   sent to the other peer. If `ws.terminate()` is called right after this,\n        //   then the close frame might not be sent.\n        terminateOnDestroy = false;\n        duplex.destroy(err);\n    });\n    ws.once(\"close\", function close() {\n        if (duplex.destroyed) return;\n        duplex.push(null);\n    });\n    duplex._destroy = function(err, callback) {\n        if (ws.readyState === ws.CLOSED) {\n            callback(err);\n            process.nextTick(emitClose, duplex);\n            return;\n        }\n        let called = false;\n        ws.once(\"error\", function error(err) {\n            called = true;\n            callback(err);\n        });\n        ws.once(\"close\", function close() {\n            if (!called) callback(err);\n            process.nextTick(emitClose, duplex);\n        });\n        if (terminateOnDestroy) ws.terminate();\n    };\n    duplex._final = function(callback) {\n        if (ws.readyState === ws.CONNECTING) {\n            ws.once(\"open\", function open() {\n                duplex._final(callback);\n            });\n            return;\n        }\n        // If the value of the `_socket` property is `null` it means that `ws` is a\n        // client websocket and the handshake failed. In fact, when this happens, a\n        // socket is never assigned to the websocket. Wait for the `'error'` event\n        // that will be emitted by the websocket.\n        if (ws._socket === null) return;\n        if (ws._socket._writableState.finished) {\n            callback();\n            if (duplex._readableState.endEmitted) duplex.destroy();\n        } else {\n            ws._socket.once(\"finish\", function finish() {\n                // `duplex` is not destroyed here because the `'end'` event will be\n                // emitted on `duplex` after this `'finish'` event. The EOF signaling\n                // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n                callback();\n            });\n            ws.close();\n        }\n    };\n    duplex._read = function() {\n        if (ws.isPaused) ws.resume();\n    };\n    duplex._write = function(chunk, encoding, callback) {\n        if (ws.readyState === ws.CONNECTING) {\n            ws.once(\"open\", function open() {\n                duplex._write(chunk, encoding, callback);\n            });\n            return;\n        }\n        ws.send(chunk, callback);\n    };\n    duplex.on(\"end\", duplexOnEnd);\n    duplex.on(\"error\", duplexOnError);\n    return duplex;\n}\nmodule.exports = createWebSocketStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUUzQjs7Ozs7Q0FLQyxHQUNELFNBQVNDLFVBQVVDLE1BQU07SUFDdkJBLE9BQU9DLElBQUksQ0FBQztBQUNkO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNDO0lBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQ0MsU0FBUyxJQUFJLElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxRQUFRLEVBQUU7UUFDbkQsSUFBSSxDQUFDQyxPQUFPO0lBQ2Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0MsY0FBY0MsR0FBRztJQUN4QixJQUFJLENBQUNDLGNBQWMsQ0FBQyxTQUFTRjtJQUM3QixJQUFJLENBQUNELE9BQU87SUFDWixJQUFJLElBQUksQ0FBQ0ksYUFBYSxDQUFDLGFBQWEsR0FBRztRQUNyQyx5Q0FBeUM7UUFDekMsSUFBSSxDQUFDVCxJQUFJLENBQUMsU0FBU087SUFDckI7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTRyxzQkFBc0JDLEVBQUUsRUFBRUMsT0FBTztJQUN4QyxJQUFJQyxxQkFBcUI7SUFFekIsTUFBTUMsU0FBUyxJQUFJbEIsT0FBTztRQUN4QixHQUFHZ0IsT0FBTztRQUNWRyxhQUFhO1FBQ2JqQixXQUFXO1FBQ1hrQixZQUFZO1FBQ1pDLG9CQUFvQjtJQUN0QjtJQUVBTixHQUFHTyxFQUFFLENBQUMsV0FBVyxTQUFTQyxRQUFRQyxHQUFHLEVBQUVDLFFBQVE7UUFDN0MsTUFBTUMsT0FDSixDQUFDRCxZQUFZUCxPQUFPUyxjQUFjLENBQUNQLFVBQVUsR0FBR0ksSUFBSUksUUFBUSxLQUFLSjtRQUVuRSxJQUFJLENBQUNOLE9BQU9XLElBQUksQ0FBQ0gsT0FBT1gsR0FBR2UsS0FBSztJQUNsQztJQUVBZixHQUFHZ0IsSUFBSSxDQUFDLFNBQVMsU0FBU0MsTUFBTXJCLEdBQUc7UUFDakMsSUFBSU8sT0FBT1osU0FBUyxFQUFFO1FBRXRCLHFFQUFxRTtRQUNyRSxFQUFFO1FBQ0Ysc0VBQXNFO1FBQ3RFLHlEQUF5RDtRQUN6RCx3RUFBd0U7UUFDeEUsb0VBQW9FO1FBQ3BFLHdFQUF3RTtRQUN4RSw0RUFBNEU7UUFDNUUsNENBQTRDO1FBQzVDVyxxQkFBcUI7UUFDckJDLE9BQU9ULE9BQU8sQ0FBQ0U7SUFDakI7SUFFQUksR0FBR2dCLElBQUksQ0FBQyxTQUFTLFNBQVNFO1FBQ3hCLElBQUlmLE9BQU9aLFNBQVMsRUFBRTtRQUV0QlksT0FBT1csSUFBSSxDQUFDO0lBQ2Q7SUFFQVgsT0FBT2dCLFFBQVEsR0FBRyxTQUFVdkIsR0FBRyxFQUFFd0IsUUFBUTtRQUN2QyxJQUFJcEIsR0FBR3FCLFVBQVUsS0FBS3JCLEdBQUdzQixNQUFNLEVBQUU7WUFDL0JGLFNBQVN4QjtZQUNUMkIsUUFBUUMsUUFBUSxDQUFDckMsV0FBV2dCO1lBQzVCO1FBQ0Y7UUFFQSxJQUFJc0IsU0FBUztRQUViekIsR0FBR2dCLElBQUksQ0FBQyxTQUFTLFNBQVNDLE1BQU1yQixHQUFHO1lBQ2pDNkIsU0FBUztZQUNUTCxTQUFTeEI7UUFDWDtRQUVBSSxHQUFHZ0IsSUFBSSxDQUFDLFNBQVMsU0FBU0U7WUFDeEIsSUFBSSxDQUFDTyxRQUFRTCxTQUFTeEI7WUFDdEIyQixRQUFRQyxRQUFRLENBQUNyQyxXQUFXZ0I7UUFDOUI7UUFFQSxJQUFJRCxvQkFBb0JGLEdBQUcwQixTQUFTO0lBQ3RDO0lBRUF2QixPQUFPd0IsTUFBTSxHQUFHLFNBQVVQLFFBQVE7UUFDaEMsSUFBSXBCLEdBQUdxQixVQUFVLEtBQUtyQixHQUFHNEIsVUFBVSxFQUFFO1lBQ25DNUIsR0FBR2dCLElBQUksQ0FBQyxRQUFRLFNBQVNhO2dCQUN2QjFCLE9BQU93QixNQUFNLENBQUNQO1lBQ2hCO1lBQ0E7UUFDRjtRQUVBLDJFQUEyRTtRQUMzRSwyRUFBMkU7UUFDM0UsMEVBQTBFO1FBQzFFLHlDQUF5QztRQUN6QyxJQUFJcEIsR0FBRzhCLE9BQU8sS0FBSyxNQUFNO1FBRXpCLElBQUk5QixHQUFHOEIsT0FBTyxDQUFDdEMsY0FBYyxDQUFDQyxRQUFRLEVBQUU7WUFDdEMyQjtZQUNBLElBQUlqQixPQUFPUyxjQUFjLENBQUNtQixVQUFVLEVBQUU1QixPQUFPVCxPQUFPO1FBQ3RELE9BQU87WUFDTE0sR0FBRzhCLE9BQU8sQ0FBQ2QsSUFBSSxDQUFDLFVBQVUsU0FBU2dCO2dCQUNqQyxtRUFBbUU7Z0JBQ25FLHFFQUFxRTtnQkFDckUsdUVBQXVFO2dCQUN2RVo7WUFDRjtZQUNBcEIsR0FBR2tCLEtBQUs7UUFDVjtJQUNGO0lBRUFmLE9BQU84QixLQUFLLEdBQUc7UUFDYixJQUFJakMsR0FBR2tDLFFBQVEsRUFBRWxDLEdBQUdtQyxNQUFNO0lBQzVCO0lBRUFoQyxPQUFPaUMsTUFBTSxHQUFHLFNBQVVDLEtBQUssRUFBRUMsUUFBUSxFQUFFbEIsUUFBUTtRQUNqRCxJQUFJcEIsR0FBR3FCLFVBQVUsS0FBS3JCLEdBQUc0QixVQUFVLEVBQUU7WUFDbkM1QixHQUFHZ0IsSUFBSSxDQUFDLFFBQVEsU0FBU2E7Z0JBQ3ZCMUIsT0FBT2lDLE1BQU0sQ0FBQ0MsT0FBT0MsVUFBVWxCO1lBQ2pDO1lBQ0E7UUFDRjtRQUVBcEIsR0FBR3VDLElBQUksQ0FBQ0YsT0FBT2pCO0lBQ2pCO0lBRUFqQixPQUFPSSxFQUFFLENBQUMsT0FBT2pCO0lBQ2pCYSxPQUFPSSxFQUFFLENBQUMsU0FBU1o7SUFDbkIsT0FBT1E7QUFDVDtBQUVBcUMsT0FBT0MsT0FBTyxHQUFHMUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9zdHJlYW0uanM/YmVkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyoqXG4gKiBFbWl0cyB0aGUgYCdjbG9zZSdgIGV2ZW50IG9uIGEgc3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7RHVwbGV4fSBzdHJlYW0gVGhlIHN0cmVhbS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRDbG9zZShzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2VuZCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGR1cGxleE9uRW5kKCkge1xuICBpZiAoIXRoaXMuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGR1cGxleE9uRXJyb3IoZXJyKSB7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHRoaXMuZGVzdHJveSgpO1xuICBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgLy8gRG8gbm90IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvci5cbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFdyYXBzIGEgYFdlYlNvY2tldGAgaW4gYSBkdXBsZXggc3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3cyBUaGUgYFdlYlNvY2tldGAgdG8gd3JhcFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhlIGBEdXBsZXhgIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJuIHtEdXBsZXh9IFRoZSBkdXBsZXggc3RyZWFtXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldFN0cmVhbSh3cywgb3B0aW9ucykge1xuICBsZXQgdGVybWluYXRlT25EZXN0cm95ID0gdHJ1ZTtcblxuICBjb25zdCBkdXBsZXggPSBuZXcgRHVwbGV4KHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGF1dG9EZXN0cm95OiBmYWxzZSxcbiAgICBlbWl0Q2xvc2U6IGZhbHNlLFxuICAgIG9iamVjdE1vZGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogZmFsc2VcbiAgfSk7XG5cbiAgd3Mub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiBtZXNzYWdlKG1zZywgaXNCaW5hcnkpIHtcbiAgICBjb25zdCBkYXRhID1cbiAgICAgICFpc0JpbmFyeSAmJiBkdXBsZXguX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSA/IG1zZy50b1N0cmluZygpIDogbXNnO1xuXG4gICAgaWYgKCFkdXBsZXgucHVzaChkYXRhKSkgd3MucGF1c2UoKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBgd3MudGVybWluYXRlKClgIGZyb20gYmVpbmcgY2FsbGVkIGJ5IGBkdXBsZXguX2Rlc3Ryb3koKWAuXG4gICAgLy9cbiAgICAvLyAtIElmIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBiZWZvcmUgdGhlIGAnb3BlbidgIGV2ZW50LCB0aGVuXG4gICAgLy8gICBgd3MudGVybWluYXRlKClgIGlzIGEgbm9vcCBhcyBubyBzb2NrZXQgaXMgYXNzaWduZWQuXG4gICAgLy8gLSBPdGhlcndpc2UsIHRoZSBlcnJvciBpcyByZS1lbWl0dGVkIGJ5IHRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlcnJvcidgXG4gICAgLy8gICBldmVudCBvZiB0aGUgYFJlY2VpdmVyYCBvYmplY3QuIFRoZSBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlcyB0aGVcbiAgICAvLyAgIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBgd3MuY2xvc2UoKWAuIFRoaXMgYWxsb3dzIGEgY2xvc2UgZnJhbWUgdG8gYmVcbiAgICAvLyAgIHNlbnQgdG8gdGhlIG90aGVyIHBlZXIuIElmIGB3cy50ZXJtaW5hdGUoKWAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHRoaXMsXG4gICAgLy8gICB0aGVuIHRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgYmUgc2VudC5cbiAgICB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSBmYWxzZTtcbiAgICBkdXBsZXguZGVzdHJveShlcnIpO1xuICB9KTtcblxuICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBkdXBsZXgucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgZHVwbGV4Ll9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ0xPU0VEKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuXG4gICAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICghY2FsbGVkKSBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGVybWluYXRlT25EZXN0cm95KSB3cy50ZXJtaW5hdGUoKTtcbiAgfTtcblxuICBkdXBsZXguX2ZpbmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX2ZpbmFsKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgYF9zb2NrZXRgIHByb3BlcnR5IGlzIGBudWxsYCBpdCBtZWFucyB0aGF0IGB3c2AgaXMgYVxuICAgIC8vIGNsaWVudCB3ZWJzb2NrZXQgYW5kIHRoZSBoYW5kc2hha2UgZmFpbGVkLiBJbiBmYWN0LCB3aGVuIHRoaXMgaGFwcGVucywgYVxuICAgIC8vIHNvY2tldCBpcyBuZXZlciBhc3NpZ25lZCB0byB0aGUgd2Vic29ja2V0LiBXYWl0IGZvciB0aGUgYCdlcnJvcidgIGV2ZW50XG4gICAgLy8gdGhhdCB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhlIHdlYnNvY2tldC5cbiAgICBpZiAod3MuX3NvY2tldCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKHdzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICBpZiAoZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIGR1cGxleC5kZXN0cm95KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdzLl9zb2NrZXQub25jZSgnZmluaXNoJywgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICAvLyBgZHVwbGV4YCBpcyBub3QgZGVzdHJveWVkIGhlcmUgYmVjYXVzZSB0aGUgYCdlbmQnYCBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGVtaXR0ZWQgb24gYGR1cGxleGAgYWZ0ZXIgdGhpcyBgJ2ZpbmlzaCdgIGV2ZW50LiBUaGUgRU9GIHNpZ25hbGluZ1xuICAgICAgICAvLyBgbnVsbGAgY2h1bmsgaXMsIGluIGZhY3QsIHB1c2hlZCB3aGVuIHRoZSB3ZWJzb2NrZXQgZW1pdHMgYCdjbG9zZSdgLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgICB3cy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICBkdXBsZXguX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdzLmlzUGF1c2VkKSB3cy5yZXN1bWUoKTtcbiAgfTtcblxuICBkdXBsZXguX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cy5zZW5kKGNodW5rLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgZHVwbGV4Lm9uKCdlbmQnLCBkdXBsZXhPbkVuZCk7XG4gIGR1cGxleC5vbignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgcmV0dXJuIGR1cGxleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXZWJTb2NrZXRTdHJlYW07XG4iXSwibmFtZXMiOlsiRHVwbGV4IiwicmVxdWlyZSIsImVtaXRDbG9zZSIsInN0cmVhbSIsImVtaXQiLCJkdXBsZXhPbkVuZCIsImRlc3Ryb3llZCIsIl93cml0YWJsZVN0YXRlIiwiZmluaXNoZWQiLCJkZXN0cm95IiwiZHVwbGV4T25FcnJvciIsImVyciIsInJlbW92ZUxpc3RlbmVyIiwibGlzdGVuZXJDb3VudCIsImNyZWF0ZVdlYlNvY2tldFN0cmVhbSIsIndzIiwib3B0aW9ucyIsInRlcm1pbmF0ZU9uRGVzdHJveSIsImR1cGxleCIsImF1dG9EZXN0cm95Iiwib2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsIm9uIiwibWVzc2FnZSIsIm1zZyIsImlzQmluYXJ5IiwiZGF0YSIsIl9yZWFkYWJsZVN0YXRlIiwidG9TdHJpbmciLCJwdXNoIiwicGF1c2UiLCJvbmNlIiwiZXJyb3IiLCJjbG9zZSIsIl9kZXN0cm95IiwiY2FsbGJhY2siLCJyZWFkeVN0YXRlIiwiQ0xPU0VEIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY2FsbGVkIiwidGVybWluYXRlIiwiX2ZpbmFsIiwiQ09OTkVDVElORyIsIm9wZW4iLCJfc29ja2V0IiwiZW5kRW1pdHRlZCIsImZpbmlzaCIsIl9yZWFkIiwiaXNQYXVzZWQiLCJyZXN1bWUiLCJfd3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwic2VuZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/subprotocol.js":
/*!***************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/subprotocol.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/validation.js\");\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */ function parse(header) {\n    const protocols = new Set();\n    let start = -1;\n    let end = -1;\n    let i = 0;\n    for(i; i < header.length; i++){\n        const code = header.charCodeAt(i);\n        if (end === -1 && tokenChars[code] === 1) {\n            if (start === -1) start = i;\n        } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n            if (end === -1 && start !== -1) end = i;\n        } else if (code === 0x2c /* ',' */ ) {\n            if (start === -1) {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (end === -1) end = i;\n            const protocol = header.slice(start, end);\n            if (protocols.has(protocol)) {\n                throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n            }\n            protocols.add(protocol);\n            start = end = -1;\n        } else {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n    }\n    if (start === -1 || end !== -1) {\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    const protocol = header.slice(start, i);\n    if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n    }\n    protocols.add(protocol);\n    return protocols;\n}\nmodule.exports = {\n    parse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi9zdWJwcm90b2NvbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsVUFBVSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRS9COzs7Ozs7Q0FNQyxHQUNELFNBQVNDLE1BQU1DLE1BQU07SUFDbkIsTUFBTUMsWUFBWSxJQUFJQztJQUN0QixJQUFJQyxRQUFRLENBQUM7SUFDYixJQUFJQyxNQUFNLENBQUM7SUFDWCxJQUFJQyxJQUFJO0lBRVIsSUFBS0EsR0FBR0EsSUFBSUwsT0FBT00sTUFBTSxFQUFFRCxJQUFLO1FBQzlCLE1BQU1FLE9BQU9QLE9BQU9RLFVBQVUsQ0FBQ0g7UUFFL0IsSUFBSUQsUUFBUSxDQUFDLEtBQUtQLFVBQVUsQ0FBQ1UsS0FBSyxLQUFLLEdBQUc7WUFDeEMsSUFBSUosVUFBVSxDQUFDLEdBQUdBLFFBQVFFO1FBQzVCLE9BQU8sSUFDTEEsTUFBTSxLQUNMRSxDQUFBQSxTQUFTLEtBQUssT0FBTyxPQUFNQSxTQUFTLElBQUcsR0FDeEM7WUFDQSxJQUFJSCxRQUFRLENBQUMsS0FBS0QsVUFBVSxDQUFDLEdBQUdDLE1BQU1DO1FBQ3hDLE9BQU8sSUFBSUUsU0FBUyxLQUFLLE9BQU8sS0FBSTtZQUNsQyxJQUFJSixVQUFVLENBQUMsR0FBRztnQkFDaEIsTUFBTSxJQUFJTSxZQUFZLENBQUMsOEJBQThCLEVBQUVKLEVBQUUsQ0FBQztZQUM1RDtZQUVBLElBQUlELFFBQVEsQ0FBQyxHQUFHQSxNQUFNQztZQUV0QixNQUFNSyxXQUFXVixPQUFPVyxLQUFLLENBQUNSLE9BQU9DO1lBRXJDLElBQUlILFVBQVVXLEdBQUcsQ0FBQ0YsV0FBVztnQkFDM0IsTUFBTSxJQUFJRCxZQUFZLENBQUMsS0FBSyxFQUFFQyxTQUFTLDJCQUEyQixDQUFDO1lBQ3JFO1lBRUFULFVBQVVZLEdBQUcsQ0FBQ0g7WUFDZFAsUUFBUUMsTUFBTSxDQUFDO1FBQ2pCLE9BQU87WUFDTCxNQUFNLElBQUlLLFlBQVksQ0FBQyw4QkFBOEIsRUFBRUosRUFBRSxDQUFDO1FBQzVEO0lBQ0Y7SUFFQSxJQUFJRixVQUFVLENBQUMsS0FBS0MsUUFBUSxDQUFDLEdBQUc7UUFDOUIsTUFBTSxJQUFJSyxZQUFZO0lBQ3hCO0lBRUEsTUFBTUMsV0FBV1YsT0FBT1csS0FBSyxDQUFDUixPQUFPRTtJQUVyQyxJQUFJSixVQUFVVyxHQUFHLENBQUNGLFdBQVc7UUFDM0IsTUFBTSxJQUFJRCxZQUFZLENBQUMsS0FBSyxFQUFFQyxTQUFTLDJCQUEyQixDQUFDO0lBQ3JFO0lBRUFULFVBQVVZLEdBQUcsQ0FBQ0g7SUFDZCxPQUFPVDtBQUNUO0FBRUFhLE9BQU9DLE9BQU8sR0FBRztJQUFFaEI7QUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL3doYXRzYXBwLWFpLWNybS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzP2Q3OGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGkgIT09IDAgJiZcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cblxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhcnNlIH07XG4iXSwibmFtZXMiOlsidG9rZW5DaGFycyIsInJlcXVpcmUiLCJwYXJzZSIsImhlYWRlciIsInByb3RvY29scyIsIlNldCIsInN0YXJ0IiwiZW5kIiwiaSIsImxlbmd0aCIsImNvZGUiLCJjaGFyQ29kZUF0IiwiU3ludGF4RXJyb3IiLCJwcm90b2NvbCIsInNsaWNlIiwiaGFzIiwiYWRkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/validation.js":
/*!**************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/validation.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { isUtf8 } = __webpack_require__(/*! buffer */ \"buffer\");\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0 // 112 - 127\n];\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */ function isValidStatusCode(code) {\n    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n}\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */ function _isValidUTF8(buf) {\n    const len = buf.length;\n    let i = 0;\n    while(i < len){\n        if ((buf[i] & 0x80) === 0) {\n            // 0xxxxxxx\n            i++;\n        } else if ((buf[i] & 0xe0) === 0xc0) {\n            // 110xxxxx 10xxxxxx\n            if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n            ) {\n                return false;\n            }\n            i += 2;\n        } else if ((buf[i] & 0xf0) === 0xe0) {\n            // 1110xxxx 10xxxxxx 10xxxxxx\n            if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong\n            buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n            ) {\n                return false;\n            }\n            i += 3;\n        } else if ((buf[i] & 0xf8) === 0xf0) {\n            // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n            if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong\n            buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n            ) {\n                return false;\n            }\n            i += 4;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\nmodule.exports = {\n    isValidStatusCode,\n    isValidUTF8: _isValidUTF8,\n    tokenChars\n};\nif (isUtf8) {\n    module.exports.isValidUTF8 = function(buf) {\n        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n    };\n} else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n    try {\n        const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?caf2\");\n        module.exports.isValidUTF8 = function(buf) {\n            return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n        };\n    } catch (e) {\n    // Continue regardless of the error.\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFM0IsRUFBRTtBQUNGLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0YsK0NBQStDO0FBQy9DLDhDQUE4QztBQUM5QyxFQUFFO0FBQ0YsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsTUFBTTtBQUNOLEVBQUU7QUFDRixrQkFBa0I7QUFDbEIsTUFBTUMsYUFBYTtJQUNqQjtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFB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S0FBS0gsYUFBYUMsT0FBT00sWUFBWU47UUFDM0Q7SUFDRixFQUFFLE9BQU9VLEdBQUc7SUFDVixvQ0FBb0M7SUFDdEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3doYXRzYXBwLWFpLWNybS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanM/NTY0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgaXNVdGY4IH0gPSByZXF1aXJlKCdidWZmZXInKTtcblxuLy9cbi8vIEFsbG93ZWQgdG9rZW4gY2hhcmFjdGVyczpcbi8vXG4vLyAnIScsICcjJywgJyQnLCAnJScsICcmJywgJycnLCAnKicsICcrJywgJy0nLFxuLy8gJy4nLCAwLTksIEEtWiwgJ14nLCAnXycsICdgJywgYS16LCAnfCcsICd+J1xuLy9cbi8vIHRva2VuQ2hhcnNbMzJdID09PSAwIC8vICcgJ1xuLy8gdG9rZW5DaGFyc1szM10gPT09IDEgLy8gJyEnXG4vLyB0b2tlbkNoYXJzWzM0XSA9PT0gMCAvLyAnXCInXG4vLyAuLi5cbi8vXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHRva2VuQ2hhcnMgPSBbXG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDAgLSAxNVxuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAxNiAtIDMxXG4gIDAsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsIDEsIDEsIDAsIC8vIDMyIC0gNDdcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNDggLSA2M1xuICAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA2NCAtIDc5XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDEsIC8vIDgwIC0gOTVcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gOTYgLSAxMTFcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMCAvLyAxMTIgLSAxMjdcbl07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhdHVzIGNvZGUgaXMgYWxsb3dlZCBpbiBhIGNsb3NlIGZyYW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzdGF0dXMgY29kZSBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICAoY29kZSA+PSAxMDAwICYmXG4gICAgICBjb2RlIDw9IDEwMTQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDUgJiZcbiAgICAgIGNvZGUgIT09IDEwMDYpIHx8XG4gICAgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpXG4gICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYnVmZmVyIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOC5cbiAqIFBvcnRlZCBmcm9tIGh0dHBzOi8vd3d3LmNsLmNhbS5hYy51ay8lN0VtZ2syNS91Y3MvdXRmOF9jaGVjay5jIGJ5XG4gKiBNYXJrdXMgS3Vobi5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgYnVmYCBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTgsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfaXNWYWxpZFVURjgoYnVmKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmICgoYnVmW2ldICYgMHg4MCkgPT09IDApIHtcbiAgICAgIC8vIDB4eHh4eHh4XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAxID09PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldICYgMHhmZSkgPT09IDB4YzAgLy8gT3ZlcmxvbmdcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDIgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGUwICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZWQgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHhhMCkgLy8gU3Vycm9nYXRlIChVK0Q4MDAgLSBVK0RGRkYpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDM7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgIC8vIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAzID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgM10gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGYwICYmIChidWZbaSArIDFdICYgMHhmMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZjQgJiYgYnVmW2kgKyAxXSA+IDB4OGYpIHx8XG4gICAgICAgIGJ1ZltpXSA+IDB4ZjQgLy8gPiBVKzEwRkZGRlxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcbiAgdG9rZW5DaGFyc1xufTtcblxuaWYgKGlzVXRmOCkge1xuICBtb2R1bGUuZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDI0ID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1V0ZjgoYnVmKTtcbiAgfTtcbn0gLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovIGVsc2UgaWYgKCFwcm9jZXNzLmVudi5XU19OT19VVEZfOF9WQUxJREFURSkge1xuICB0cnkge1xuICAgIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAzMiA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpc1V0ZjgiLCJyZXF1aXJlIiwidG9rZW5DaGFycyIsImlzVmFsaWRTdGF0dXNDb2RlIiwiY29kZSIsIl9pc1ZhbGlkVVRGOCIsImJ1ZiIsImxlbiIsImxlbmd0aCIsImkiLCJtb2R1bGUiLCJleHBvcnRzIiwiaXNWYWxpZFVURjgiLCJwcm9jZXNzIiwiZW52IiwiV1NfTk9fVVRGXzhfVkFMSURBVEUiLCJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/websocket-server.js":
/*!********************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/websocket-server.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */ \nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst extension = __webpack_require__(/*! ./extension */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/websocket.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/constants.js\");\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */ class WebSocketServer extends EventEmitter {\n    /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */ constructor(options, callback){\n        super();\n        options = {\n            allowSynchronousEvents: true,\n            autoPong: true,\n            maxPayload: 100 * 1024 * 1024,\n            skipUTF8Validation: false,\n            perMessageDeflate: false,\n            handleProtocols: null,\n            clientTracking: true,\n            verifyClient: null,\n            noServer: false,\n            backlog: null,\n            server: null,\n            host: null,\n            path: null,\n            port: null,\n            WebSocket,\n            ...options\n        };\n        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n            throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + \"must be specified\");\n        }\n        if (options.port != null) {\n            this._server = http.createServer((req, res)=>{\n                const body = http.STATUS_CODES[426];\n                res.writeHead(426, {\n                    \"Content-Length\": body.length,\n                    \"Content-Type\": \"text/plain\"\n                });\n                res.end(body);\n            });\n            this._server.listen(options.port, options.host, options.backlog, callback);\n        } else if (options.server) {\n            this._server = options.server;\n        }\n        if (this._server) {\n            const emitConnection = this.emit.bind(this, \"connection\");\n            this._removeListeners = addListeners(this._server, {\n                listening: this.emit.bind(this, \"listening\"),\n                error: this.emit.bind(this, \"error\"),\n                upgrade: (req, socket, head)=>{\n                    this.handleUpgrade(req, socket, head, emitConnection);\n                }\n            });\n        }\n        if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n        if (options.clientTracking) {\n            this.clients = new Set();\n            this._shouldEmitClose = false;\n        }\n        this.options = options;\n        this._state = RUNNING;\n    }\n    /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */ address() {\n        if (this.options.noServer) {\n            throw new Error('The server is operating in \"noServer\" mode');\n        }\n        if (!this._server) return null;\n        return this._server.address();\n    }\n    /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */ close(cb) {\n        if (this._state === CLOSED) {\n            if (cb) {\n                this.once(\"close\", ()=>{\n                    cb(new Error(\"The server is not running\"));\n                });\n            }\n            process.nextTick(emitClose, this);\n            return;\n        }\n        if (cb) this.once(\"close\", cb);\n        if (this._state === CLOSING) return;\n        this._state = CLOSING;\n        if (this.options.noServer || this.options.server) {\n            if (this._server) {\n                this._removeListeners();\n                this._removeListeners = this._server = null;\n            }\n            if (this.clients) {\n                if (!this.clients.size) {\n                    process.nextTick(emitClose, this);\n                } else {\n                    this._shouldEmitClose = true;\n                }\n            } else {\n                process.nextTick(emitClose, this);\n            }\n        } else {\n            const server = this._server;\n            this._removeListeners();\n            this._removeListeners = this._server = null;\n            //\n            // The HTTP/S server was created internally. Close it, and rely on its\n            // `'close'` event.\n            //\n            server.close(()=>{\n                emitClose(this);\n            });\n        }\n    }\n    /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */ shouldHandle(req) {\n        if (this.options.path) {\n            const index = req.url.indexOf(\"?\");\n            const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n            if (pathname !== this.options.path) return false;\n        }\n        return true;\n    }\n    /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */ handleUpgrade(req, socket, head, cb) {\n        socket.on(\"error\", socketOnError);\n        const key = req.headers[\"sec-websocket-key\"];\n        const upgrade = req.headers.upgrade;\n        const version = +req.headers[\"sec-websocket-version\"];\n        if (req.method !== \"GET\") {\n            const message = \"Invalid HTTP method\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n            return;\n        }\n        if (upgrade === undefined || upgrade.toLowerCase() !== \"websocket\") {\n            const message = \"Invalid Upgrade header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n        }\n        if (key === undefined || !keyRegex.test(key)) {\n            const message = \"Missing or invalid Sec-WebSocket-Key header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n        }\n        if (version !== 8 && version !== 13) {\n            const message = \"Missing or invalid Sec-WebSocket-Version header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n        }\n        if (!this.shouldHandle(req)) {\n            abortHandshake(socket, 400);\n            return;\n        }\n        const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n        let protocols = new Set();\n        if (secWebSocketProtocol !== undefined) {\n            try {\n                protocols = subprotocol.parse(secWebSocketProtocol);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Protocol header\";\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n        }\n        const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n        const extensions = {};\n        if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n            const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n            try {\n                const offers = extension.parse(secWebSocketExtensions);\n                if (offers[PerMessageDeflate.extensionName]) {\n                    perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n                    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n                }\n            } catch (err) {\n                const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n        }\n        //\n        // Optionally call external client verification handler.\n        //\n        if (this.options.verifyClient) {\n            const info = {\n                origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n                secure: !!(req.socket.authorized || req.socket.encrypted),\n                req\n            };\n            if (this.options.verifyClient.length === 2) {\n                this.options.verifyClient(info, (verified, code, message, headers)=>{\n                    if (!verified) {\n                        return abortHandshake(socket, code || 401, message, headers);\n                    }\n                    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n                });\n                return;\n            }\n            if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n        }\n        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n    }\n    /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */ completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n        //\n        // Destroy the socket if the client has already sent a FIN packet.\n        //\n        if (!socket.readable || !socket.writable) return socket.destroy();\n        if (socket[kWebSocket]) {\n            throw new Error(\"server.handleUpgrade() was called more than once with the same \" + \"socket, possibly due to a misconfiguration\");\n        }\n        if (this._state > RUNNING) return abortHandshake(socket, 503);\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        const headers = [\n            \"HTTP/1.1 101 Switching Protocols\",\n            \"Upgrade: websocket\",\n            \"Connection: Upgrade\",\n            `Sec-WebSocket-Accept: ${digest}`\n        ];\n        const ws = new this.options.WebSocket(null, undefined, this.options);\n        if (protocols.size) {\n            //\n            // Optionally call external protocol selection handler.\n            //\n            const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n            if (protocol) {\n                headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n                ws._protocol = protocol;\n            }\n        }\n        if (extensions[PerMessageDeflate.extensionName]) {\n            const params = extensions[PerMessageDeflate.extensionName].params;\n            const value = extension.format({\n                [PerMessageDeflate.extensionName]: [\n                    params\n                ]\n            });\n            headers.push(`Sec-WebSocket-Extensions: ${value}`);\n            ws._extensions = extensions;\n        }\n        //\n        // Allow external modification/inspection of handshake headers.\n        //\n        this.emit(\"headers\", headers, req);\n        socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n        socket.removeListener(\"error\", socketOnError);\n        ws.setSocket(socket, head, {\n            allowSynchronousEvents: this.options.allowSynchronousEvents,\n            maxPayload: this.options.maxPayload,\n            skipUTF8Validation: this.options.skipUTF8Validation\n        });\n        if (this.clients) {\n            this.clients.add(ws);\n            ws.on(\"close\", ()=>{\n                this.clients.delete(ws);\n                if (this._shouldEmitClose && !this.clients.size) {\n                    process.nextTick(emitClose, this);\n                }\n            });\n        }\n        cb(ws, req);\n    }\n}\nmodule.exports = WebSocketServer;\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */ function addListeners(server, map) {\n    for (const event of Object.keys(map))server.on(event, map[event]);\n    return function removeListeners() {\n        for (const event of Object.keys(map)){\n            server.removeListener(event, map[event]);\n        }\n    };\n}\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */ function emitClose(server) {\n    server._state = CLOSED;\n    server.emit(\"close\");\n}\n/**\n * Handle socket errors.\n *\n * @private\n */ function socketOnError() {\n    this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */ function abortHandshake(socket, code, message, headers) {\n    //\n    // The socket is writable unless the user destroyed or ended it before calling\n    // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n    // error. Handling this does not make much sense as the worst that can happen\n    // is that some of the data written by the user might be discarded due to the\n    // call to `socket.end()` below, which triggers an `'error'` event that in\n    // turn causes the socket to be destroyed.\n    //\n    message = message || http.STATUS_CODES[code];\n    headers = {\n        Connection: \"close\",\n        \"Content-Type\": \"text/html\",\n        \"Content-Length\": Buffer.byteLength(message),\n        ...headers\n    };\n    socket.once(\"finish\", socket.destroy);\n    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map((h)=>`${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message);\n}\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */ function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n    if (server.listenerCount(\"wsClientError\")) {\n        const err = new Error(message);\n        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n        server.emit(\"wsClientError\", err, socket, req);\n    } else {\n        abortHandshake(socket, code, message);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlHQUFpRyxHQUVqRztBQUVBLE1BQU1BLGVBQWVDLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUUsTUFBTSxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRUcsVUFBVSxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBRS9CLE1BQU1JLFlBQVlKLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1LLG9CQUFvQkwsbUJBQU9BLENBQUM7QUFDbEMsTUFBTU0sY0FBY04sbUJBQU9BLENBQUM7QUFDNUIsTUFBTU8sWUFBWVAsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFUSxJQUFJLEVBQUVDLFVBQVUsRUFBRSxHQUFHVCxtQkFBT0EsQ0FBQztBQUVyQyxNQUFNVSxXQUFXO0FBRWpCLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsVUFBVTtBQUNoQixNQUFNQyxTQUFTO0FBRWY7Ozs7Q0FJQyxHQUNELE1BQU1DLHdCQUF3QmY7SUFDNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQThCQyxHQUNEZ0IsWUFBWUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDN0IsS0FBSztRQUVMRCxVQUFVO1lBQ1JFLHdCQUF3QjtZQUN4QkMsVUFBVTtZQUNWQyxZQUFZLE1BQU0sT0FBTztZQUN6QkMsb0JBQW9CO1lBQ3BCQyxtQkFBbUI7WUFDbkJDLGlCQUFpQjtZQUNqQkMsZ0JBQWdCO1lBQ2hCQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsU0FBUztZQUNUQyxRQUFRO1lBQ1JDLE1BQU07WUFDTkMsTUFBTTtZQUNOQyxNQUFNO1lBQ054QjtZQUNBLEdBQUdTLE9BQU87UUFDWjtRQUVBLElBQ0UsUUFBU2UsSUFBSSxJQUFJLFFBQVEsQ0FBQ2Ys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QzdFLDZFQUE2RTtJQUM3RSwwRUFBMEU7SUFDMUUsMENBQTBDO0lBQzFDLEVBQUU7SUFDRkcsVUFBVUEsV0FBVzlFLEtBQUtxQyxZQUFZLENBQUM4RCxLQUFLO0lBQzVDeEIsVUFBVTtRQUNSdUQsWUFBWTtRQUNaLGdCQUFnQjtRQUNoQixrQkFBa0JDLE9BQU9DLFVBQVUsQ0FBQ3REO1FBQ3BDLEdBQUdILE9BQU87SUFDWjtJQUVBekIsT0FBT1csSUFBSSxDQUFDLFVBQVVYLE9BQU9xRCxPQUFPO0lBRXBDckQsT0FBT1YsR0FBRyxDQUNSLENBQUMsU0FBUyxFQUFFMkQsS0FBSyxDQUFDLEVBQUVuRyxLQUFLcUMsWUFBWSxDQUFDOEQsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUMvQzRCLE9BQU9DLElBQUksQ0FBQ3JELFNBQ1RrRCxHQUFHLENBQUMsQ0FBQ1EsSUFBTSxDQUFDLEVBQUVBLEVBQUUsRUFBRSxFQUFFMUQsT0FBTyxDQUFDMEQsRUFBRSxDQUFDLENBQUMsRUFDaENmLElBQUksQ0FBQyxVQUNSLGFBQ0F4QztBQUVOO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVNDLGtDQUFrQ3BELE1BQU0sRUFBRU8sR0FBRyxFQUFFZ0IsTUFBTSxFQUFFaUQsSUFBSSxFQUFFckIsT0FBTztJQUMzRSxJQUFJbkQsT0FBTzJHLGFBQWEsQ0FBQyxrQkFBa0I7UUFDekMsTUFBTS9DLE1BQU0sSUFBSTdCLE1BQU1vQjtRQUN0QnBCLE1BQU02RSxpQkFBaUIsQ0FBQ2hELEtBQUtSO1FBRTdCcEQsT0FBT2dCLElBQUksQ0FBQyxpQkFBaUI0QyxLQUFLckMsUUFBUWhCO0lBQzVDLE9BQU87UUFDTGlELGVBQWVqQyxRQUFRaUQsTUFBTXJCO0lBQy9CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzPzVkZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4JFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IGV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmUoJy4vc3VicHJvdG9jb2wnKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtleVJlZ2V4ID0gL15bKy8wLTlBLVphLXpdezIyfT09JC87XG5cbmNvbnN0IFJVTk5JTkcgPSAwO1xuY29uc3QgQ0xPU0lORyA9IDE7XG5jb25zdCBDTE9TRUQgPSAyO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBvbmcgaW4gcmVzcG9uc2UgdG8gYSBwaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYWNrbG9nPTUxMV0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZlxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgdHJhY2sgY2xpZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gICAqICAgICBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aF0gQWNjZXB0IG9ubHkgY29ubmVjdGlvbnMgbWF0Y2hpbmcgdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvcnRdIFRoZSBwb3J0IHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXG4gICAqICAgICBzZXJ2ZXIgdG8gdXNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLldlYlNvY2tldD1XZWJTb2NrZXRdIFNwZWNpZmllcyB0aGUgYFdlYlNvY2tldGBcbiAgICogICAgIGNsYXNzIHRvIHVzZS4gSXQgbXVzdCBiZSB0aGUgYFdlYlNvY2tldGAgY2xhc3Mgb3IgY2xhc3MgdGhhdCBleHRlbmRzIGl0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcbiAgICAgIGF1dG9Qb25nOiB0cnVlLFxuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIFdlYlNvY2tldCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikgfHxcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XG4gICAgICAob3B0aW9ucy5zZXJ2ZXIgJiYgb3B0aW9ucy5ub1NlcnZlcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgJyArXG4gICAgICAgICAgJ211c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXG4gICAgICAgIG9wdGlvbnMucG9ydCxcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xuICAgICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogd2hlbiBhbGwgZXhpc3RpbmcgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGNiKG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBub3QgcnVubmluZycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xuICAgICAgLy8gYCdjbG9zZSdgIGV2ZW50LlxuICAgICAgLy9cbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgIGVtaXRDbG9zZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzaG91bGRIYW5kbGUocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICBjb25zdCBrZXkgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXTtcbiAgICBjb25zdCB1cGdyYWRlID0gcmVxLmhlYWRlcnMudXBncmFkZTtcbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcblxuICAgIGlmIChyZXEubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIEhUVFAgbWV0aG9kJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDA1LCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8ICFrZXlSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtS2V5IGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtVmVyc2lvbiBoZWFkZXInO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zaG91bGRIYW5kbGUocmVxKSkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldFByb3RvY29sID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBsZXQgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldFByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb3RvY29scyA9IHN1YnByb3RvY29sLnBhcnNlKHNlY1dlYlNvY2tldFByb3RvY29sKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnSW52YWxpZCBvciB1bmFjY2VwdGFibGUgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBvcmlnaW46XG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxuICAgICAgICByZXFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xuICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUgfHwgNDAxLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgY2JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxuICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICAvL1xuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxuICAgIC8vXG4gICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPiBSVU5OSU5HKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA1MDMpO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldCcsXG4gICAgICAnQ29ubmVjdGlvbjogVXBncmFkZScsXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcbiAgICBdO1xuXG4gICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5vcHRpb25zLldlYlNvY2tldChudWxsLCB1bmRlZmluZWQsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAocHJvdG9jb2xzLnNpemUpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgcHJvdG9jb2wgc2VsZWN0aW9uIGhhbmRsZXIuXG4gICAgICAvL1xuICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scyhwcm90b2NvbHMsIHJlcSlcbiAgICAgICAgOiBwcm90b2NvbHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5mb3JtYXQoe1xuICAgICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IFtwYXJhbXNdXG4gICAgICB9KTtcbiAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAke3ZhbHVlfWApO1xuICAgICAgd3MuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQWxsb3cgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uL2luc3BlY3Rpb24gb2YgaGFuZHNoYWtlIGhlYWRlcnMuXG4gICAgLy9cbiAgICB0aGlzLmVtaXQoJ2hlYWRlcnMnLCBoZWFkZXJzLCByZXEpO1xuXG4gICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KCdcXHJcXG4nKS5qb2luKCdcXHJcXG4nKSk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgd3Muc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdGhpcy5vcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG4gICAgICBtYXhQYXlsb2FkOiB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogdGhpcy5vcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgdGhpcy5jbGllbnRzLmFkZCh3cyk7XG4gICAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUod3MpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRFbWl0Q2xvc2UgJiYgIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYih3cywgcmVxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW5cbiAqICAgICBjYWxsZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbWFwW2V2ZW50XSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVtaXQgYSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYW4gYEV2ZW50RW1pdHRlcmAuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHNlcnZlcikge1xuICBzZXJ2ZXIuX3N0YXRlID0gQ0xPU0VEO1xuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgc29ja2V0IGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICAvL1xuICAvLyBUaGUgc29ja2V0IGlzIHdyaXRhYmxlIHVubGVzcyB0aGUgdXNlciBkZXN0cm95ZWQgb3IgZW5kZWQgaXQgYmVmb3JlIGNhbGxpbmdcbiAgLy8gYHNlcnZlci5oYW5kbGVVcGdyYWRlKClgIG9yIGluIHRoZSBgdmVyaWZ5Q2xpZW50YCBmdW5jdGlvbiwgd2hpY2ggaXMgYSB1c2VyXG4gIC8vIGVycm9yLiBIYW5kbGluZyB0aGlzIGRvZXMgbm90IG1ha2UgbXVjaCBzZW5zZSBhcyB0aGUgd29yc3QgdGhhdCBjYW4gaGFwcGVuXG4gIC8vIGlzIHRoYXQgc29tZSBvZiB0aGUgZGF0YSB3cml0dGVuIGJ5IHRoZSB1c2VyIG1pZ2h0IGJlIGRpc2NhcmRlZCBkdWUgdG8gdGhlXG4gIC8vIGNhbGwgdG8gYHNvY2tldC5lbmQoKWAgYmVsb3csIHdoaWNoIHRyaWdnZXJzIGFuIGAnZXJyb3InYCBldmVudCB0aGF0IGluXG4gIC8vIHR1cm4gY2F1c2VzIHRoZSBzb2NrZXQgdG8gYmUgZGVzdHJveWVkLlxuICAvL1xuICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgaGVhZGVycyA9IHtcbiAgICBDb25uZWN0aW9uOiAnY2xvc2UnLFxuICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKSxcbiAgICAuLi5oZWFkZXJzXG4gIH07XG5cbiAgc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIHNvY2tldC5kZXN0cm95KTtcblxuICBzb2NrZXQuZW5kKFxuICAgIGBIVFRQLzEuMSAke2NvZGV9ICR7aHR0cC5TVEFUVVNfQ09ERVNbY29kZV19XFxyXFxuYCArXG4gICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG4gICAgICAgIC5qb2luKCdcXHJcXG4nKSArXG4gICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICBtZXNzYWdlXG4gICk7XG59XG5cbi8qKlxuICogRW1pdCBhIGAnd3NDbGllbnRFcnJvcidgIGV2ZW50IG9uIGEgYFdlYlNvY2tldFNlcnZlcmAgaWYgdGhlcmUgaXMgYXQgbGVhc3RcbiAqIG9uZSBsaXN0ZW5lciBmb3IgaXQsIG90aGVyd2lzZSBjYWxsIGBhYm9ydEhhbmRzaGFrZSgpYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldFNlcnZlcn0gc2VydmVyIFRoZSBXZWJTb2NrZXQgc2VydmVyXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcihzZXJ2ZXIsIHJlcSwgc29ja2V0LCBjb2RlLCBtZXNzYWdlKSB7XG4gIGlmIChzZXJ2ZXIubGlzdGVuZXJDb3VudCgnd3NDbGllbnRFcnJvcicpKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKTtcblxuICAgIHNlcnZlci5lbWl0KCd3c0NsaWVudEVycm9yJywgZXJyLCBzb2NrZXQsIHJlcSk7XG4gIH0gZWxzZSB7XG4gICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsInJlcXVpcmUiLCJodHRwIiwiRHVwbGV4IiwiY3JlYXRlSGFzaCIsImV4dGVuc2lvbiIsIlBlck1lc3NhZ2VEZWZsYXRlIiwic3VicHJvdG9jb2wiLCJXZWJTb2NrZXQiLCJHVUlEIiwia1dlYlNvY2tldCIsImtleVJlZ2V4IiwiUlVOTklORyIsIkNMT1NJTkciLCJDTE9TRUQiLCJXZWJTb2NrZXRTZXJ2ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImFsbG93U3luY2hyb25vdXNFdmVudHMiLCJhdXRvUG9uZyIsIm1heFBheWxvYWQiLCJza2lwVVRGOFZhbGlkYXRpb24iLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImhhbmRsZVByb3RvY29scyIsImNsaWVudFRyYWNraW5nIiwidmVyaWZ5Q2xpZW50Iiwibm9TZXJ2ZXIiLCJiYWNrbG9nIiwic2VydmVyIiwiaG9zdCIsInBhdGgiLCJwb3J0IiwiVHlwZUVycm9yIiwiX3NlcnZlciIsImNyZWF0ZVNlcnZlciIsInJlcSIsInJlcyIsImJvZHkiLCJTVEFUVVNfQ09ERVMiLCJ3cml0ZUhlYWQiLCJsZW5ndGgiLCJlbmQiLCJsaXN0ZW4iLCJlbWl0Q29ubmVjdGlvbiIsImVtaXQiLCJiaW5kIiwiX3JlbW92ZUxpc3RlbmVycyIsImFkZExpc3RlbmVycyIsImxpc3RlbmluZyIsImVycm9yIiwidXBncmFkZSIsInNvY2tldCIsImhlYWQiLCJoYW5kbGVVcGdyYWRlIiwiY2xpZW50cyIsIlNldCIsIl9zaG91bGRFbWl0Q2xvc2UiLCJfc3RhdGUiLCJhZGRyZXNzIiwiRXJyb3IiLCJjbG9zZSIsImNiIiwib25jZSIsInByb2Nlc3MiLCJuZXh0VGljayIsImVtaXRDbG9zZSIsInNpemUiLCJzaG91bGRIYW5kbGUiLCJpbmRleCIsInVybCIsImluZGV4T2YiLCJwYXRobmFtZSIsInNsaWNlIiwib24iLCJzb2NrZXRPbkVycm9yIiwia2V5IiwiaGVhZGVycyIsInZlcnNpb24iLCJtZXRob2QiLCJtZXNzYWdlIiwiYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yIiwidW5kZWZpbmVkIiwidG9Mb3dlckNhc2UiLCJ0ZXN0IiwiYWJvcnRIYW5kc2hha2UiLCJzZWNXZWJTb2NrZXRQcm90b2NvbCIsInByb3RvY29scyIsInBhcnNlIiwiZXJyIiwic2VjV2ViU29ja2V0RXh0ZW5zaW9ucyIsImV4dGVuc2lvbnMiLCJvZmZlcnMiLCJleHRlbnNpb25OYW1lIiwiYWNjZXB0IiwiaW5mbyIsIm9yaWdpbiIsInNlY3VyZSIsImF1dGhvcml6ZWQiLCJlbmNyeXB0ZWQiLCJ2ZXJpZmllZCIsImNvZGUiLCJjb21wbGV0ZVVwZ3JhZGUiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwiZGVzdHJveSIsImRpZ2VzdCIsInVwZGF0ZSIsIndzIiwicHJvdG9jb2wiLCJ2YWx1ZXMiLCJuZXh0IiwidmFsdWUiLCJwdXNoIiwiX3Byb3RvY29sIiwicGFyYW1zIiwiZm9ybWF0IiwiX2V4dGVuc2lvbnMiLCJ3cml0ZSIsImNvbmNhdCIsImpvaW4iLCJyZW1vdmVMaXN0ZW5lciIsInNldFNvY2tldCIsImFkZCIsImRlbGV0ZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJtYXAiLCJldmVudCIsIk9iamVjdCIsImtleXMiLCJyZW1vdmVMaXN0ZW5lcnMiLCJDb25uZWN0aW9uIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsImgiLCJsaXN0ZW5lckNvdW50IiwiY2FwdHVyZVN0YWNrVHJhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/websocket.js":
/*!*************************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/lib/websocket.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */ \nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Duplex, Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/sender.js\");\nconst { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/constants.js\");\nconst { EventTarget: { addEventListener, removeEventListener } } = __webpack_require__(/*! ./event-target */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/buffer-util.js\");\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol(\"kAborted\");\nconst protocolVersions = [\n    8,\n    13\n];\nconst readyStates = [\n    \"CONNECTING\",\n    \"OPEN\",\n    \"CLOSING\",\n    \"CLOSED\"\n];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */ class WebSocket extends EventEmitter {\n    /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */ constructor(address, protocols, options){\n        super();\n        this._binaryType = BINARY_TYPES[0];\n        this._closeCode = 1006;\n        this._closeFrameReceived = false;\n        this._closeFrameSent = false;\n        this._closeMessage = EMPTY_BUFFER;\n        this._closeTimer = null;\n        this._extensions = {};\n        this._paused = false;\n        this._protocol = \"\";\n        this._readyState = WebSocket.CONNECTING;\n        this._receiver = null;\n        this._sender = null;\n        this._socket = null;\n        if (address !== null) {\n            this._bufferedAmount = 0;\n            this._isServer = false;\n            this._redirects = 0;\n            if (protocols === undefined) {\n                protocols = [];\n            } else if (!Array.isArray(protocols)) {\n                if (typeof protocols === \"object\" && protocols !== null) {\n                    options = protocols;\n                    protocols = [];\n                } else {\n                    protocols = [\n                        protocols\n                    ];\n                }\n            }\n            initAsClient(this, address, protocols, options);\n        } else {\n            this._autoPong = options.autoPong;\n            this._isServer = true;\n        }\n    }\n    /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */ get binaryType() {\n        return this._binaryType;\n    }\n    set binaryType(type) {\n        if (!BINARY_TYPES.includes(type)) return;\n        this._binaryType = type;\n        //\n        // Allow to change `binaryType` on the fly.\n        //\n        if (this._receiver) this._receiver._binaryType = type;\n    }\n    /**\n   * @type {Number}\n   */ get bufferedAmount() {\n        if (!this._socket) return this._bufferedAmount;\n        return this._socket._writableState.length + this._sender._bufferedBytes;\n    }\n    /**\n   * @type {String}\n   */ get extensions() {\n        return Object.keys(this._extensions).join();\n    }\n    /**\n   * @type {Boolean}\n   */ get isPaused() {\n        return this._paused;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onclose() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onerror() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onopen() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onmessage() {\n        return null;\n    }\n    /**\n   * @type {String}\n   */ get protocol() {\n        return this._protocol;\n    }\n    /**\n   * @type {Number}\n   */ get readyState() {\n        return this._readyState;\n    }\n    /**\n   * @type {String}\n   */ get url() {\n        return this._url;\n    }\n    /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */ setSocket(socket, head, options) {\n        const receiver = new Receiver({\n            allowSynchronousEvents: options.allowSynchronousEvents,\n            binaryType: this.binaryType,\n            extensions: this._extensions,\n            isServer: this._isServer,\n            maxPayload: options.maxPayload,\n            skipUTF8Validation: options.skipUTF8Validation\n        });\n        this._sender = new Sender(socket, this._extensions, options.generateMask);\n        this._receiver = receiver;\n        this._socket = socket;\n        receiver[kWebSocket] = this;\n        socket[kWebSocket] = this;\n        receiver.on(\"conclude\", receiverOnConclude);\n        receiver.on(\"drain\", receiverOnDrain);\n        receiver.on(\"error\", receiverOnError);\n        receiver.on(\"message\", receiverOnMessage);\n        receiver.on(\"ping\", receiverOnPing);\n        receiver.on(\"pong\", receiverOnPong);\n        //\n        // These methods may not be available if `socket` is just a `Duplex`.\n        //\n        if (socket.setTimeout) socket.setTimeout(0);\n        if (socket.setNoDelay) socket.setNoDelay();\n        if (head.length > 0) socket.unshift(head);\n        socket.on(\"close\", socketOnClose);\n        socket.on(\"data\", socketOnData);\n        socket.on(\"end\", socketOnEnd);\n        socket.on(\"error\", socketOnError);\n        this._readyState = WebSocket.OPEN;\n        this.emit(\"open\");\n    }\n    /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */ emitClose() {\n        if (!this._socket) {\n            this._readyState = WebSocket.CLOSED;\n            this.emit(\"close\", this._closeCode, this._closeMessage);\n            return;\n        }\n        if (this._extensions[PerMessageDeflate.extensionName]) {\n            this._extensions[PerMessageDeflate.extensionName].cleanup();\n        }\n        this._receiver.removeAllListeners();\n        this._readyState = WebSocket.CLOSED;\n        this.emit(\"close\", this._closeCode, this._closeMessage);\n    }\n    /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */ close(code, data) {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            const msg = \"WebSocket was closed before the connection was established\";\n            abortHandshake(this, this._req, msg);\n            return;\n        }\n        if (this.readyState === WebSocket.CLOSING) {\n            if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n                this._socket.end();\n            }\n            return;\n        }\n        this._readyState = WebSocket.CLOSING;\n        this._sender.close(code, data, !this._isServer, (err)=>{\n            //\n            // This error is handled by the `'error'` listener on the socket. We only\n            // want to know if the close frame has been sent here.\n            //\n            if (err) return;\n            this._closeFrameSent = true;\n            if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n                this._socket.end();\n            }\n        });\n        //\n        // Specify a timeout for the closing handshake to complete.\n        //\n        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n    }\n    /**\n   * Pause the socket.\n   *\n   * @public\n   */ pause() {\n        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n            return;\n        }\n        this._paused = true;\n        this._socket.pause();\n    }\n    /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */ ping(data, mask, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n            cb = data;\n            data = mask = undefined;\n        } else if (typeof mask === \"function\") {\n            cb = mask;\n            mask = undefined;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */ pong(data, mask, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n            cb = data;\n            data = mask = undefined;\n        } else if (typeof mask === \"function\") {\n            cb = mask;\n            mask = undefined;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n   * Resume the socket.\n   *\n   * @public\n   */ resume() {\n        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n            return;\n        }\n        this._paused = false;\n        if (!this._receiver._writableState.needDrain) this._socket.resume();\n    }\n    /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */ send(data, options, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof options === \"function\") {\n            cb = options;\n            options = {};\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        const opts = {\n            binary: typeof data !== \"string\",\n            mask: !this._isServer,\n            compress: true,\n            fin: true,\n            ...options\n        };\n        if (!this._extensions[PerMessageDeflate.extensionName]) {\n            opts.compress = false;\n        }\n        this._sender.send(data || EMPTY_BUFFER, opts, cb);\n    }\n    /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */ terminate() {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            const msg = \"WebSocket was closed before the connection was established\";\n            abortHandshake(this, this._req, msg);\n            return;\n        }\n        if (this._socket) {\n            this._readyState = WebSocket.CLOSING;\n            this._socket.destroy();\n        }\n    }\n}\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CONNECTING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CONNECTING\")\n});\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CONNECTING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CONNECTING\")\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"OPEN\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"OPEN\")\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"OPEN\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"OPEN\")\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CLOSING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSING\")\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CLOSING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSING\")\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CLOSED\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSED\")\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CLOSED\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSED\")\n});\n[\n    \"binaryType\",\n    \"bufferedAmount\",\n    \"extensions\",\n    \"isPaused\",\n    \"protocol\",\n    \"readyState\",\n    \"url\"\n].forEach((property)=>{\n    Object.defineProperty(WebSocket.prototype, property, {\n        enumerable: true\n    });\n});\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n[\n    \"open\",\n    \"error\",\n    \"close\",\n    \"message\"\n].forEach((method)=>{\n    Object.defineProperty(WebSocket.prototype, `on${method}`, {\n        enumerable: true,\n        get () {\n            for (const listener of this.listeners(method)){\n                if (listener[kForOnEventAttribute]) return listener[kListener];\n            }\n            return null;\n        },\n        set (handler) {\n            for (const listener of this.listeners(method)){\n                if (listener[kForOnEventAttribute]) {\n                    this.removeListener(method, listener);\n                    break;\n                }\n            }\n            if (typeof handler !== \"function\") return;\n            this.addEventListener(method, handler, {\n                [kForOnEventAttribute]: true\n            });\n        }\n    });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */ function initAsClient(websocket, address, protocols, options) {\n    const opts = {\n        allowSynchronousEvents: true,\n        autoPong: true,\n        protocolVersion: protocolVersions[1],\n        maxPayload: 100 * 1024 * 1024,\n        skipUTF8Validation: false,\n        perMessageDeflate: true,\n        followRedirects: false,\n        maxRedirects: 10,\n        ...options,\n        socketPath: undefined,\n        hostname: undefined,\n        protocol: undefined,\n        timeout: undefined,\n        method: \"GET\",\n        host: undefined,\n        path: undefined,\n        port: undefined\n    };\n    websocket._autoPong = opts.autoPong;\n    if (!protocolVersions.includes(opts.protocolVersion)) {\n        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(\", \")})`);\n    }\n    let parsedUrl;\n    if (address instanceof URL) {\n        parsedUrl = address;\n    } else {\n        try {\n            parsedUrl = new URL(address);\n        } catch (e) {\n            throw new SyntaxError(`Invalid URL: ${address}`);\n        }\n    }\n    if (parsedUrl.protocol === \"http:\") {\n        parsedUrl.protocol = \"ws:\";\n    } else if (parsedUrl.protocol === \"https:\") {\n        parsedUrl.protocol = \"wss:\";\n    }\n    websocket._url = parsedUrl.href;\n    const isSecure = parsedUrl.protocol === \"wss:\";\n    const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\n    let invalidUrlMessage;\n    if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\n        invalidUrlMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' + '\"http:\", \"https\", or \"ws+unix:\"';\n    } else if (isIpcUrl && !parsedUrl.pathname) {\n        invalidUrlMessage = \"The URL's pathname is empty\";\n    } else if (parsedUrl.hash) {\n        invalidUrlMessage = \"The URL contains a fragment identifier\";\n    }\n    if (invalidUrlMessage) {\n        const err = new SyntaxError(invalidUrlMessage);\n        if (websocket._redirects === 0) {\n            throw err;\n        } else {\n            emitErrorAndClose(websocket, err);\n            return;\n        }\n    }\n    const defaultPort = isSecure ? 443 : 80;\n    const key = randomBytes(16).toString(\"base64\");\n    const request = isSecure ? https.request : http.request;\n    const protocolSet = new Set();\n    let perMessageDeflate;\n    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);\n    opts.defaultPort = opts.defaultPort || defaultPort;\n    opts.port = parsedUrl.port || defaultPort;\n    opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n    opts.headers = {\n        ...opts.headers,\n        \"Sec-WebSocket-Version\": opts.protocolVersion,\n        \"Sec-WebSocket-Key\": key,\n        Connection: \"Upgrade\",\n        Upgrade: \"websocket\"\n    };\n    opts.path = parsedUrl.pathname + parsedUrl.search;\n    opts.timeout = opts.handshakeTimeout;\n    if (opts.perMessageDeflate) {\n        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n        opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n            [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n        });\n    }\n    if (protocols.length) {\n        for (const protocol of protocols){\n            if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n                throw new SyntaxError(\"An invalid or duplicated subprotocol was specified\");\n            }\n            protocolSet.add(protocol);\n        }\n        opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n    }\n    if (opts.origin) {\n        if (opts.protocolVersion < 13) {\n            opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n        } else {\n            opts.headers.Origin = opts.origin;\n        }\n    }\n    if (parsedUrl.username || parsedUrl.password) {\n        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n    }\n    if (isIpcUrl) {\n        const parts = opts.path.split(\":\");\n        opts.socketPath = parts[0];\n        opts.path = parts[1];\n    }\n    let req;\n    if (opts.followRedirects) {\n        if (websocket._redirects === 0) {\n            websocket._originalIpc = isIpcUrl;\n            websocket._originalSecure = isSecure;\n            websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n            const headers = options && options.headers;\n            //\n            // Shallow copy the user provided options so that headers can be changed\n            // without mutating the original object.\n            //\n            options = {\n                ...options,\n                headers: {}\n            };\n            if (headers) {\n                for (const [key, value] of Object.entries(headers)){\n                    options.headers[key.toLowerCase()] = value;\n                }\n            }\n        } else if (websocket.listenerCount(\"redirect\") === 0) {\n            const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n            if (!isSameHost || websocket._originalSecure && !isSecure) {\n                //\n                // Match curl 7.77.0 behavior and drop the following headers. These\n                // headers are also dropped when following a redirect to a subdomain.\n                //\n                delete opts.headers.authorization;\n                delete opts.headers.cookie;\n                if (!isSameHost) delete opts.headers.host;\n                opts.auth = undefined;\n            }\n        }\n        //\n        // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n        // If the `Authorization` header is set, then there is nothing to do as it\n        // will take precedence.\n        //\n        if (opts.auth && !options.headers.authorization) {\n            options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n        }\n        req = websocket._req = request(opts);\n        if (websocket._redirects) {\n            //\n            // Unlike what is done for the `'upgrade'` event, no early exit is\n            // triggered here if the user calls `websocket.close()` or\n            // `websocket.terminate()` from a listener of the `'redirect'` event. This\n            // is because the user can also call `request.destroy()` with an error\n            // before calling `websocket.close()` or `websocket.terminate()` and this\n            // would result in an error being emitted on the `request` object with no\n            // `'error'` event listeners attached.\n            //\n            websocket.emit(\"redirect\", websocket.url, req);\n        }\n    } else {\n        req = websocket._req = request(opts);\n    }\n    if (opts.timeout) {\n        req.on(\"timeout\", ()=>{\n            abortHandshake(websocket, req, \"Opening handshake has timed out\");\n        });\n    }\n    req.on(\"error\", (err)=>{\n        if (req === null || req[kAborted]) return;\n        req = websocket._req = null;\n        emitErrorAndClose(websocket, err);\n    });\n    req.on(\"response\", (res)=>{\n        const location = res.headers.location;\n        const statusCode = res.statusCode;\n        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n            if (++websocket._redirects > opts.maxRedirects) {\n                abortHandshake(websocket, req, \"Maximum redirects exceeded\");\n                return;\n            }\n            req.abort();\n            let addr;\n            try {\n                addr = new URL(location, address);\n            } catch (e) {\n                const err = new SyntaxError(`Invalid URL: ${location}`);\n                emitErrorAndClose(websocket, err);\n                return;\n            }\n            initAsClient(websocket, addr, protocols, options);\n        } else if (!websocket.emit(\"unexpected-response\", req, res)) {\n            abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n        }\n    });\n    req.on(\"upgrade\", (res, socket, head)=>{\n        websocket.emit(\"upgrade\", res);\n        //\n        // The user may have closed the connection from a listener of the\n        // `'upgrade'` event.\n        //\n        if (websocket.readyState !== WebSocket.CONNECTING) return;\n        req = websocket._req = null;\n        const upgrade = res.headers.upgrade;\n        if (upgrade === undefined || upgrade.toLowerCase() !== \"websocket\") {\n            abortHandshake(websocket, socket, \"Invalid Upgrade header\");\n            return;\n        }\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        if (res.headers[\"sec-websocket-accept\"] !== digest) {\n            abortHandshake(websocket, socket, \"Invalid Sec-WebSocket-Accept header\");\n            return;\n        }\n        const serverProt = res.headers[\"sec-websocket-protocol\"];\n        let protError;\n        if (serverProt !== undefined) {\n            if (!protocolSet.size) {\n                protError = \"Server sent a subprotocol but none was requested\";\n            } else if (!protocolSet.has(serverProt)) {\n                protError = \"Server sent an invalid subprotocol\";\n            }\n        } else if (protocolSet.size) {\n            protError = \"Server sent no subprotocol\";\n        }\n        if (protError) {\n            abortHandshake(websocket, socket, protError);\n            return;\n        }\n        if (serverProt) websocket._protocol = serverProt;\n        const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n        if (secWebSocketExtensions !== undefined) {\n            if (!perMessageDeflate) {\n                const message = \"Server sent a Sec-WebSocket-Extensions header but no extension \" + \"was requested\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            let extensions;\n            try {\n                extensions = parse(secWebSocketExtensions);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Extensions header\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            const extensionNames = Object.keys(extensions);\n            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n                const message = \"Server indicated an extension that was not requested\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            try {\n                perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Extensions header\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n        websocket.setSocket(socket, head, {\n            allowSynchronousEvents: opts.allowSynchronousEvents,\n            generateMask: opts.generateMask,\n            maxPayload: opts.maxPayload,\n            skipUTF8Validation: opts.skipUTF8Validation\n        });\n    });\n    if (opts.finishRequest) {\n        opts.finishRequest(req, websocket);\n    } else {\n        req.end();\n    }\n}\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */ function emitErrorAndClose(websocket, err) {\n    websocket._readyState = WebSocket.CLOSING;\n    websocket.emit(\"error\", err);\n    websocket.emitClose();\n}\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */ function netConnect(options) {\n    options.path = options.socketPath;\n    return net.connect(options);\n}\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */ function tlsConnect(options) {\n    options.path = undefined;\n    if (!options.servername && options.servername !== \"\") {\n        options.servername = net.isIP(options.host) ? \"\" : options.host;\n    }\n    return tls.connect(options);\n}\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */ function abortHandshake(websocket, stream, message) {\n    websocket._readyState = WebSocket.CLOSING;\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshake);\n    if (stream.setHeader) {\n        stream[kAborted] = true;\n        stream.abort();\n        if (stream.socket && !stream.socket.destroyed) {\n            //\n            // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n            // called after the request completed. See\n            // https://github.com/websockets/ws/issues/1869.\n            //\n            stream.socket.destroy();\n        }\n        process.nextTick(emitErrorAndClose, websocket, err);\n    } else {\n        stream.destroy(err);\n        stream.once(\"error\", websocket.emit.bind(websocket, \"error\"));\n        stream.once(\"close\", websocket.emitClose.bind(websocket));\n    }\n}\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */ function sendAfterClose(websocket, data, cb) {\n    if (data) {\n        const length = toBuffer(data).length;\n        //\n        // The `_bufferedAmount` property is used only when the peer is a client and\n        // the opening handshake fails. Under these circumstances, in fact, the\n        // `setSocket()` method is not called, so the `_socket` and `_sender`\n        // properties are set to `null`.\n        //\n        if (websocket._socket) websocket._sender._bufferedBytes += length;\n        else websocket._bufferedAmount += length;\n    }\n    if (cb) {\n        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n        process.nextTick(cb, err);\n    }\n}\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */ function receiverOnConclude(code, reason) {\n    const websocket = this[kWebSocket];\n    websocket._closeFrameReceived = true;\n    websocket._closeMessage = reason;\n    websocket._closeCode = code;\n    if (websocket._socket[kWebSocket] === undefined) return;\n    websocket._socket.removeListener(\"data\", socketOnData);\n    process.nextTick(resume, websocket._socket);\n    if (code === 1005) websocket.close();\n    else websocket.close(code, reason);\n}\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */ function receiverOnDrain() {\n    const websocket = this[kWebSocket];\n    if (!websocket.isPaused) websocket._socket.resume();\n}\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */ function receiverOnError(err) {\n    const websocket = this[kWebSocket];\n    if (websocket._socket[kWebSocket] !== undefined) {\n        websocket._socket.removeListener(\"data\", socketOnData);\n        //\n        // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n        // https://github.com/websockets/ws/issues/1940.\n        //\n        process.nextTick(resume, websocket._socket);\n        websocket.close(err[kStatusCode]);\n    }\n    websocket.emit(\"error\", err);\n}\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */ function receiverOnFinish() {\n    this[kWebSocket].emitClose();\n}\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */ function receiverOnMessage(data, isBinary) {\n    this[kWebSocket].emit(\"message\", data, isBinary);\n}\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */ function receiverOnPing(data) {\n    const websocket = this[kWebSocket];\n    if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n    websocket.emit(\"ping\", data);\n}\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */ function receiverOnPong(data) {\n    this[kWebSocket].emit(\"pong\", data);\n}\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */ function resume(stream) {\n    stream.resume();\n}\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */ function socketOnClose() {\n    const websocket = this[kWebSocket];\n    this.removeListener(\"close\", socketOnClose);\n    this.removeListener(\"data\", socketOnData);\n    this.removeListener(\"end\", socketOnEnd);\n    websocket._readyState = WebSocket.CLOSING;\n    let chunk;\n    //\n    // The close frame might not have been received or the `'end'` event emitted,\n    // for example, if the socket was destroyed due to an error. Ensure that the\n    // `receiver` stream is closed after writing any remaining buffered data to\n    // it. If the readable side of the socket is in flowing mode then there is no\n    // buffered data as everything has been already written and `readable.read()`\n    // will return `null`. If instead, the socket is paused, any possible buffered\n    // data will be read as a single chunk.\n    //\n    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n        websocket._receiver.write(chunk);\n    }\n    websocket._receiver.end();\n    this[kWebSocket] = undefined;\n    clearTimeout(websocket._closeTimer);\n    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n        websocket.emitClose();\n    } else {\n        websocket._receiver.on(\"error\", receiverOnFinish);\n        websocket._receiver.on(\"finish\", receiverOnFinish);\n    }\n}\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function socketOnData(chunk) {\n    if (!this[kWebSocket]._receiver.write(chunk)) {\n        this.pause();\n    }\n}\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */ function socketOnEnd() {\n    const websocket = this[kWebSocket];\n    websocket._readyState = WebSocket.CLOSING;\n    websocket._receiver.end();\n    this.end();\n}\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */ function socketOnError() {\n    const websocket = this[kWebSocket];\n    this.removeListener(\"error\", socketOnError);\n    this.on(\"error\", NOOP);\n    if (websocket) {\n        websocket._readyState = WebSocket.CLOSING;\n        this.destroy();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQUEsMEdBQTBHLEdBRTFHO0FBRUEsTUFBTUEsZUFBZUMsbUJBQU9BLENBQUM7QUFDN0IsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDdEIsTUFBTUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDckIsTUFBTUcsTUFBTUgsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUksTUFBTUosbUJBQU9BLENBQUM7QUFDcEIsTUFBTSxFQUFFSyxXQUFXLEVBQUVDLFVBQVUsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUM1QyxNQUFNLEVBQUVPLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBQ3JDLE1BQU0sRUFBRVMsR0FBRyxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBRXhCLE1BQU1VLG9CQUFvQlYsbUJBQU9BLENBQUM7QUFDbEMsTUFBTVcsV0FBV1gsbUJBQU9BLENBQUM7QUFDekIsTUFBTVksU0FBU1osbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUNKYSxZQUFZLEVBQ1pDLFlBQVksRUFDWkMsSUFBSSxFQUNKQyxvQkFBb0IsRUFDcEJDLFNBQVMsRUFDVEMsV0FBVyxFQUNYQyxVQUFVLEVBQ1ZDLElBQUksRUFDTCxHQUFHcEIsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQ0pxQixhQUFhLEVBQUVDLGdCQUFnQixFQUFFQyxtQkFBbUIsRUFBRSxFQUN2RCxHQUFHdkIsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUV3QixNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHekIsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFMEIsUUFBUSxFQUFFLEdBQUcxQixtQkFBT0EsQ0FBQztBQUU3QixNQUFNMkIsZUFBZSxLQUFLO0FBQzFCLE1BQU1DLFdBQVdDLE9BQU87QUFDeEIsTUFBTUMsbUJBQW1CO0lBQUM7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QUN4SSxXQUFXO0lBRWxDLElBQUksQ0FBQ3FJLGNBQWMsQ0FBQyxTQUFTakQ7SUFDN0IsSUFBSSxDQUFDYixFQUFFLENBQUMsU0FBU3RFO0lBRWpCLElBQUl1SSxXQUFXO1FBQ2JBLFVBQVU1RyxXQUFXLEdBQUdkLFVBQVVvRixPQUFPO1FBQ3pDLElBQUksQ0FBQ0ksT0FBTztJQUNkO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanM/OTQwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5EdXBsZXh8UmVhZGFibGUkXCIsIFwiY2F1Z2h0RXJyb3JzXCI6IFwibm9uZVwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgcmFuZG9tQnl0ZXMsIGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBEdXBsZXgsIFJlYWRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyJyk7XG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5jb25zdCBrQWJvcnRlZCA9IFN5bWJvbCgna0Fib3J0ZWQnKTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAocHJvdG9jb2xzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdvYmplY3QnICYmIHByb3RvY29scyAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2F1dG9Qb25nID0gb3B0aW9ucy5hdXRvUG9uZztcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBkZXZpYXRlcyBmcm9tIHRoZSBXSEFUV0cgaW50ZXJmYWNlIHNpbmNlIHdzIGRvZXNuJ3Qgc3VwcG9ydCB0aGVcbiAgICogcmVxdWlyZWQgZGVmYXVsdCBcImJsb2JcIiB0eXBlIChpbnN0ZWFkIHdlIGRlZmluZSBhIGN1c3RvbSBcIm5vZGVidWZmZXJcIlxuICAgKiB0eXBlKS5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKSByZXR1cm47XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcblxuICAgIC8vXG4gICAgLy8gQWxsb3cgdG8gY2hhbmdlIGBiaW5hcnlUeXBlYCBvbiB0aGUgZmx5LlxuICAgIC8vXG4gICAgaWYgKHRoaXMuX3JlY2VpdmVyKSB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkQW1vdW50O1xuXG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5sZW5ndGggKyB0aGlzLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBleHRlbnNpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25jbG9zZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25lcnJvcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25vcGVuKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKHtcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIGJpbmFyeVR5cGU6IHRoaXMuYmluYXJ5VHlwZSxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuX2V4dGVuc2lvbnMsXG4gICAgICBpc1NlcnZlcjogdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBtYXhQYXlsb2FkOiBvcHRpb25zLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZW5kZXIgPSBuZXcgU2VuZGVyKHNvY2tldCwgdGhpcy5fZXh0ZW5zaW9ucywgb3B0aW9ucy5nZW5lcmF0ZU1hc2spO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIC8vXG4gICAgLy8gVGhlc2UgbWV0aG9kcyBtYXkgbm90IGJlIGF2YWlsYWJsZSBpZiBgc29ja2V0YCBpcyBqdXN0IGEgYER1cGxleGAuXG4gICAgLy9cbiAgICBpZiAoc29ja2V0LnNldFRpbWVvdXQpIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIGlmIChzb2NrZXQuc2V0Tm9EZWxheSkgc29ja2V0LnNldE5vRGVsYXkoKTtcblxuICAgIGlmIChoZWFkLmxlbmd0aCA+IDApIHNvY2tldC51bnNoaWZ0KGhlYWQpO1xuXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICAgIHNvY2tldC5vbignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gICAgc29ja2V0Lm9uKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgdGhlIGAnY2xvc2UnYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRDbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgY2xvc2luZyBoYW5kc2hha2UuXG4gICAqXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLStcbiAgICogICAgIC0gLSAtfHdzLmNsb3NlKCl8LS0+fGNsb3NlIGZyYW1lfC0tPnx3cy5jbG9zZSgpfC0gLSAtXG4gICAqICAgIHwgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLSsgICAgIHxcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcbiAgICogQ0xPU0lORyAgfHdzLmNsb3NlKCl8PC0tfGNsb3NlIGZyYW1lfDwtLSstLS0tLSsgICAgICAgQ0xPU0lOR1xuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgfFxuICAgKiAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0+fGZpbnwgLSAtIC0gLVxuICAgKiAgICB8ICAgICAgICAgKy0tLSsgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rXG4gICAqICAgICAtIC0gLSAtIC18ZmlufDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAqICAgICAgICAgICAgICArLS0tK1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgcmVhc29uIHdoeSB0aGUgY29ubmVjdGlvbiBpc1xuICAgKiAgICAgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgJiZcbiAgICAgICAgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fCB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuX3NlbmRlci5jbG9zZShjb2RlLCBkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIChlcnIpID0+IHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgYnkgdGhlIGAnZXJyb3InYCBsaXN0ZW5lciBvbiB0aGUgc29ja2V0LiBXZSBvbmx5XG4gICAgICAvLyB3YW50IHRvIGtub3cgaWYgdGhlIGNsb3NlIGZyYW1lIGhhcyBiZWVuIHNlbnQgaGVyZS5cbiAgICAgIC8vXG4gICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHxcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy9cbiAgICAvLyBTcGVjaWZ5IGEgdGltZW91dCBmb3IgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIHRvIGNvbXBsZXRlLlxuICAgIC8vXG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveS5iaW5kKHRoaXMuX3NvY2tldCksXG4gICAgICBjbG9zZVRpbWVvdXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fc29ja2V0LnBhdXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSB0aGlzLl9zb2NrZXQucmVzdW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxuICAgKiAgICAgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj10cnVlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gZGF0YSBpcyB3cml0dGVuIG91dFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxuICAgICAgbWFzazogIXRoaXMuX2lzU2VydmVyLFxuICAgICAgY29tcHJlc3M6IHRydWUsXG4gICAgICBmaW46IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuW1xuICAnYmluYXJ5VHlwZScsXG4gICdidWZmZXJlZEFtb3VudCcsXG4gICdleHRlbnNpb25zJyxcbiAgJ2lzUGF1c2VkJyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3JlYWR5U3RhdGUnLFxuICAndXJsJ1xuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHJldHVybiBsaXN0ZW5lcltrTGlzdGVuZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGhhbmRsZXIsIHtcbiAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgYW55XG4gKiAgICAgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBtdWx0aXBsZVxuICogICAgIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b1Bvbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gKiAgICAgYXV0b21hdGljYWxseSBzZW5kIGEgcG9uZyBpbiByZXNwb25zZSB0byBhIHBpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmZpbmlzaFJlcXVlc3RdIEEgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAqICAgICBjdXN0b21pemUgdGhlIGhlYWRlcnMgb2YgZWFjaCBodHRwIHJlcXVlc3QgYmVmb3JlIGl0IGlzIHNlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9sbG93UmVkaXJlY3RzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBmb2xsb3dcbiAqICAgICByZWRpcmVjdHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gKiAgICAgbWFza2luZyBrZXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oYW5kc2hha2VUaW1lb3V0XSBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlXG4gKiAgICAgaGFuZHNoYWtlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gKiAgICAgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFJlZGlyZWN0cz0xMF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlZGlyZWN0c1xuICogICAgIGFsbG93ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5vcmlnaW5dIFZhbHVlIG9mIHRoZSBgT3JpZ2luYCBvclxuICogICAgIGBTZWMtV2ViU29ja2V0LU9yaWdpbmAgaGVhZGVyXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPXRydWVdIEVuYWJsZS9kaXNhYmxlXG4gKiAgICAgcGVybWVzc2FnZS1kZWZsYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJvdG9jb2xWZXJzaW9uPTEzXSBWYWx1ZSBvZiB0aGVcbiAqICAgICBgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCBoZWFkZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxuICAgIGF1dG9Qb25nOiB0cnVlLFxuICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcbiAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgaG9zdDogdW5kZWZpbmVkLFxuICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICBwb3J0OiB1bmRlZmluZWRcbiAgfTtcblxuICB3ZWJzb2NrZXQuX2F1dG9Qb25nID0gb3B0cy5hdXRvUG9uZztcblxuICBpZiAoIXByb3RvY29sVmVyc2lvbnMuaW5jbHVkZXMob3B0cy5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRzLnByb3RvY29sVmVyc2lvbn0gYCArXG4gICAgICAgIGAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbignLCAnKX0pYFxuICAgICk7XG4gIH1cblxuICBsZXQgcGFyc2VkVXJsO1xuXG4gIGlmIChhZGRyZXNzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcGFyc2VkVXJsID0gYWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9ICd3czonO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3NzOic7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3VybCA9IHBhcnNlZFVybC5ocmVmO1xuXG4gIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG4gIGNvbnN0IGlzSXBjVXJsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuICBsZXQgaW52YWxpZFVybE1lc3NhZ2U7XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID1cbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgJyArXG4gICAgICAnXCJodHRwOlwiLCBcImh0dHBzXCIsIG9yIFwid3MrdW5peDpcIic7XG4gIH0gZWxzZSBpZiAoaXNJcGNVcmwgJiYgIXBhcnNlZFVybC5wYXRobmFtZSkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gXCJUaGUgVVJMJ3MgcGF0aG5hbWUgaXMgZW1wdHlcIjtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJztcbiAgfVxuXG4gIGlmIChpbnZhbGlkVXJsTWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihpbnZhbGlkVXJsTWVzc2FnZSk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgcmVxdWVzdCA9IGlzU2VjdXJlID8gaHR0cHMucmVxdWVzdCA6IGh0dHAucmVxdWVzdDtcbiAgY29uc3QgcHJvdG9jb2xTZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBwZXJNZXNzYWdlRGVmbGF0ZTtcblxuICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gPVxuICAgIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiB8fCAoaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdCk7XG4gIG9wdHMuZGVmYXVsdFBvcnQgPSBvcHRzLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLnBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuICAgID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgIDogcGFyc2VkVXJsLmhvc3RuYW1lO1xuICBvcHRzLmhlYWRlcnMgPSB7XG4gICAgLi4ub3B0cy5oZWFkZXJzLFxuICAgICdTZWMtV2ViU29ja2V0LVZlcnNpb24nOiBvcHRzLnByb3RvY29sVmVyc2lvbixcbiAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXG4gICAgQ29ubmVjdGlvbjogJ1VwZ3JhZGUnLFxuICAgIFVwZ3JhZGU6ICd3ZWJzb2NrZXQnXG4gIH07XG4gIG9wdHMucGF0aCA9IHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIG9wdHMudGltZW91dCA9IG9wdHMuaGFuZHNoYWtlVGltZW91dDtcblxuICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0cy5tYXhQYXlsb2FkXG4gICAgKTtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyddID0gZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogcGVyTWVzc2FnZURlZmxhdGUub2ZmZXIoKVxuICAgIH0pO1xuICB9XG4gIGlmIChwcm90b2NvbHMubGVuZ3RoKSB7XG4gICAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIHByb3RvY29sICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhc3VicHJvdG9jb2xSZWdleC50ZXN0KHByb3RvY29sKSB8fFxuICAgICAgICBwcm90b2NvbFNldC5oYXMocHJvdG9jb2wpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgICdBbiBpbnZhbGlkIG9yIGR1cGxpY2F0ZWQgc3VicHJvdG9jb2wgd2FzIHNwZWNpZmllZCdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcHJvdG9jb2xTZXQuYWRkKHByb3RvY29sKTtcbiAgICB9XG5cbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHByb3RvY29scy5qb2luKCcsJyk7XG4gIH1cbiAgaWYgKG9wdHMub3JpZ2luKSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2xWZXJzaW9uIDwgMTMpIHtcbiAgICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IG9wdHMub3JpZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLmhlYWRlcnMuT3JpZ2luID0gb3B0cy5vcmlnaW47XG4gICAgfVxuICB9XG4gIGlmIChwYXJzZWRVcmwudXNlcm5hbWUgfHwgcGFyc2VkVXJsLnBhc3N3b3JkKSB7XG4gICAgb3B0cy5hdXRoID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xuICB9XG5cbiAgaWYgKGlzSXBjVXJsKSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgbGV0IHJlcTtcblxuICBpZiAob3B0cy5mb2xsb3dSZWRpcmVjdHMpIHtcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxJcGMgPSBpc0lwY1VybDtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgPSBpc1NlY3VyZTtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoID0gaXNJcGNVcmxcbiAgICAgICAgPyBvcHRzLnNvY2tldFBhdGhcbiAgICAgICAgOiBwYXJzZWRVcmwuaG9zdDtcblxuICAgICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWFkZXJzO1xuXG4gICAgICAvL1xuICAgICAgLy8gU2hhbGxvdyBjb3B5IHRoZSB1c2VyIHByb3ZpZGVkIG9wdGlvbnMgc28gdGhhdCBoZWFkZXJzIGNhbiBiZSBjaGFuZ2VkXG4gICAgICAvLyB3aXRob3V0IG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAvL1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgaGVhZGVyczoge30gfTtcblxuICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdlYnNvY2tldC5saXN0ZW5lckNvdW50KCdyZWRpcmVjdCcpID09PSAwKSB7XG4gICAgICBjb25zdCBpc1NhbWVIb3N0ID0gaXNJcGNVcmxcbiAgICAgICAgPyB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXG4gICAgICAgICAgPyBvcHRzLnNvY2tldFBhdGggPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoXG4gICAgICAgICAgOiBmYWxzZVxuICAgICAgICA6IHdlYnNvY2tldC5fb3JpZ2luYWxJcGNcbiAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgOiBwYXJzZWRVcmwuaG9zdCA9PT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGg7XG5cbiAgICAgIGlmICghaXNTYW1lSG9zdCB8fCAod2Vic29ja2V0Ll9vcmlnaW5hbFNlY3VyZSAmJiAhaXNTZWN1cmUpKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBkcm9wIHRoZSBmb2xsb3dpbmcgaGVhZGVycy4gVGhlc2VcbiAgICAgICAgLy8gaGVhZGVycyBhcmUgYWxzbyBkcm9wcGVkIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgdG8gYSBzdWJkb21haW4uXG4gICAgICAgIC8vXG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5jb29raWU7XG5cbiAgICAgICAgaWYgKCFpc1NhbWVIb3N0KSBkZWxldGUgb3B0cy5oZWFkZXJzLmhvc3Q7XG5cbiAgICAgICAgb3B0cy5hdXRoID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTWF0Y2ggY3VybCA3Ljc3LjAgYmVoYXZpb3IgYW5kIG1ha2UgdGhlIGZpcnN0IGBBdXRob3JpemF0aW9uYCBoZWFkZXIgd2luLlxuICAgIC8vIElmIHRoZSBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlzIHNldCwgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvIGFzIGl0XG4gICAgLy8gd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gICAgLy9cbiAgICBpZiAob3B0cy5hdXRoICYmICFvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPVxuICAgICAgICAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcblxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cykge1xuICAgICAgLy9cbiAgICAgIC8vIFVubGlrZSB3aGF0IGlzIGRvbmUgZm9yIHRoZSBgJ3VwZ3JhZGUnYCBldmVudCwgbm8gZWFybHkgZXhpdCBpc1xuICAgICAgLy8gdHJpZ2dlcmVkIGhlcmUgaWYgdGhlIHVzZXIgY2FsbHMgYHdlYnNvY2tldC5jbG9zZSgpYCBvclxuICAgICAgLy8gYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgJ3JlZGlyZWN0J2AgZXZlbnQuIFRoaXNcbiAgICAgIC8vIGlzIGJlY2F1c2UgdGhlIHVzZXIgY2FuIGFsc28gY2FsbCBgcmVxdWVzdC5kZXN0cm95KClgIHdpdGggYW4gZXJyb3JcbiAgICAgIC8vIGJlZm9yZSBjYWxsaW5nIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3IgYHdlYnNvY2tldC50ZXJtaW5hdGUoKWAgYW5kIHRoaXNcbiAgICAgIC8vIHdvdWxkIHJlc3VsdCBpbiBhbiBlcnJvciBiZWluZyBlbWl0dGVkIG9uIHRoZSBgcmVxdWVzdGAgb2JqZWN0IHdpdGggbm9cbiAgICAgIC8vIGAnZXJyb3InYCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQuXG4gICAgICAvL1xuICAgICAgd2Vic29ja2V0LmVtaXQoJ3JlZGlyZWN0Jywgd2Vic29ja2V0LnVybCwgcmVxKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSByZXF1ZXN0KG9wdHMpO1xuICB9XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcVtrQWJvcnRlZF0pIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcbiAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgbGV0IGFkZHI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHtsb2NhdGlvbn1gKTtcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0LmVtaXQoJ3VuZXhwZWN0ZWQtcmVzcG9uc2UnLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlXG4gICAgLy8gYCd1cGdyYWRlJ2AgZXZlbnQuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG5cbiAgICBjb25zdCB1cGdyYWRlID0gcmVzLmhlYWRlcnMudXBncmFkZTtcblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RFcnJvcjtcblxuICAgIGlmIChzZXJ2ZXJQcm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcbiAgICAgIH0gZWxzZSBpZiAoIXByb3RvY29sU2V0LmhhcyhzZXJ2ZXJQcm90KSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xuICAgIH1cblxuICAgIGlmIChwcm90RXJyb3IpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBwcm90RXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJQcm90KSB3ZWJzb2NrZXQuX3Byb3RvY29sID0gc2VydmVyUHJvdDtcblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdTZXJ2ZXIgc2VudCBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgYnV0IG5vIGV4dGVuc2lvbiAnICtcbiAgICAgICAgICAnd2FzIHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXh0ZW5zaW9ucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWVzID0gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgIGV4dGVuc2lvbk5hbWVzWzBdICE9PSBQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdTZXJ2ZXIgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiB0aGF0IHdhcyBub3QgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3ZWJzb2NrZXQuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPVxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogb3B0cy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzLFxuICAgICAgZ2VuZXJhdGVNYXNrOiBvcHRzLmdlbmVyYXRlTWFzayxcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKG9wdHMuZmluaXNoUmVxdWVzdCkge1xuICAgIG9wdHMuZmluaXNoUmVxdWVzdChyZXEsIHdlYnNvY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgcmVxLmVuZCgpO1xuICB9XG59XG5cbi8qKlxuICogRW1pdCB0aGUgYCdlcnJvcidgIGFuZCBgJ2Nsb3NlJ2AgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gVGhlIGVycm9yIHRvIGVtaXRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyAnJyA6IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xuICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW1ba0Fib3J0ZWRdID0gdHJ1ZTtcbiAgICBzdHJlYW0uYWJvcnQoKTtcblxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgLy9cbiAgICAgIC8vIE9uIE5vZGUuanMgPj0gMTQuMy4wIGByZXF1ZXN0LmFib3J0KClgIGRvZXMgbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBpZlxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cbiAgICAgIC8vXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlLCB3ZWJzb2NrZXQsIGVycik7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKTtcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCB3ZWJzb2NrZXQuZW1pdC5iaW5kKHdlYnNvY2tldCwgJ2Vycm9yJykpO1xuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBjYXNlcyB3aGVyZSB0aGUgYHBpbmcoKWAsIGBwb25nKClgLCBvciBgc2VuZCgpYCBtZXRob2RzIGFyZSBjYWxsZWRcbiAqIHdoZW4gdGhlIGByZWFkeVN0YXRlYCBhdHRyaWJ1dGUgaXMgYENMT1NJTkdgIG9yIGBDTE9TRURgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZEFmdGVyQ2xvc2Uod2Vic29ja2V0LCBkYXRhLCBjYikge1xuICBpZiAoZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRvQnVmZmVyKGRhdGEpLmxlbmd0aDtcblxuICAgIC8vXG4gICAgLy8gVGhlIGBfYnVmZmVyZWRBbW91bnRgIHByb3BlcnR5IGlzIHVzZWQgb25seSB3aGVuIHRoZSBwZWVyIGlzIGEgY2xpZW50IGFuZFxuICAgIC8vIHRoZSBvcGVuaW5nIGhhbmRzaGFrZSBmYWlscy4gVW5kZXIgdGhlc2UgY2lyY3Vtc3RhbmNlcywgaW4gZmFjdCwgdGhlXG4gICAgLy8gYHNldFNvY2tldCgpYCBtZXRob2QgaXMgbm90IGNhbGxlZCwgc28gdGhlIGBfc29ja2V0YCBhbmQgYF9zZW5kZXJgXG4gICAgLy8gcHJvcGVydGllcyBhcmUgc2V0IHRvIGBudWxsYC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQuX3NvY2tldCkgd2Vic29ja2V0Ll9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xuICAgIGVsc2Ugd2Vic29ja2V0Ll9idWZmZXJlZEFtb3VudCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAoY2IpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0LnJlYWR5U3RhdGV9IGAgK1xuICAgICAgICBgKCR7cmVhZHlTdGF0ZXNbd2Vic29ja2V0LnJlYWR5U3RhdGVdfSlgXG4gICAgKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnY29uY2x1ZGUnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSByZWFzb24gVGhlIHJlYXNvbiBmb3IgY2xvc2luZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkNvbmNsdWRlKGNvZGUsIHJlYXNvbikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0Ll9jbG9zZU1lc3NhZ2UgPSByZWFzb247XG4gIHdlYnNvY2tldC5fY2xvc2VDb2RlID0gY29kZTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuICBpZiAoY29kZSA9PT0gMTAwNSkgd2Vic29ja2V0LmNsb3NlKCk7XG4gIGVsc2Ugd2Vic29ja2V0LmNsb3NlKGNvZGUsIHJlYXNvbik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZHJhaW4nYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKCF3ZWJzb2NrZXQuaXNQYXVzZWQpIHdlYnNvY2tldC5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuXG4gICAgLy9cbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTk0MC5cbiAgICAvL1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgICB3ZWJzb2NrZXQuY2xvc2UoZXJyW2tTdGF0dXNDb2RlXSk7XG4gIH1cblxuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2ZpbmlzaCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnbWVzc2FnZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgbWVzc2FnZVxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSBTcGVjaWZpZXMgd2hldGhlciB0aGUgbWVzc2FnZSBpcyBiaW5hcnkgb3Igbm90XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCBpc0JpbmFyeSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncGluZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKHdlYnNvY2tldC5fYXV0b1BvbmcpIHdlYnNvY2tldC5wb25nKGRhdGEsICF0aGlzLl9pc1NlcnZlciwgTk9PUCk7XG4gIHdlYnNvY2tldC5lbWl0KCdwaW5nJywgZGF0YSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncG9uZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwb25nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUG9uZyhkYXRhKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgncG9uZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFJlc3VtZSBhIHJlYWRhYmxlIHN0cmVhbVxuICpcbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSBUaGUgcmVhZGFibGUgc3RyZWFtXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtKSB7XG4gIHN0cmVhbS5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgc29ja2V0T25FbmQpO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGxldCBjaHVuaztcblxuICAvL1xuICAvLyBUaGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGhhdmUgYmVlbiByZWNlaXZlZCBvciB0aGUgYCdlbmQnYCBldmVudCBlbWl0dGVkLFxuICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHNvY2tldCB3YXMgZGVzdHJveWVkIGR1ZSB0byBhbiBlcnJvci4gRW5zdXJlIHRoYXQgdGhlXG4gIC8vIGByZWNlaXZlcmAgc3RyZWFtIGlzIGNsb3NlZCBhZnRlciB3cml0aW5nIGFueSByZW1haW5pbmcgYnVmZmVyZWQgZGF0YSB0b1xuICAvLyBpdC4gSWYgdGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHNvY2tldCBpcyBpbiBmbG93aW5nIG1vZGUgdGhlbiB0aGVyZSBpcyBub1xuICAvLyBidWZmZXJlZCBkYXRhIGFzIGV2ZXJ5dGhpbmcgaGFzIGJlZW4gYWxyZWFkeSB3cml0dGVuIGFuZCBgcmVhZGFibGUucmVhZCgpYFxuICAvLyB3aWxsIHJldHVybiBgbnVsbGAuIElmIGluc3RlYWQsIHRoZSBzb2NrZXQgaXMgcGF1c2VkLCBhbnkgcG9zc2libGUgYnVmZmVyZWRcbiAgLy8gZGF0YSB3aWxsIGJlIHJlYWQgYXMgYSBzaW5nbGUgY2h1bmsuXG4gIC8vXG4gIGlmIChcbiAgICAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkICYmXG4gICAgIXdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmXG4gICAgIXdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkICYmXG4gICAgKGNodW5rID0gd2Vic29ja2V0Ll9zb2NrZXQucmVhZCgpKSAhPT0gbnVsbFxuICApIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLndyaXRlKGNodW5rKTtcbiAgfVxuXG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG5cbiAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICBjbGVhclRpbWVvdXQod2Vic29ja2V0Ll9jbG9zZVRpbWVyKTtcblxuICBpZiAoXG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCB8fFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICkge1xuICAgIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25GaW5pc2gpO1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2ZpbmlzaCcsIHJlY2VpdmVyT25GaW5pc2gpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25EYXRhKGNodW5rKSB7XG4gIGlmICghdGhpc1trV2ViU29ja2V0XS5fcmVjZWl2ZXIud3JpdGUoY2h1bmspKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVuZCgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcbiAgdGhpcy5lbmQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FcnJvcigpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICB0aGlzLm9uKCdlcnJvcicsIE5PT1ApO1xuXG4gIGlmICh3ZWJzb2NrZXQpIHtcbiAgICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsInJlcXVpcmUiLCJodHRwcyIsImh0dHAiLCJuZXQiLCJ0bHMiLCJyYW5kb21CeXRlcyIsImNyZWF0ZUhhc2giLCJEdXBsZXgiLCJSZWFkYWJsZSIsIlVSTCIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiUmVjZWl2ZXIiLCJTZW5kZXIiLCJCSU5BUllfVFlQRVMiLCJFTVBUWV9CVUZGRVIiLCJHVUlEIiwia0Zvck9uRXZlbnRBdHRyaWJ1dGUiLCJrTGlzdGVuZXIiLCJrU3RhdHVzQ29kZSIsImtXZWJTb2NrZXQiLCJOT09QIiwiRXZlbnRUYXJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImZvcm1hdCIsInBhcnNlIiwidG9CdWZmZXIiLCJjbG9zZVRpbWVvdXQiLCJrQWJvcnRlZCIsIlN5bWJvbCIsInByb3RvY29sVmVyc2lvbnMiLCJyZWFkeVN0YXRlcyIsInN1YnByb3RvY29sUmVnZXgiLCJXZWJTb2NrZXQiLCJjb25zdHJ1Y3RvciIsImFkZHJlc3MiLCJwcm90b2NvbHMiLCJvcHRpb25zIiwiX2JpbmFyeVR5cGUiLCJfY2xvc2VDb2RlIiwiX2Nsb3NlRnJhbWVSZWNlaXZlZCIsIl9jbG9zZUZyYW1lU2VudCIsIl9jbG9zZU1lc3NhZ2UiLCJfY2xvc2VUaW1lciIsIl9leHRlbnNpb25zIiwiX3BhdXNlZCIsIl9wcm90b2NvbCIsIl9yZWFkeVN0YXRlIiwiQ09OTkVDVElORyIsIl9yZWNlaXZlciIsIl9zZW5kZXIiLCJfc29ja2V0IiwiX2J1ZmZlcmVkQW1vdW50IiwiX2lzU2VydmVyIiwiX3JlZGlyZWN0cyIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsImluaXRBc0NsaWVudCIsIl9hdXRvUG9uZyIsImF1dG9Qb25nIiwiYmluYXJ5VHlwZSIsInR5cGUiLCJpbmNsdWRlcyIsImJ1ZmZlcmVkQW1vdW50IiwiX3dyaXRhYmxlU3RhdGUiLCJsZW5ndGgiLCJfYnVmZmVyZWRCeXRlcyIsImV4dGVuc2lvbnMiLCJPYmplY3QiLCJrZXlzIiwiam9pbiIsImlzUGF1c2VkIiwib25jbG9zZSIsIm9uZXJyb3IiLCJvbm9wZW4iLCJvbm1lc3NhZ2UiLCJwcm90b2NvbCIsInJlYWR5U3RhdGUiLCJ1cmwiLCJfdXJsIiwic2V0U29ja2V0Iiwic29ja2V0IiwiaGVhZCIsInJlY2VpdmVyIiwiYWxsb3dTeW5jaHJvbm91c0V2ZW50cyIsImlzU2VydmVyIiwibWF4UGF5bG9hZCIsInNraXBVVEY4VmFsaWRhdGlvbiIsImdlbmVyYXRlTWFzayIsIm9uIiwicmVjZWl2ZXJPbkNvbmNsdWRlIiwicmVjZWl2ZXJPbkRyYWluIiwicmVjZWl2ZXJPbkVycm9yIiwicmVjZWl2ZXJPbk1lc3NhZ2UiLCJyZWNlaXZlck9uUGluZyIsInJlY2VpdmVyT25Qb25nIiwic2V0VGltZW91dCIsInNldE5vRGVsYXkiLCJ1bnNoaWZ0Iiwic29ja2V0T25DbG9zZSIsInNvY2tldE9uRGF0YSIsInNvY2tldE9uRW5kIiwic29ja2V0T25FcnJvciIsIk9QRU4iLCJlbWl0IiwiZW1pdENsb3NlIiwiQ0xPU0VEIiwiZXh0ZW5zaW9uTmFtZSIsImNsZWFudXAiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJjbG9zZSIsImNvZGUiLCJkYXRhIiwibXNnIiwiYWJvcnRIYW5kc2hha2UiLCJfcmVxIiwiQ0xPU0lORyIsImVycm9yRW1pdHRlZCIsImVuZCIsImVyciIsImRlc3Ryb3kiLCJiaW5kIiwicGF1c2UiLCJwaW5nIiwibWFzayIsImNiIiwiRXJyb3IiLCJ0b1N0cmluZyIsInNlbmRBZnRlckNsb3NlIiwicG9uZyIsInJlc3VtZSIsIm5lZWREcmFpbiIsInNlbmQiLCJvcHRzIiwiYmluYXJ5IiwiY29tcHJlc3MiLCJmaW4iLCJ0ZXJtaW5hdGUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsImluZGV4T2YiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwicHJvcGVydHkiLCJtZXRob2QiLCJnZXQiLCJsaXN0ZW5lciIsImxpc3RlbmVycyIsInNldCIsImhhbmRsZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ3ZWJzb2NrZXQiLCJwcm90b2NvbFZlcnNpb24iLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImZvbGxvd1JlZGlyZWN0cyIsIm1heFJlZGlyZWN0cyIsInNvY2tldFBhdGgiLCJob3N0bmFtZSIsInRpbWVvdXQiLCJob3N0IiwicGF0aCIsInBvcnQiLCJSYW5nZUVycm9yIiwicGFyc2VkVXJsIiwiZSIsIlN5bnRheEVycm9yIiwiaHJlZiIsImlzU2VjdXJlIiwiaXNJcGNVcmwiLCJpbnZhbGlkVXJsTWVzc2FnZSIsInBhdGhuYW1lIiwiaGFzaCIsImVtaXRFcnJvckFuZENsb3NlIiwiZGVmYXVsdFBvcnQiLCJrZXkiLCJyZXF1ZXN0IiwicHJvdG9jb2xTZXQiLCJTZXQiLCJjcmVhdGVDb25uZWN0aW9uIiwidGxzQ29ubmVjdCIsIm5ldENvbm5lY3QiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJoZWFkZXJzIiwiQ29ubmVjdGlvbiIsIlVwZ3JhZGUiLCJzZWFyY2giLCJoYW5kc2hha2VUaW1lb3V0Iiwib2ZmZXIiLCJ0ZXN0IiwiaGFzIiwiYWRkIiwib3JpZ2luIiwiT3JpZ2luIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImF1dGgiLCJwYXJ0cyIsInNwbGl0IiwicmVxIiwiX29yaWdpbmFsSXBjIiwiX29yaWdpbmFsU2VjdXJlIiwiX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aCIsImVudHJpZXMiLCJ0b0xvd2VyQ2FzZSIsImxpc3RlbmVyQ291bnQiLCJpc1NhbWVIb3N0IiwiYXV0aG9yaXphdGlvbiIsImNvb2tpZSIsIkJ1ZmZlciIsImZyb20iLCJyZXMiLCJsb2NhdGlvbiIsInN0YXR1c0NvZGUiLCJhYm9ydCIsImFkZHIiLCJ1cGdyYWRlIiwiZGlnZXN0IiwidXBkYXRlIiwic2VydmVyUHJvdCIsInByb3RFcnJvciIsInNpemUiLCJzZWNXZWJTb2NrZXRFeHRlbnNpb25zIiwibWVzc2FnZSIsImV4dGVuc2lvbk5hbWVzIiwiYWNjZXB0IiwiZmluaXNoUmVxdWVzdCIsImNvbm5lY3QiLCJzZXJ2ZXJuYW1lIiwiaXNJUCIsInN0cmVhbSIsImNhcHR1cmVTdGFja1RyYWNlIiwic2V0SGVhZGVyIiwiZGVzdHJveWVkIiwicHJvY2VzcyIsIm5leHRUaWNrIiwib25jZSIsInJlYXNvbiIsInJlY2VpdmVyT25GaW5pc2giLCJpc0JpbmFyeSIsImNodW5rIiwiX3JlYWRhYmxlU3RhdGUiLCJlbmRFbWl0dGVkIiwicmVhZCIsIndyaXRlIiwiY2xlYXJUaW1lb3V0IiwiZmluaXNoZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/contrib/has-cors.js":
/*!****************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/contrib/has-cors.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasCORS: () => (/* binding */ hasCORS)\n/* harmony export */ });\n// imported from https://github.com/component/has-cors\nlet value = false;\ntry {\n    value = typeof XMLHttpRequest !== \"undefined\" && \"withCredentials\" in new XMLHttpRequest();\n} catch (err) {\n// if XMLHttp support is disabled in IE then it will throw\n// when trying to create\n}\nconst hasCORS = value;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL2NvbnRyaWIvaGFzLWNvcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHNEQUFzRDtBQUN0RCxJQUFJQSxRQUFRO0FBQ1osSUFBSTtJQUNBQSxRQUFRLE9BQU9DLG1CQUFtQixlQUM5QixxQkFBcUIsSUFBSUE7QUFDakMsRUFDQSxPQUFPQyxLQUFLO0FBQ1IsMERBQTBEO0FBQzFELHdCQUF3QjtBQUM1QjtBQUNPLE1BQU1DLFVBQVVILE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL2NvbnRyaWIvaGFzLWNvcnMuanM/Y2JkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvaGFzLWNvcnNcbmxldCB2YWx1ZSA9IGZhbHNlO1xudHJ5IHtcbiAgICB2YWx1ZSA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG59XG5jYXRjaCAoZXJyKSB7XG4gICAgLy8gaWYgWE1MSHR0cCBzdXBwb3J0IGlzIGRpc2FibGVkIGluIElFIHRoZW4gaXQgd2lsbCB0aHJvd1xuICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxufVxuZXhwb3J0IGNvbnN0IGhhc0NPUlMgPSB2YWx1ZTtcbiJdLCJuYW1lcyI6WyJ2YWx1ZSIsIlhNTEh0dHBSZXF1ZXN0IiwiZXJyIiwiaGFzQ09SUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/contrib/has-cors.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/contrib/parseqs.js":
/*!***************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/contrib/parseqs.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n// imported from https://github.com/galkn/querystring\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */ function encode(obj) {\n    let str = \"\";\n    for(let i in obj){\n        if (obj.hasOwnProperty(i)) {\n            if (str.length) str += \"&\";\n            str += encodeURIComponent(i) + \"=\" + encodeURIComponent(obj[i]);\n        }\n    }\n    return str;\n}\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */ function decode(qs) {\n    let qry = {};\n    let pairs = qs.split(\"&\");\n    for(let i = 0, l = pairs.length; i < l; i++){\n        let pair = pairs[i].split(\"=\");\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n    return qry;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL2NvbnRyaWIvcGFyc2Vxcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLHFEQUFxRDtBQUNyRDs7Ozs7O0NBTUMsR0FDTSxTQUFTQSxPQUFPQyxHQUFHO0lBQ3RCLElBQUlDLE1BQU07SUFDVixJQUFLLElBQUlDLEtBQUtGLElBQUs7UUFDZixJQUFJQSxJQUFJRyxjQUFjLENBQUNELElBQUk7WUFDdkIsSUFBSUQsSUFBSUcsTUFBTSxFQUNWSCxPQUFPO1lBQ1hBLE9BQU9JLG1CQUFtQkgsS0FBSyxNQUFNRyxtQkFBbUJMLEdBQUcsQ0FBQ0UsRUFBRTtRQUNsRTtJQUNKO0lBQ0EsT0FBT0Q7QUFDWDtBQUNBOzs7OztDQUtDLEdBQ00sU0FBU0ssT0FBT0MsRUFBRTtJQUNyQixJQUFJQyxNQUFNLENBQUM7SUFDWCxJQUFJQyxRQUFRRixHQUFHRyxLQUFLLENBQUM7SUFDckIsSUFBSyxJQUFJUixJQUFJLEdBQUdTLElBQUlGLE1BQU1MLE1BQU0sRUFBRUYsSUFBSVMsR0FBR1QsSUFBSztRQUMxQyxJQUFJVSxPQUFPSCxLQUFLLENBQUNQLEVBQUUsQ0FBQ1EsS0FBSyxDQUFDO1FBQzFCRixHQUFHLENBQUNLLG1CQUFtQkQsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFHQyxtQkFBbUJELElBQUksQ0FBQyxFQUFFO0lBQ2pFO0lBQ0EsT0FBT0o7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL3doYXRzYXBwLWFpLWNybS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9lc20tZGVidWcvY29udHJpYi9wYXJzZXFzLmpzP2Q3ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ2Fsa24vcXVlcnlzdHJpbmdcbi8qKlxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUob2JqKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHN0ciArPSAnJic7XG4gICAgICAgICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8qKlxuICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHFzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShxcykge1xuICAgIGxldCBxcnkgPSB7fTtcbiAgICBsZXQgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGxldCBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gICAgfVxuICAgIHJldHVybiBxcnk7XG59XG4iXSwibmFtZXMiOlsiZW5jb2RlIiwib2JqIiwic3RyIiwiaSIsImhhc093blByb3BlcnR5IiwibGVuZ3RoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZGVjb2RlIiwicXMiLCJxcnkiLCJwYWlycyIsInNwbGl0IiwibCIsInBhaXIiLCJkZWNvZGVVUklDb21wb25lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/contrib/parseqs.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js":
/*!****************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n// imported from https://github.com/galkn/parseuri\n/**\n * Parses a URI\n *\n * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n *\n * See:\n * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n * - https://caniuse.com/url\n * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n *\n * History of the parse() method:\n * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */ const re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nconst parts = [\n    \"source\",\n    \"protocol\",\n    \"authority\",\n    \"userInfo\",\n    \"user\",\n    \"password\",\n    \"host\",\n    \"port\",\n    \"relative\",\n    \"path\",\n    \"directory\",\n    \"file\",\n    \"query\",\n    \"anchor\"\n];\nfunction parse(str) {\n    if (str.length > 8000) {\n        throw \"URI too long\";\n    }\n    const src = str, b = str.indexOf(\"[\"), e = str.indexOf(\"]\");\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, \";\") + str.substring(e, str.length);\n    }\n    let m = re.exec(str || \"\"), uri = {}, i = 14;\n    while(i--){\n        uri[parts[i]] = m[i] || \"\";\n    }\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, \":\");\n        uri.authority = uri.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\");\n        uri.ipv6uri = true;\n    }\n    uri.pathNames = pathNames(uri, uri[\"path\"]);\n    uri.queryKey = queryKey(uri, uri[\"query\"]);\n    return uri;\n}\nfunction pathNames(obj, path) {\n    const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n    if (path.slice(0, 1) == \"/\" || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.slice(-1) == \"/\") {\n        names.splice(names.length - 1, 1);\n    }\n    return names;\n}\nfunction queryKey(uri, query) {\n    const data = {};\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n    return data;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL2NvbnRyaWIvcGFyc2V1cmkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGtEQUFrRDtBQUNsRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDRCxNQUFNQSxLQUFLO0FBQ1gsTUFBTUMsUUFBUTtJQUNWO0lBQVU7SUFBWTtJQUFhO0lBQVk7SUFBUTtJQUFZO0lBQVE7SUFBUTtJQUFZO0lBQVE7SUFBYTtJQUFRO0lBQVM7Q0FDeEk7QUFDTSxTQUFTQyxNQUFNQyxHQUFHO0lBQ3JCLElBQUlBLElBQUlDLE1BQU0sR0FBRyxNQUFNO1FBQ25CLE1BQU07SUFDVjtJQUNBLE1BQU1DLE1BQU1GLEtBQUtHLElBQUlILElBQUlJLE9BQU8sQ0FBQyxNQUFNQyxJQUFJTCxJQUFJSSxPQUFPLENBQUM7SUFDdkQsSUFBSUQsS0FBSyxDQUFDLEtBQUtFLEtBQUssQ0FBQyxHQUFHO1FBQ3BCTCxNQUFNQSxJQUFJTSxTQUFTLENBQUMsR0FBR0gsS0FBS0gsSUFBSU0sU0FBUyxDQUFDSCxHQUFHRSxHQUFHRSxPQUFPLENBQUMsTUFBTSxPQUFPUCxJQUFJTSxTQUFTLENBQUNELEdBQUdMLElBQUlDLE1BQU07SUFDcEc7SUFDQSxJQUFJTyxJQUFJWCxHQUFHWSxJQUFJLENBQUNULE9BQU8sS0FBS1UsTUFBTSxDQUFDLEdBQUdDLElBQUk7SUFDMUMsTUFBT0EsSUFBSztRQUNSRCxHQUFHLENBQUNaLEtBQUssQ0FBQ2EsRUFBRSxDQUFDLEdBQUdILENBQUMsQ0FBQ0csRUFBRSxJQUFJO0lBQzVCO0lBQ0EsSUFBSVIsS0FBSyxDQUFDLEtBQUtFLEtBQUssQ0FBQyxHQUFHO1FBQ3BCSyxJQUFJRSxNQUFNLEdBQUdWO1FBQ2JRLElBQUlHLElBQUksR0FBR0gsSUFBSUcsSUFBSSxDQUFDUCxTQUFTLENBQUMsR0FBR0ksSUFBSUcsSUFBSSxDQUFDWixNQUFNLEdBQUcsR0FBR00sT0FBTyxDQUFDLE1BQU07UUFDcEVHLElBQUlJLFNBQVMsR0FBR0osSUFBSUksU0FBUyxDQUFDUCxPQUFPLENBQUMsS0FBSyxJQUFJQSxPQUFPLENBQUMsS0FBSyxJQUFJQSxPQUFPLENBQUMsTUFBTTtRQUM5RUcsSUFBSUssT0FBTyxHQUFHO0lBQ2xCO0lBQ0FMLElBQUlNLFNBQVMsR0FBR0EsVUFBVU4sS0FBS0EsR0FBRyxDQUFDLE9BQU87SUFDMUNBLElBQUlPLFFBQVEsR0FBR0EsU0FBU1AsS0FBS0EsR0FBRyxDQUFDLFFBQVE7SUFDekMsT0FBT0E7QUFDWDtBQUNBLFNBQVNNLFVBQVVFLEdBQUcsRUFBRUMsSUFBSTtJQUN4QixNQUFNQyxPQUFPLFlBQVlDLFFBQVFGLEtBQUtaLE9BQU8sQ0FBQ2EsTUFBTSxLQUFLRSxLQUFLLENBQUM7SUFDL0QsSUFBSUgsS0FBS0ksS0FBSyxDQUFDLEdBQUcsTUFBTSxPQUFPSixLQUFLbEIsTUFBTSxLQUFLLEdBQUc7UUFDOUNvQixNQUFNRyxNQUFNLENBQUMsR0FBRztJQUNwQjtJQUNBLElBQUlMLEtBQUtJLEtBQUssQ0FBQyxDQUFDLE1BQU0sS0FBSztRQUN2QkYsTUFBTUcsTUFBTSxDQUFDSCxNQUFNcEIsTUFBTSxHQUFHLEdBQUc7SUFDbkM7SUFDQSxPQUFPb0I7QUFDWDtBQUNBLFNBQVNKLFNBQVNQLEdBQUcsRUFBRWUsS0FBSztJQUN4QixNQUFNQyxPQUFPLENBQUM7SUFDZEQsTUFBTWxCLE9BQU8sQ0FBQyw2QkFBNkIsU0FBVW9CLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFO1FBQzNELElBQUlELElBQUk7WUFDSkYsSUFBSSxDQUFDRSxHQUFHLEdBQUdDO1FBQ2Y7SUFDSjtJQUNBLE9BQU9IO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL2NvbnRyaWIvcGFyc2V1cmkuanM/ZWVjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nYWxrbi9wYXJzZXVyaVxuLyoqXG4gKiBQYXJzZXMgYSBVUklcbiAqXG4gKiBOb3RlOiB3ZSBjb3VsZCBhbHNvIGhhdmUgdXNlZCB0aGUgYnVpbHQtaW4gVVJMIG9iamVjdCwgYnV0IGl0IGlzbid0IHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLlxuICpcbiAqIFNlZTpcbiAqIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTFxuICogLSBodHRwczovL2Nhbml1c2UuY29tL3VybFxuICogLSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMzk4NiNhcHBlbmRpeC1CXG4gKlxuICogSGlzdG9yeSBvZiB0aGUgcGFyc2UoKSBtZXRob2Q6XG4gKiAtIGZpcnN0IGNvbW1pdDogaHR0cHM6Ly9naXRodWIuY29tL3NvY2tldGlvL3NvY2tldC5pby1jbGllbnQvY29tbWl0LzRlZTFkNWQ5NGIzOTA2YTljMDUyYjQ1OWYxYTgxOGIxNWYzOGY5MWNcbiAqIC0gZXhwb3J0IGludG8gaXRzIG93biBtb2R1bGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9lbmdpbmUuaW8tY2xpZW50L2NvbW1pdC9kZTJjNTYxZTQ1NjRlZmViNzhmMWJkYjFiYTM5ZWY4MWIyODIyY2IzXG4gKiAtIHJlaW1wb3J0OiBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vZW5naW5lLmlvLWNsaWVudC9jb21taXQvZGYzMjI3N2MzZjZkNjIyZWVjNWVkMDlmNDkzY2FlM2YzMzkxZDI0MlxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5jb25zdCByZSA9IC9eKD86KD8hW146QFxcLz8jXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QFxcLz8jXSopKD86OihbXjpAXFwvPyNdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuY29uc3QgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIGlmIChzdHIubGVuZ3RoID4gODAwMCkge1xuICAgICAgICB0aHJvdyBcIlVSSSB0b28gbG9uZ1wiO1xuICAgIH1cbiAgICBjb25zdCBzcmMgPSBzdHIsIGIgPSBzdHIuaW5kZXhPZignWycpLCBlID0gc3RyLmluZGV4T2YoJ10nKTtcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBtID0gcmUuZXhlYyhzdHIgfHwgJycpLCB1cmkgPSB7fSwgaSA9IDE0O1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgfVxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuICAgIHVyaS5wYXRoTmFtZXMgPSBwYXRoTmFtZXModXJpLCB1cmlbJ3BhdGgnXSk7XG4gICAgdXJpLnF1ZXJ5S2V5ID0gcXVlcnlLZXkodXJpLCB1cmlbJ3F1ZXJ5J10pO1xuICAgIHJldHVybiB1cmk7XG59XG5mdW5jdGlvbiBwYXRoTmFtZXMob2JqLCBwYXRoKSB7XG4gICAgY29uc3QgcmVneCA9IC9cXC97Miw5fS9nLCBuYW1lcyA9IHBhdGgucmVwbGFjZShyZWd4LCBcIi9cIikuc3BsaXQoXCIvXCIpO1xuICAgIGlmIChwYXRoLnNsaWNlKDAsIDEpID09ICcvJyB8fCBwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBuYW1lcy5zcGxpY2UoMCwgMSk7XG4gICAgfVxuICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PSAnLycpIHtcbiAgICAgICAgbmFtZXMuc3BsaWNlKG5hbWVzLmxlbmd0aCAtIDEsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXM7XG59XG5mdW5jdGlvbiBxdWVyeUtleSh1cmksIHF1ZXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIHF1ZXJ5LnJlcGxhY2UoLyg/Ol58JikoW14mPV0qKT0/KFteJl0qKS9nLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xuICAgICAgICBpZiAoJDEpIHtcbiAgICAgICAgICAgIGRhdGFbJDFdID0gJDI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbiJdLCJuYW1lcyI6WyJyZSIsInBhcnRzIiwicGFyc2UiLCJzdHIiLCJsZW5ndGgiLCJzcmMiLCJiIiwiaW5kZXhPZiIsImUiLCJzdWJzdHJpbmciLCJyZXBsYWNlIiwibSIsImV4ZWMiLCJ1cmkiLCJpIiwic291cmNlIiwiaG9zdCIsImF1dGhvcml0eSIsImlwdjZ1cmkiLCJwYXRoTmFtZXMiLCJxdWVyeUtleSIsIm9iaiIsInBhdGgiLCJyZWd4IiwibmFtZXMiLCJzcGxpdCIsInNsaWNlIiwic3BsaWNlIiwicXVlcnkiLCJkYXRhIiwiJDAiLCIkMSIsIiQyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/globals.node.js":
/*!************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/globals.node.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CookieJar: () => (/* binding */ CookieJar),\n/* harmony export */   createCookieJar: () => (/* binding */ createCookieJar),\n/* harmony export */   defaultBinaryType: () => (/* binding */ defaultBinaryType),\n/* harmony export */   globalThisShim: () => (/* binding */ globalThisShim),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\nconst nextTick = process.nextTick;\nconst globalThisShim = global;\nconst defaultBinaryType = \"nodebuffer\";\nfunction createCookieJar() {\n    return new CookieJar();\n}\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie\n */ function parse(setCookieString) {\n    const parts = setCookieString.split(\"; \");\n    const i = parts[0].indexOf(\"=\");\n    if (i === -1) {\n        return;\n    }\n    const name = parts[0].substring(0, i).trim();\n    if (!name.length) {\n        return;\n    }\n    let value = parts[0].substring(i + 1).trim();\n    if (value.charCodeAt(0) === 0x22) {\n        // remove double quotes\n        value = value.slice(1, -1);\n    }\n    const cookie = {\n        name,\n        value\n    };\n    for(let j = 1; j < parts.length; j++){\n        const subParts = parts[j].split(\"=\");\n        if (subParts.length !== 2) {\n            continue;\n        }\n        const key = subParts[0].trim();\n        const value = subParts[1].trim();\n        switch(key){\n            case \"Expires\":\n                cookie.expires = new Date(value);\n                break;\n            case \"Max-Age\":\n                const expiration = new Date();\n                expiration.setUTCSeconds(expiration.getUTCSeconds() + parseInt(value, 10));\n                cookie.expires = expiration;\n                break;\n            default:\n        }\n    }\n    return cookie;\n}\nclass CookieJar {\n    constructor(){\n        this._cookies = new Map();\n    }\n    parseCookies(values) {\n        if (!values) {\n            return;\n        }\n        values.forEach((value)=>{\n            const parsed = parse(value);\n            if (parsed) {\n                this._cookies.set(parsed.name, parsed);\n            }\n        });\n    }\n    get cookies() {\n        const now = Date.now();\n        this._cookies.forEach((cookie, name)=>{\n            var _a;\n            if (((_a = cookie.expires) === null || _a === void 0 ? void 0 : _a.getTime()) < now) {\n                this._cookies.delete(name);\n            }\n        });\n        return this._cookies.entries();\n    }\n    addCookies(xhr) {\n        const cookies = [];\n        for (const [name, cookie] of this.cookies){\n            cookies.push(`${name}=${cookie.value}`);\n        }\n        if (cookies.length) {\n            xhr.setDisableHeaderCheck(true);\n            xhr.setRequestHeader(\"cookie\", cookies.join(\"; \"));\n        }\n    }\n    appendCookies(headers) {\n        for (const [name, cookie] of this.cookies){\n            headers.append(\"cookie\", `${name}=${cookie.value}`);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL2dsb2JhbHMubm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBTyxNQUFNQSxXQUFXQyxRQUFRRCxRQUFRLENBQUM7QUFDbEMsTUFBTUUsaUJBQWlCQyxPQUFPO0FBQzlCLE1BQU1DLG9CQUFvQixhQUFhO0FBQ3ZDLFNBQVNDO0lBQ1osT0FBTyxJQUFJQztBQUNmO0FBQ0E7O0NBRUMsR0FDTSxTQUFTQyxNQUFNQyxlQUFlO0lBQ2pDLE1BQU1DLFFBQVFELGdCQUFnQkUsS0FBSyxDQUFDO0lBQ3BDLE1BQU1DLElBQUlGLEtBQUssQ0FBQyxFQUFFLENBQUNHLE9BQU8sQ0FBQztJQUMzQixJQUFJRCxNQUFNLENBQUMsR0FBRztRQUNWO0lBQ0o7SUFDQSxNQUFNRSxPQUFPSixLQUFLLENBQUMsRUFBRSxDQUFDSyxTQUFTLENBQUMsR0FBR0gsR0FBR0ksSUFBSTtJQUMxQyxJQUFJLENBQUNGLEtBQUtHLE1BQU0sRUFBRTtRQUNkO0lBQ0o7SUFDQSxJQUFJQyxRQUFRUixLQUFLLENBQUMsRUFBRSxDQUFDSyxTQUFTLENBQUNILElBQUksR0FBR0ksSUFBSTtJQUMxQyxJQUFJRSxNQUFNQyxVQUFVLENBQUMsT0FBTyxNQUFNO1FBQzlCLHVCQUF1QjtRQUN2QkQsUUFBUUEsTUFBTUUsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUM1QjtJQUNBLE1BQU1DLFNBQVM7UUFDWFA7UUFDQUk7SUFDSjtJQUNBLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJWixNQUFNTyxNQUFNLEVBQUVLLElBQUs7UUFDbkMsTUFBTUMsV0FBV2IsS0FBSyxDQUFDWSxFQUFFLENBQUNYLEtBQUssQ0FBQztRQUNoQyxJQUFJWSxTQUFTTixNQUFNLEtBQUssR0FBRztZQUN2QjtRQUNKO1FBQ0EsTUFBTU8sTUFBTUQsUUFBUSxDQUFDLEVBQUUsQ0FBQ1AsSUFBSTtRQUM1QixNQUFNRSxRQUFRSyxRQUFRLENBQUMsRUFBRSxDQUFDUCxJQUFJO1FBQzlCLE9BQVFRO1lBQ0osS0FBSztnQkFDREgsT0FBT0ksT0FBTyxHQUFHLElBQUlDLEtBQUtSO2dCQUMxQjtZQUNKLEtBQUs7Z0JBQ0QsTUFBTVMsYUFBYSxJQUFJRDtnQkFDdkJDLFdBQVdDLGFBQWEsQ0FBQ0QsV0FBV0UsYUFBYSxLQUFLQyxTQUFTWixPQUFPO2dCQUN0RUcsT0FBT0ksT0FBTyxHQUFHRTtnQkFDakI7WUFDSjtRQUVKO0lBQ0o7SUFDQSxPQUFPTjtBQUNYO0FBQ08sTUFBTWQ7SUFDVHdCLGFBQWM7UUFDVixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJQztJQUN4QjtJQUNBQyxhQUFhQyxNQUFNLEVBQUU7UUFDakIsSUFBSSxDQUFDQSxRQUFRO1lBQ1Q7UUFDSjtRQUNBQSxPQUFPQyxPQUFPLENBQUMsQ0FBQ2xCO1lBQ1osTUFBTW1CLFNBQVM3QixNQUFNVTtZQUNyQixJQUFJbUIsUUFBUTtnQkFDUixJQUFJLENBQUNMLFFBQVEsQ0FBQ00sR0FBRyxDQUFDRCxPQUFPdkIsSUFBSSxFQUFFdUI7WUFDbkM7UUFDSjtJQUNKO0lBQ0EsSUFBSUUsVUFBVTtRQUNWLE1BQU1DLE1BQU1kLEtBQUtjLEdBQUc7UUFDcEIsSUFBSSxDQUFDUixRQUFRLENBQUNJLE9BQU8sQ0FBQyxDQUFDZixRQUFRUDtZQUMzQixJQUFJMkI7WUFDSixJQUFJLENBQUMsQ0FBQ0EsS0FBS3BCLE9BQU9JLE9BQU8sTUFBTSxRQUFRZ0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHQyxPQUFPLEVBQUMsSUFBS0YsS0FBSztnQkFDakYsSUFBSSxDQUFDUixRQUFRLENBQUNXLE1BQU0sQ0FBQzdCO1lBQ3pCO1FBQ0o7UUFDQSxPQUFPLElBQUksQ0FBQ2tCLFFBQVEsQ0FBQ1ksT0FBTztJQUNoQztJQUNBQyxXQUFXQyxHQUFHLEVBQUU7UUFDWixNQUFNUCxVQUFVLEVBQUU7UUFDbEIsS0FBSyxNQUFNLENBQUN6QixNQUFNTyxPQUFPLElBQUksSUFBSSxDQUFDa0IsT0FBTyxDQUFFO1lBQ3ZDQSxRQUFRUSxJQUFJLENBQUMsQ0FBQyxFQUFFakMsS0FBSyxDQUFDLEVBQUVPLE9BQU9ILEtBQUssQ0FBQyxDQUFDO1FBQzFDO1FBQ0EsSUFBSXFCLFFBQVF0QixNQUFNLEVBQUU7WUFDaEI2QixJQUFJRSxxQkFBcUIsQ0FBQztZQUMxQkYsSUFBSUcsZ0JBQWdCLENBQUMsVUFBVVYsUUFBUVcsSUFBSSxDQUFDO1FBQ2hEO0lBQ0o7SUFDQUMsY0FBY0MsT0FBTyxFQUFFO1FBQ25CLEtBQUssTUFBTSxDQUFDdEMsTUFBTU8sT0FBTyxJQUFJLElBQUksQ0FBQ2tCLE9BQU8sQ0FBRTtZQUN2Q2EsUUFBUUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFdkMsS0FBSyxDQUFDLEVBQUVPLE9BQU9ILEtBQUssQ0FBQyxDQUFDO1FBQ3REO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3doYXRzYXBwLWFpLWNybS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9lc20tZGVidWcvZ2xvYmFscy5ub2RlLmpzPzA3ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbmV4cG9ydCBjb25zdCBnbG9iYWxUaGlzU2hpbSA9IGdsb2JhbDtcbmV4cG9ydCBjb25zdCBkZWZhdWx0QmluYXJ5VHlwZSA9IFwibm9kZWJ1ZmZlclwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvb2tpZUphcigpIHtcbiAgICByZXR1cm4gbmV3IENvb2tpZUphcigpO1xufVxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9TZXQtQ29va2llXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShzZXRDb29raWVTdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHNldENvb2tpZVN0cmluZy5zcGxpdChcIjsgXCIpO1xuICAgIGNvbnN0IGkgPSBwYXJ0c1swXS5pbmRleE9mKFwiPVwiKTtcbiAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gcGFydHNbMF0uc3Vic3RyaW5nKDAsIGkpLnRyaW0oKTtcbiAgICBpZiAoIW5hbWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gcGFydHNbMF0uc3Vic3RyaW5nKGkgKyAxKS50cmltKCk7XG4gICAgaWYgKHZhbHVlLmNoYXJDb2RlQXQoMCkgPT09IDB4MjIpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGRvdWJsZSBxdW90ZXNcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIGNvbnN0IGNvb2tpZSA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWUsXG4gICAgfTtcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHN1YlBhcnRzID0gcGFydHNbal0uc3BsaXQoXCI9XCIpO1xuICAgICAgICBpZiAoc3ViUGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBzdWJQYXJ0c1swXS50cmltKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3ViUGFydHNbMV0udHJpbSgpO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSBcIkV4cGlyZXNcIjpcbiAgICAgICAgICAgICAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNYXgtQWdlXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwaXJhdGlvbiA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgZXhwaXJhdGlvbi5zZXRVVENTZWNvbmRzKGV4cGlyYXRpb24uZ2V0VVRDU2Vjb25kcygpICsgcGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgICAgICAgICAgICAgY29va2llLmV4cGlyZXMgPSBleHBpcmF0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGlnbm9yZSBvdGhlciBrZXlzXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvb2tpZTtcbn1cbmV4cG9ydCBjbGFzcyBDb29raWVKYXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9jb29raWVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBwYXJzZUNvb2tpZXModmFsdWVzKSB7XG4gICAgICAgIGlmICghdmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29va2llcy5zZXQocGFyc2VkLm5hbWUsIHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgY29va2llcygpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5fY29va2llcy5mb3JFYWNoKChjb29raWUsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gY29va2llLmV4cGlyZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUaW1lKCkpIDwgbm93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29va2llcy5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29va2llcy5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGFkZENvb2tpZXMoeGhyKSB7XG4gICAgICAgIGNvbnN0IGNvb2tpZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgY29va2llXSBvZiB0aGlzLmNvb2tpZXMpIHtcbiAgICAgICAgICAgIGNvb2tpZXMucHVzaChgJHtuYW1lfT0ke2Nvb2tpZS52YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29va2llcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcImNvb2tpZVwiLCBjb29raWVzLmpvaW4oXCI7IFwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kQ29va2llcyhoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIGNvb2tpZV0gb2YgdGhpcy5jb29raWVzKSB7XG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChcImNvb2tpZVwiLCBgJHtuYW1lfT0ke2Nvb2tpZS52YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJuZXh0VGljayIsInByb2Nlc3MiLCJnbG9iYWxUaGlzU2hpbSIsImdsb2JhbCIsImRlZmF1bHRCaW5hcnlUeXBlIiwiY3JlYXRlQ29va2llSmFyIiwiQ29va2llSmFyIiwicGFyc2UiLCJzZXRDb29raWVTdHJpbmciLCJwYXJ0cyIsInNwbGl0IiwiaSIsImluZGV4T2YiLCJuYW1lIiwic3Vic3RyaW5nIiwidHJpbSIsImxlbmd0aCIsInZhbHVlIiwiY2hhckNvZGVBdCIsInNsaWNlIiwiY29va2llIiwiaiIsInN1YlBhcnRzIiwia2V5IiwiZXhwaXJlcyIsIkRhdGUiLCJleHBpcmF0aW9uIiwic2V0VVRDU2Vjb25kcyIsImdldFVUQ1NlY29uZHMiLCJwYXJzZUludCIsImNvbnN0cnVjdG9yIiwiX2Nvb2tpZXMiLCJNYXAiLCJwYXJzZUNvb2tpZXMiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwicGFyc2VkIiwic2V0IiwiY29va2llcyIsIm5vdyIsIl9hIiwiZ2V0VGltZSIsImRlbGV0ZSIsImVudHJpZXMiLCJhZGRDb29raWVzIiwieGhyIiwicHVzaCIsInNldERpc2FibGVIZWFkZXJDaGVjayIsInNldFJlcXVlc3RIZWFkZXIiLCJqb2luIiwiYXBwZW5kQ29va2llcyIsImhlYWRlcnMiLCJhcHBlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/globals.node.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fetch: () => (/* reexport safe */ _transports_polling_fetch_js__WEBPACK_IMPORTED_MODULE_6__.Fetch),\n/* harmony export */   NodeWebSocket: () => (/* reexport safe */ _transports_websocket_node_js__WEBPACK_IMPORTED_MODULE_9__.WS),\n/* harmony export */   NodeXHR: () => (/* reexport safe */ _transports_polling_xhr_node_js__WEBPACK_IMPORTED_MODULE_7__.XHR),\n/* harmony export */   Socket: () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_0__.Socket),\n/* harmony export */   SocketWithUpgrade: () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_0__.SocketWithUpgrade),\n/* harmony export */   SocketWithoutUpgrade: () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_0__.SocketWithoutUpgrade),\n/* harmony export */   Transport: () => (/* reexport safe */ _transport_js__WEBPACK_IMPORTED_MODULE_1__.Transport),\n/* harmony export */   TransportError: () => (/* reexport safe */ _transport_js__WEBPACK_IMPORTED_MODULE_1__.TransportError),\n/* harmony export */   WebSocket: () => (/* reexport safe */ _transports_websocket_js__WEBPACK_IMPORTED_MODULE_10__.WS),\n/* harmony export */   WebTransport: () => (/* reexport safe */ _transports_webtransport_js__WEBPACK_IMPORTED_MODULE_11__.WT),\n/* harmony export */   XHR: () => (/* reexport safe */ _transports_polling_xhr_js__WEBPACK_IMPORTED_MODULE_8__.XHR),\n/* harmony export */   installTimerFunctions: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_3__.installTimerFunctions),\n/* harmony export */   nextTick: () => (/* reexport safe */ _globals_node_js__WEBPACK_IMPORTED_MODULE_5__.nextTick),\n/* harmony export */   parse: () => (/* reexport safe */ _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__.parse),\n/* harmony export */   protocol: () => (/* binding */ protocol),\n/* harmony export */   transports: () => (/* reexport safe */ _transports_index_js__WEBPACK_IMPORTED_MODULE_2__.transports)\n/* harmony export */ });\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./socket.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/socket.js\");\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transport.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transport.js\");\n/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transports/index.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/util.js\");\n/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contrib/parseuri.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js\");\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./globals.node.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/globals.node.js\");\n/* harmony import */ var _transports_polling_fetch_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transports/polling-fetch.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling-fetch.js\");\n/* harmony import */ var _transports_polling_xhr_node_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transports/polling-xhr.node.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.node.js\");\n/* harmony import */ var _transports_polling_xhr_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./transports/polling-xhr.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.js\");\n/* harmony import */ var _transports_websocket_node_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./transports/websocket.node.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/websocket.node.js\");\n/* harmony import */ var _transports_websocket_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./transports/websocket.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/websocket.js\");\n/* harmony import */ var _transports_webtransport_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transports/webtransport.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/webtransport.js\");\n\n\n\nconst protocol = _socket_js__WEBPACK_IMPORTED_MODULE_0__.Socket.protocol;\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDbkI7QUFDcUQ7QUFDaEUsTUFBTUcsV0FBV0gsOENBQU1BLENBQUNHLFFBQVEsQ0FBQztBQUNtQjtBQUNSO0FBQ0Q7QUFDSjtBQUNEO0FBQ1M7QUFDWTtBQUNoQjtBQUNtQjtBQUNUO0FBQ00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL2luZGV4LmpzP2U0MTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29ja2V0IH0gZnJvbSBcIi4vc29ja2V0LmpzXCI7XG5leHBvcnQgeyBTb2NrZXQgfTtcbmV4cG9ydCB7IFNvY2tldFdpdGhvdXRVcGdyYWRlLCBTb2NrZXRXaXRoVXBncmFkZSwgfSBmcm9tIFwiLi9zb2NrZXQuanNcIjtcbmV4cG9ydCBjb25zdCBwcm90b2NvbCA9IFNvY2tldC5wcm90b2NvbDtcbmV4cG9ydCB7IFRyYW5zcG9ydCwgVHJhbnNwb3J0RXJyb3IgfSBmcm9tIFwiLi90cmFuc3BvcnQuanNcIjtcbmV4cG9ydCB7IHRyYW5zcG9ydHMgfSBmcm9tIFwiLi90cmFuc3BvcnRzL2luZGV4LmpzXCI7XG5leHBvcnQgeyBpbnN0YWxsVGltZXJGdW5jdGlvbnMgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5leHBvcnQgeyBwYXJzZSB9IGZyb20gXCIuL2NvbnRyaWIvcGFyc2V1cmkuanNcIjtcbmV4cG9ydCB7IG5leHRUaWNrIH0gZnJvbSBcIi4vZ2xvYmFscy5ub2RlLmpzXCI7XG5leHBvcnQgeyBGZXRjaCB9IGZyb20gXCIuL3RyYW5zcG9ydHMvcG9sbGluZy1mZXRjaC5qc1wiO1xuZXhwb3J0IHsgWEhSIGFzIE5vZGVYSFIgfSBmcm9tIFwiLi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLm5vZGUuanNcIjtcbmV4cG9ydCB7IFhIUiB9IGZyb20gXCIuL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanNcIjtcbmV4cG9ydCB7IFdTIGFzIE5vZGVXZWJTb2NrZXQgfSBmcm9tIFwiLi90cmFuc3BvcnRzL3dlYnNvY2tldC5ub2RlLmpzXCI7XG5leHBvcnQgeyBXUyBhcyBXZWJTb2NrZXQgfSBmcm9tIFwiLi90cmFuc3BvcnRzL3dlYnNvY2tldC5qc1wiO1xuZXhwb3J0IHsgV1QgYXMgV2ViVHJhbnNwb3J0IH0gZnJvbSBcIi4vdHJhbnNwb3J0cy93ZWJ0cmFuc3BvcnQuanNcIjtcbiJdLCJuYW1lcyI6WyJTb2NrZXQiLCJTb2NrZXRXaXRob3V0VXBncmFkZSIsIlNvY2tldFdpdGhVcGdyYWRlIiwicHJvdG9jb2wiLCJUcmFuc3BvcnQiLCJUcmFuc3BvcnRFcnJvciIsInRyYW5zcG9ydHMiLCJpbnN0YWxsVGltZXJGdW5jdGlvbnMiLCJwYXJzZSIsIm5leHRUaWNrIiwiRmV0Y2giLCJYSFIiLCJOb2RlWEhSIiwiV1MiLCJOb2RlV2ViU29ja2V0IiwiV2ViU29ja2V0IiwiV1QiLCJXZWJUcmFuc3BvcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/socket.js":
/*!******************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/socket.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Socket: () => (/* binding */ Socket),\n/* harmony export */   SocketWithUpgrade: () => (/* binding */ SocketWithUpgrade),\n/* harmony export */   SocketWithoutUpgrade: () => (/* binding */ SocketWithoutUpgrade)\n/* harmony export */ });\n/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transports/index.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/util.js\");\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contrib/parseqs.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/contrib/parseqs.js\");\n/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contrib/parseuri.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @socket.io/component-emitter */ \"(ssr)/../node_modules/@socket.io/component-emitter/lib/esm/index.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! engine.io-parser */ \"(ssr)/../node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./globals.node.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/globals.node.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! debug */ \"(ssr)/../node_modules/engine.io-client/node_modules/debug/src/index.js\");\n\n\n\n\n\n\n\n // debug()\nconst debug = debug__WEBPACK_IMPORTED_MODULE_7__(\"engine.io-client:socket\"); // debug()\nconst withEventListeners = typeof addEventListener === \"function\" && typeof removeEventListener === \"function\";\nconst OFFLINE_EVENT_LISTENERS = [];\nif (withEventListeners) {\n    // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the\n    // script, so we create one single event listener here which will forward the event to the socket instances\n    addEventListener(\"offline\", ()=>{\n        debug(\"closing %d connection(s) because the network was lost\", OFFLINE_EVENT_LISTENERS.length);\n        OFFLINE_EVENT_LISTENERS.forEach((listener)=>listener());\n    }, false);\n}\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that\n * successfully establishes the connection.\n *\n * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.\n *\n * @example\n * import { SocketWithoutUpgrade, WebSocket } from \"engine.io-client\";\n *\n * const socket = new SocketWithoutUpgrade({\n *   transports: [WebSocket]\n * });\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithUpgrade\n * @see Socket\n */ class SocketWithoutUpgrade extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */ constructor(uri, opts){\n        super();\n        this.binaryType = _globals_node_js__WEBPACK_IMPORTED_MODULE_6__.defaultBinaryType;\n        this.writeBuffer = [];\n        this._prevBufferLen = 0;\n        this._pingInterval = -1;\n        this._pingTimeout = -1;\n        this._maxPayload = -1;\n        /**\n         * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the\n         * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.\n         */ this._pingTimeoutTime = Infinity;\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            const parsedUri = (0,_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__.parse)(uri);\n            opts.hostname = parsedUri.host;\n            opts.secure = parsedUri.protocol === \"https\" || parsedUri.protocol === \"wss\";\n            opts.port = parsedUri.port;\n            if (parsedUri.query) opts.query = parsedUri.query;\n        } else if (opts.host) {\n            opts.hostname = (0,_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__.parse)(opts.host).host;\n        }\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.installTimerFunctions)(this, opts);\n        this.secure = null != opts.secure ? opts.secure : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname = opts.hostname || (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port = opts.port || (typeof location !== \"undefined\" && location.port ? location.port : this.secure ? \"443\" : \"80\");\n        this.transports = [];\n        this._transportsByName = {};\n        opts.transports.forEach((t)=>{\n            const transportName = t.prototype.name;\n            this.transports.push(transportName);\n            this._transportsByName[transportName] = t;\n        });\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            addTrailingSlash: true,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024\n            },\n            transportOptions: {},\n            closeOnBeforeunload: false\n        }, opts);\n        this.opts.path = this.opts.path.replace(/\\/$/, \"\") + (this.opts.addTrailingSlash ? \"/\" : \"\");\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = (0,_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__.decode)(this.opts.query);\n        }\n        if (withEventListeners) {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                this._beforeunloadEventListener = ()=>{\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                };\n                addEventListener(\"beforeunload\", this._beforeunloadEventListener, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                debug(\"adding listener for the 'offline' event\");\n                this._offlineEventListener = ()=>{\n                    this._onClose(\"transport close\", {\n                        description: \"network connection lost\"\n                    });\n                };\n                OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);\n            }\n        }\n        if (this.opts.withCredentials) {\n            this._cookieJar = (0,_globals_node_js__WEBPACK_IMPORTED_MODULE_6__.createCookieJar)();\n        }\n        this._open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */ createTransport(name) {\n        debug('creating transport \"%s\"', name);\n        const query = Object.assign({}, this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__.protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id) query.sid = this.id;\n        const opts = Object.assign({}, this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port\n        }, this.opts.transportOptions[name]);\n        debug(\"options: %j\", opts);\n        return new this._transportsByName[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @private\n     */ _open() {\n        if (this.transports.length === 0) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(()=>{\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1 ? \"websocket\" : this.transports[0];\n        this.readyState = \"opening\";\n        const transport = this.createTransport(transportName);\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @private\n     */ setTransport(transport) {\n        debug(\"setting transport %s\", transport.name);\n        if (this.transport) {\n            debug(\"clearing existing transport %s\", this.transport.name);\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport.on(\"drain\", this._onDrain.bind(this)).on(\"packet\", this._onPacket.bind(this)).on(\"error\", this._onError.bind(this)).on(\"close\", (reason)=>this._onClose(\"transport close\", reason));\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @private\n     */ onOpen() {\n        debug(\"socket open\");\n        this.readyState = \"open\";\n        SocketWithoutUpgrade.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n    }\n    /**\n     * Handles a packet.\n     *\n     * @private\n     */ _onPacket(packet) {\n        if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n            debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch(packet.type){\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this._sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    this._resetPingTimeout();\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this._onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        } else {\n            debug('packet received with socket readyState \"%s\"', this.readyState);\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @private\n     */ onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this._pingInterval = data.pingInterval;\n        this._pingTimeout = data.pingTimeout;\n        this._maxPayload = data.maxPayload;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState) return;\n        this._resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @private\n     */ _resetPingTimeout() {\n        this.clearTimeoutFn(this._pingTimeoutTimer);\n        const delay = this._pingInterval + this._pingTimeout;\n        this._pingTimeoutTime = Date.now() + delay;\n        this._pingTimeoutTimer = this.setTimeoutFn(()=>{\n            this._onClose(\"ping timeout\");\n        }, delay);\n        if (this.opts.autoUnref) {\n            this._pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @private\n     */ _onDrain() {\n        this.writeBuffer.splice(0, this._prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this._prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        } else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @private\n     */ flush() {\n        if (\"closed\" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n            const packets = this._getWritablePackets();\n            debug(\"flushing %d packets in socket\", packets.length);\n            this.transport.send(packets);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this._prevBufferLen = packets.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n     * long-polling)\n     *\n     * @private\n     */ _getWritablePackets() {\n        const shouldCheckPayloadSize = this._maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1;\n        if (!shouldCheckPayloadSize) {\n            return this.writeBuffer;\n        }\n        let payloadSize = 1; // first packet type\n        for(let i = 0; i < this.writeBuffer.length; i++){\n            const data = this.writeBuffer[i].data;\n            if (data) {\n                payloadSize += (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.byteLength)(data);\n            }\n            if (i > 0 && payloadSize > this._maxPayload) {\n                debug(\"only send %d out of %d packets\", i, this.writeBuffer.length);\n                return this.writeBuffer.slice(0, i);\n            }\n            payloadSize += 2; // separator + packet type\n        }\n        debug(\"payload size is %d (max: %d)\", payloadSize, this._maxPayload);\n        return this.writeBuffer;\n    }\n    /**\n     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.\n     *\n     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the\n     * `write()` method then the message would not be buffered by the Socket.IO client.\n     *\n     * @return {boolean}\n     * @private\n     */ /* private */ _hasPingExpired() {\n        if (!this._pingTimeoutTime) return true;\n        const hasExpired = Date.now() > this._pingTimeoutTime;\n        if (hasExpired) {\n            debug(\"throttled timer detected, scheduling connection close\");\n            this._pingTimeoutTime = 0;\n            (0,_globals_node_js__WEBPACK_IMPORTED_MODULE_6__.nextTick)(()=>{\n                this._onClose(\"ping timeout\");\n            }, this.setTimeoutFn);\n        }\n        return hasExpired;\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @return {Socket} for chaining.\n     */ write(msg, options, fn) {\n        this._sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a message. Alias of {@link Socket#write}.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @return {Socket} for chaining.\n     */ send(msg, options, fn) {\n        this._sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type: packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @private\n     */ _sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn) this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     */ close() {\n        const close = ()=>{\n            this._onClose(\"forced close\");\n            debug(\"socket closing - telling transport to close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = ()=>{\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = ()=>{\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", ()=>{\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    } else {\n                        close();\n                    }\n                });\n            } else if (this.upgrading) {\n                waitForUpgrade();\n            } else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @private\n     */ _onError(err) {\n        debug(\"socket error %j\", err);\n        SocketWithoutUpgrade.priorWebsocketSuccess = false;\n        if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === \"opening\") {\n            debug(\"trying next transport\");\n            this.transports.shift();\n            return this._open();\n        }\n        this.emitReserved(\"error\", err);\n        this._onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @private\n     */ _onClose(reason, description) {\n        if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n            debug('socket close with reason: \"%s\"', reason);\n            // clear timers\n            this.clearTimeoutFn(this._pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (withEventListeners) {\n                if (this._beforeunloadEventListener) {\n                    removeEventListener(\"beforeunload\", this._beforeunloadEventListener, false);\n                }\n                if (this._offlineEventListener) {\n                    const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);\n                    if (i !== -1) {\n                        debug(\"removing listener for the 'offline' event\");\n                        OFFLINE_EVENT_LISTENERS.splice(i, 1);\n                    }\n                }\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, description);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this._prevBufferLen = 0;\n        }\n    }\n}\nSocketWithoutUpgrade.protocol = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__.protocol;\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes with an upgrade mechanism, which means that once the connection is established with the first\n * low-level transport, it will try to upgrade to a better transport.\n *\n * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.\n *\n * @example\n * import { SocketWithUpgrade, WebSocket } from \"engine.io-client\";\n *\n * const socket = new SocketWithUpgrade({\n *   transports: [WebSocket]\n * });\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithoutUpgrade\n * @see Socket\n */ class SocketWithUpgrade extends SocketWithoutUpgrade {\n    constructor(){\n        super(...arguments);\n        this._upgrades = [];\n    }\n    onOpen() {\n        super.onOpen();\n        if (\"open\" === this.readyState && this.opts.upgrade) {\n            debug(\"starting upgrade probes\");\n            for(let i = 0; i < this._upgrades.length; i++){\n                this._probe(this._upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} name - transport name\n     * @private\n     */ _probe(name) {\n        debug('probing transport \"%s\"', name);\n        let transport = this.createTransport(name);\n        let failed = false;\n        SocketWithoutUpgrade.priorWebsocketSuccess = false;\n        const onTransportOpen = ()=>{\n            if (failed) return;\n            debug('probe transport \"%s\" opened', name);\n            transport.send([\n                {\n                    type: \"ping\",\n                    data: \"probe\"\n                }\n            ]);\n            transport.once(\"packet\", (msg)=>{\n                if (failed) return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    debug('probe transport \"%s\" pong', name);\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport) return;\n                    SocketWithoutUpgrade.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    debug('pausing current transport \"%s\"', this.transport.name);\n                    this.transport.pause(()=>{\n                        if (failed) return;\n                        if (\"closed\" === this.readyState) return;\n                        debug(\"changing transport and sending upgrade packet\");\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([\n                            {\n                                type: \"upgrade\"\n                            }\n                        ]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                } else {\n                    debug('probe transport \"%s\" failed', name);\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed) return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = (err)=>{\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            debug('probe transport \"%s\" failed because of error: %s', name, err);\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = ()=>{\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        if (this._upgrades.indexOf(\"webtransport\") !== -1 && name !== \"webtransport\") {\n            // favor WebTransport\n            this.setTimeoutFn(()=>{\n                if (!failed) {\n                    transport.open();\n                }\n            }, 200);\n        } else {\n            transport.open();\n        }\n    }\n    onHandshake(data) {\n        this._upgrades = this._filterUpgrades(data.upgrades);\n        super.onHandshake(data);\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} upgrades - server upgrades\n     * @private\n     */ _filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        for(let i = 0; i < upgrades.length; i++){\n            if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes with an upgrade mechanism, which means that once the connection is established with the first\n * low-level transport, it will try to upgrade to a better transport.\n *\n * @example\n * import { Socket } from \"engine.io-client\";\n *\n * const socket = new Socket();\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithoutUpgrade\n * @see SocketWithUpgrade\n */ class Socket extends SocketWithUpgrade {\n    constructor(uri, opts = {}){\n        const o = typeof uri === \"object\" ? uri : opts;\n        if (!o.transports || o.transports && typeof o.transports[0] === \"string\") {\n            o.transports = (o.transports || [\n                \"polling\",\n                \"websocket\",\n                \"webtransport\"\n            ]).map((transportName)=>_transports_index_js__WEBPACK_IMPORTED_MODULE_0__.transports[transportName]).filter((t)=>!!t);\n        }\n        super(uri, o);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3NvY2tldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUF5RTtBQUNYO0FBQ2hCO0FBQ0E7QUFDUztBQUNYO0FBQ3NDO0FBQ2xELENBQUMsVUFBVTtBQUMzQyxNQUFNWSxRQUFRRCxrQ0FBV0EsQ0FBQyw0QkFBNEIsVUFBVTtBQUNoRSxNQUFNRSxxQkFBcUIsT0FBT0MscUJBQXFCLGNBQ25ELE9BQU9DLHdCQUF3QjtBQUNuQyxNQUFNQywwQkFBMEIsRUFBRTtBQUNsQyxJQUFJSCxvQkFBb0I7SUFDcEIsbUhBQW1IO0lBQ25ILDJHQUEyRztJQUMzR0MsaUJBQWlCLFdBQVc7UUFDeEJGLE1BQU0seURBQXlESSx3QkFBd0JDLE1BQU07UUFDN0ZELHdCQUF3QkUsT0FBTyxDQUFDLENBQUNDLFdBQWFBO0lBQ2xELEdBQUc7QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ00sTUFBTUMsNkJBQTZCZCxpRUFBT0E7SUFDN0M7Ozs7O0tBS0MsR0FDRGUsWUFBWUMsR0FBRyxFQUFFQyxJQUFJLENBQUU7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FBQ0MsVUFBVSxHQUFHZiwrREFBaUJBO1FBQ25DLElBQUksQ0FBQ2dCLFdBQVcsR0FBRyxFQUFFO1FBQ3JCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLENBQUM7UUFDdEIsSUFBSSxDQUFDQyxZQUFZLEdBQUcsQ0FBQztRQUNyQixJQUFJLENBQUNDLFdBQVcsR0FBRyxDQUFDO1FBQ3BCOzs7U0FHQyxHQUNELElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdDO1FBQ3hCLElBQUlULE9BQU8sYUFBYSxPQUFPQSxLQUFLO1lBQ2hDQyxPQUFPRDtZQUNQQSxNQUFNO1FBQ1Y7UUFDQSxJQUFJQSxLQUFLO1lBQ0wsTUFBTVUsWUFBWTNCLDJEQUFLQSxDQUFDaUI7WUFDeEJD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QUFFLEdBQ3BDa0MsaUJBQWlCM0csSUFBSSxDQUFDMEcsUUFBUSxDQUFDakMsRUFBRTtRQUN6QztRQUNBLE9BQU9rQztJQUNYO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sTUFBTUMsZUFBZW5CO0lBQ3hCaEgsWUFBWUMsR0FBRyxFQUFFQyxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQ3hCLE1BQU1rSSxJQUFJLE9BQU9uSSxRQUFRLFdBQVdBLE1BQU1DO1FBQzFDLElBQUksQ0FBQ2tJLEVBQUV6SixVQUFVLElBQ1p5SixFQUFFekosVUFBVSxJQUFJLE9BQU95SixFQUFFekosVUFBVSxDQUFDLEVBQUUsS0FBSyxVQUFXO1lBQ3ZEeUosRUFBRXpKLFVBQVUsR0FBRyxDQUFDeUosRUFBRXpKLFVBQVUsSUFBSTtnQkFBQztnQkFBVztnQkFBYTthQUFlLEVBQ25FMEosR0FBRyxDQUFDLENBQUNqSCxnQkFBa0J4Qyw0REFBa0IsQ0FBQ3dDLGNBQWMsRUFDeERrSCxNQUFNLENBQUMsQ0FBQ25ILElBQU0sQ0FBQyxDQUFDQTtRQUN6QjtRQUNBLEtBQUssQ0FBQ2xCLEtBQUttSTtJQUNmO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3NvY2tldC5qcz9hZjRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRyYW5zcG9ydHMgYXMgREVGQVVMVF9UUkFOU1BPUlRTIH0gZnJvbSBcIi4vdHJhbnNwb3J0cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaW5zdGFsbFRpbWVyRnVuY3Rpb25zLCBieXRlTGVuZ3RoIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSBcIi4vY29udHJpYi9wYXJzZXFzLmpzXCI7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gXCIuL2NvbnRyaWIvcGFyc2V1cmkuanNcIjtcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tIFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiO1xuaW1wb3J0IHsgcHJvdG9jb2wgfSBmcm9tIFwiZW5naW5lLmlvLXBhcnNlclwiO1xuaW1wb3J0IHsgY3JlYXRlQ29va2llSmFyLCBkZWZhdWx0QmluYXJ5VHlwZSwgbmV4dFRpY2ssIH0gZnJvbSBcIi4vZ2xvYmFscy5ub2RlLmpzXCI7XG5pbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7IC8vIGRlYnVnKClcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJlbmdpbmUuaW8tY2xpZW50OnNvY2tldFwiKTsgLy8gZGVidWcoKVxuY29uc3Qgd2l0aEV2ZW50TGlzdGVuZXJzID0gdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiByZW1vdmVFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBPRkZMSU5FX0VWRU5UX0xJU1RFTkVSUyA9IFtdO1xuaWYgKHdpdGhFdmVudExpc3RlbmVycykge1xuICAgIC8vIHdpdGhpbiBhIFNlcnZpY2VXb3JrZXIsIGFueSBldmVudCBoYW5kbGVyIGZvciB0aGUgJ29mZmxpbmUnIGV2ZW50IG11c3QgYmUgYWRkZWQgb24gdGhlIGluaXRpYWwgZXZhbHVhdGlvbiBvZiB0aGVcbiAgICAvLyBzY3JpcHQsIHNvIHdlIGNyZWF0ZSBvbmUgc2luZ2xlIGV2ZW50IGxpc3RlbmVyIGhlcmUgd2hpY2ggd2lsbCBmb3J3YXJkIHRoZSBldmVudCB0byB0aGUgc29ja2V0IGluc3RhbmNlc1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsICgpID0+IHtcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nICVkIGNvbm5lY3Rpb24ocykgYmVjYXVzZSB0aGUgbmV0d29yayB3YXMgbG9zdFwiLCBPRkZMSU5FX0VWRU5UX0xJU1RFTkVSUy5sZW5ndGgpO1xuICAgICAgICBPRkZMSU5FX0VWRU5UX0xJU1RFTkVSUy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSk7XG4gICAgfSwgZmFsc2UpO1xufVxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGEgV2ViU29ja2V0LWxpa2UgaW50ZXJmYWNlIHRvIGNvbm5lY3QgdG8gYW4gRW5naW5lLklPIHNlcnZlci4gVGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBlc3RhYmxpc2hlZFxuICogd2l0aCBvbmUgb2YgdGhlIGF2YWlsYWJsZSBsb3ctbGV2ZWwgdHJhbnNwb3J0cywgbGlrZSBIVFRQIGxvbmctcG9sbGluZywgV2ViU29ja2V0IG9yIFdlYlRyYW5zcG9ydC5cbiAqXG4gKiBUaGlzIGNsYXNzIGNvbWVzIHdpdGhvdXQgdXBncmFkZSBtZWNoYW5pc20sIHdoaWNoIG1lYW5zIHRoYXQgaXQgd2lsbCBrZWVwIHRoZSBmaXJzdCBsb3ctbGV2ZWwgdHJhbnNwb3J0IHRoYXRcbiAqIHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBJbiBvcmRlciB0byBhbGxvdyB0cmVlLXNoYWtpbmcsIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzIGluY2x1ZGVkLCB0aGF0J3Mgd2h5IHRoZSBgdHJhbnNwb3J0c2Agb3B0aW9uIGlzIG1hbmRhdG9yeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgU29ja2V0V2l0aG91dFVwZ3JhZGUsIFdlYlNvY2tldCB9IGZyb20gXCJlbmdpbmUuaW8tY2xpZW50XCI7XG4gKlxuICogY29uc3Qgc29ja2V0ID0gbmV3IFNvY2tldFdpdGhvdXRVcGdyYWRlKHtcbiAqICAgdHJhbnNwb3J0czogW1dlYlNvY2tldF1cbiAqIH0pO1xuICpcbiAqIHNvY2tldC5vbihcIm9wZW5cIiwgKCkgPT4ge1xuICogICBzb2NrZXQuc2VuZChcImhlbGxvXCIpO1xuICogfSk7XG4gKlxuICogQHNlZSBTb2NrZXRXaXRoVXBncmFkZVxuICogQHNlZSBTb2NrZXRcbiAqL1xuZXhwb3J0IGNsYXNzIFNvY2tldFdpdGhvdXRVcGdyYWRlIGV4dGVuZHMgRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgLSB1cmkgb3Igb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgb3B0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJpbmFyeVR5cGUgPSBkZWZhdWx0QmluYXJ5VHlwZTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLl9wcmV2QnVmZmVyTGVuID0gMDtcbiAgICAgICAgdGhpcy5fcGluZ0ludGVydmFsID0gLTE7XG4gICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuX21heFBheWxvYWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBleHBpcmF0aW9uIHRpbWVzdGFtcCBvZiB0aGUge0BsaW5rIF9waW5nVGltZW91dFRpbWVyfSBvYmplY3QgaXMgdHJhY2tlZCwgaW4gY2FzZSB0aGUgdGltZXIgaXMgdGhyb3R0bGVkIGFuZCB0aGVcbiAgICAgICAgICogY2FsbGJhY2sgaXMgbm90IGZpcmVkIG9uIHRpbWUuIFRoaXMgY2FuIGhhcHBlbiBmb3IgZXhhbXBsZSB3aGVuIGEgbGFwdG9wIGlzIHN1c3BlbmRlZCBvciB3aGVuIGEgcGhvbmUgaXMgbG9ja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcGluZ1RpbWVvdXRUaW1lID0gSW5maW5pdHk7XG4gICAgICAgIGlmICh1cmkgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVyaSkge1xuICAgICAgICAgICAgb3B0cyA9IHVyaTtcbiAgICAgICAgICAgIHVyaSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVyaSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVXJpID0gcGFyc2UodXJpKTtcbiAgICAgICAgICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZWRVcmkuaG9zdDtcbiAgICAgICAgICAgIG9wdHMuc2VjdXJlID1cbiAgICAgICAgICAgICAgICBwYXJzZWRVcmkucHJvdG9jb2wgPT09IFwiaHR0cHNcIiB8fCBwYXJzZWRVcmkucHJvdG9jb2wgPT09IFwid3NzXCI7XG4gICAgICAgICAgICBvcHRzLnBvcnQgPSBwYXJzZWRVcmkucG9ydDtcbiAgICAgICAgICAgIGlmIChwYXJzZWRVcmkucXVlcnkpXG4gICAgICAgICAgICAgICAgb3B0cy5xdWVyeSA9IHBhcnNlZFVyaS5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICAgICAgICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZShvcHRzLmhvc3QpLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFsbFRpbWVyRnVuY3Rpb25zKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLnNlY3VyZSA9XG4gICAgICAgICAgICBudWxsICE9IG9wdHMuc2VjdXJlXG4gICAgICAgICAgICAgICAgPyBvcHRzLnNlY3VyZVxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIFwiaHR0cHM6XCIgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgICAgICAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgICAgICAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/IFwiNDQzXCIgOiBcIjgwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9XG4gICAgICAgICAgICBvcHRzLmhvc3RuYW1lIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogXCJsb2NhbGhvc3RcIik7XG4gICAgICAgIHRoaXMucG9ydCA9XG4gICAgICAgICAgICBvcHRzLnBvcnQgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgICAgICAgICAgICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5zZWN1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCI0NDNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjgwXCIpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydHMgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0c0J5TmFtZSA9IHt9O1xuICAgICAgICBvcHRzLnRyYW5zcG9ydHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0TmFtZSA9IHQucHJvdG90eXBlLm5hbWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHMucHVzaCh0cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydHNCeU5hbWVbdHJhbnNwb3J0TmFtZV0gPSB0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBwYXRoOiBcIi9lbmdpbmUuaW9cIixcbiAgICAgICAgICAgIGFnZW50OiBmYWxzZSxcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgICAgICB1cGdyYWRlOiB0cnVlLFxuICAgICAgICAgICAgdGltZXN0YW1wUGFyYW06IFwidFwiLFxuICAgICAgICAgICAgcmVtZW1iZXJVcGdyYWRlOiBmYWxzZSxcbiAgICAgICAgICAgIGFkZFRyYWlsaW5nU2xhc2g6IHRydWUsXG4gICAgICAgICAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHRydWUsXG4gICAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZToge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMTAyNCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc3BvcnRPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIGNsb3NlT25CZWZvcmV1bmxvYWQ6IGZhbHNlLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgdGhpcy5vcHRzLnBhdGggPVxuICAgICAgICAgICAgdGhpcy5vcHRzLnBhdGgucmVwbGFjZSgvXFwvJC8sIFwiXCIpICtcbiAgICAgICAgICAgICAgICAodGhpcy5vcHRzLmFkZFRyYWlsaW5nU2xhc2ggPyBcIi9cIiA6IFwiXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5xdWVyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5vcHRzLnF1ZXJ5ID0gZGVjb2RlKHRoaXMub3B0cy5xdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpdGhFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jbG9zZU9uQmVmb3JldW5sb2FkKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBjbG9zZXMgdGhlIGNvbm5lY3Rpb24gd2hlbiB0aGUgXCJiZWZvcmV1bmxvYWRcIiBldmVudCBpcyBlbWl0dGVkIGJ1dCBub3QgQ2hyb21lLiBUaGlzIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlcyBldmVyeSBicm93c2VyIGJlaGF2ZXMgdGhlIHNhbWUgKG5vIFwiZGlzY29ubmVjdFwiIGV2ZW50IGF0IHRoZSBTb2NrZXQuSU8gbGV2ZWwgd2hlbiB0aGUgcGFnZSBpc1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlZC9yZWxvYWRlZClcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmV1bmxvYWRFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbGVudGx5IGNsb3NlIHRoZSB0cmFuc3BvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCB0aGlzLl9iZWZvcmV1bmxvYWRFdmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ob3N0bmFtZSAhPT0gXCJsb2NhbGhvc3RcIikge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiYWRkaW5nIGxpc3RlbmVyIGZvciB0aGUgJ29mZmxpbmUnIGV2ZW50XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZmxpbmVFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNsb3NlKFwidHJhbnNwb3J0IGNsb3NlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIm5ldHdvcmsgY29ubmVjdGlvbiBsb3N0XCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT0ZGTElORV9FVkVOVF9MSVNURU5FUlMucHVzaCh0aGlzLl9vZmZsaW5lRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvb2tpZUphciA9IGNyZWF0ZUNvb2tpZUphcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRyYW5zcG9ydCBuYW1lXG4gICAgICogQHJldHVybiB7VHJhbnNwb3J0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3JlYXRlVHJhbnNwb3J0KG5hbWUpIHtcbiAgICAgICAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMucXVlcnkpO1xuICAgICAgICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgICAgICAgcXVlcnkuRUlPID0gcHJvdG9jb2w7XG4gICAgICAgIC8vIHRyYW5zcG9ydCBuYW1lXG4gICAgICAgIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG4gICAgICAgIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICAgICAgICBpZiAodGhpcy5pZClcbiAgICAgICAgICAgIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgc29ja2V0OiB0aGlzLFxuICAgICAgICAgICAgaG9zdG5hbWU6IHRoaXMuaG9zdG5hbWUsXG4gICAgICAgICAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLFxuICAgICAgICAgICAgcG9ydDogdGhpcy5wb3J0LFxuICAgICAgICB9LCB0aGlzLm9wdHMudHJhbnNwb3J0T3B0aW9uc1tuYW1lXSk7XG4gICAgICAgIGRlYnVnKFwib3B0aW9uczogJWpcIiwgb3B0cyk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5fdHJhbnNwb3J0c0J5TmFtZVtuYW1lXShvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgXCJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydE5hbWUgPSB0aGlzLm9wdHMucmVtZW1iZXJVcGdyYWRlICYmXG4gICAgICAgICAgICBTb2NrZXRXaXRob3V0VXBncmFkZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiZcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKFwid2Vic29ja2V0XCIpICE9PSAtMVxuICAgICAgICAgICAgPyBcIndlYnNvY2tldFwiXG4gICAgICAgICAgICA6IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB0cmFuc3BvcnQub3BlbigpO1xuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICAgICAgICBkZWJ1ZyhcInNldHRpbmcgdHJhbnNwb3J0ICVzXCIsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlc1wiLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gICAgICAgIHRyYW5zcG9ydFxuICAgICAgICAgICAgLm9uKFwiZHJhaW5cIiwgdGhpcy5fb25EcmFpbi5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLm9uKFwicGFja2V0XCIsIHRoaXMuX29uUGFja2V0LmJpbmQodGhpcykpXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLmJpbmQodGhpcykpXG4gICAgICAgICAgICAub24oXCJjbG9zZVwiLCAocmVhc29uKSA9PiB0aGlzLl9vbkNsb3NlKFwidHJhbnNwb3J0IGNsb3NlXCIsIHJlYXNvbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIGRlYnVnKFwic29ja2V0IG9wZW5cIik7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICBTb2NrZXRXaXRob3V0VXBncmFkZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPVxuICAgICAgICAgICAgXCJ3ZWJzb2NrZXRcIiA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJvcGVuXCIpO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwiY2xvc2luZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgICAgICAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImhlYXJ0YmVhdFwiKTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKEpTT04ucGFyc2UocGFja2V0LmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZFBhY2tldChcInBvbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwb25nXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJzZXJ2ZXIgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRhdGFcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcIm1lc3NhZ2VcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBoYW5kc2hha2Ugb2JqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkhhbmRzaGFrZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiaGFuZHNoYWtlXCIsIGRhdGEpO1xuICAgICAgICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICAgICAgICB0aGlzLl9waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5fcGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICAgICAgICB0aGlzLl9tYXhQYXlsb2FkID0gZGF0YS5tYXhQYXlsb2FkO1xuICAgICAgICB0aGlzLm9uT3BlbigpO1xuICAgICAgICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gICAgICAgIGlmIChcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3Jlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhbmQgcmVzZXRzIHBpbmcgdGltZW91dCB0aW1lciBiYXNlZCBvbiBzZXJ2ZXIgcGluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldFBpbmdUaW1lb3V0KCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dEZuKHRoaXMuX3BpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMuX3BpbmdJbnRlcnZhbCArIHRoaXMuX3BpbmdUaW1lb3V0O1xuICAgICAgICB0aGlzLl9waW5nVGltZW91dFRpbWUgPSBEYXRlLm5vdygpICsgZGVsYXk7XG4gICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0VGltZXIgPSB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vbkNsb3NlKFwicGluZyB0aW1lb3V0XCIpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9waW5nVGltZW91dFRpbWVyLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uRHJhaW4oKSB7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMuX3ByZXZCdWZmZXJMZW4pO1xuICAgICAgICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gICAgICAgIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAgICAgICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICAgICAgICB0aGlzLl9wcmV2QnVmZmVyTGVuID0gMDtcbiAgICAgICAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRyYWluXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZsdXNoKCkge1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICAgICAgICAgIXRoaXMudXBncmFkaW5nICYmXG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcGFja2V0cyA9IHRoaXMuX2dldFdyaXRhYmxlUGFja2V0cygpO1xuICAgICAgICAgICAgZGVidWcoXCJmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldFwiLCBwYWNrZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHBhY2tldHMpO1xuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgICAgICAgICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgICAgICAgICB0aGlzLl9wcmV2QnVmZmVyTGVuID0gcGFja2V0cy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImZsdXNoXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGUgZW5jb2RlZCBzaXplIG9mIHRoZSB3cml0ZUJ1ZmZlciBpcyBiZWxvdyB0aGUgbWF4UGF5bG9hZCB2YWx1ZSBzZW50IGJ5IHRoZSBzZXJ2ZXIgKG9ubHkgZm9yIEhUVFBcbiAgICAgKiBsb25nLXBvbGxpbmcpXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRXcml0YWJsZVBhY2tldHMoKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZENoZWNrUGF5bG9hZFNpemUgPSB0aGlzLl9tYXhQYXlsb2FkICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5uYW1lID09PSBcInBvbGxpbmdcIiAmJlxuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGggPiAxO1xuICAgICAgICBpZiAoIXNob3VsZENoZWNrUGF5bG9hZFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXlsb2FkU2l6ZSA9IDE7IC8vIGZpcnN0IHBhY2tldCB0eXBlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMud3JpdGVCdWZmZXJbaV0uZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFNpemUgKz0gYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gMCAmJiBwYXlsb2FkU2l6ZSA+IHRoaXMuX21heFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIm9ubHkgc2VuZCAlZCBvdXQgb2YgJWQgcGFja2V0c1wiLCBpLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXIuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSAyOyAvLyBzZXBhcmF0b3IgKyBwYWNrZXQgdHlwZVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwicGF5bG9hZCBzaXplIGlzICVkIChtYXg6ICVkKVwiLCBwYXlsb2FkU2l6ZSwgdGhpcy5fbWF4UGF5bG9hZCk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaGVhcnRiZWF0IHRpbWVyIGhhcyBleHBpcmVkIGJ1dCB0aGUgc29ja2V0IGhhcyBub3QgeWV0IGJlZW4gbm90aWZpZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBwcml2YXRlIGZvciBub3cgYmVjYXVzZSBpdCBkb2VzIG5vdCByZWFsbHkgZml0IHRoZSBXZWJTb2NrZXQgQVBJLCBidXQgaWYgd2UgcHV0IGl0IGluIHRoZVxuICAgICAqIGB3cml0ZSgpYCBtZXRob2QgdGhlbiB0aGUgbWVzc2FnZSB3b3VsZCBub3QgYmUgYnVmZmVyZWQgYnkgdGhlIFNvY2tldC5JTyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgLyogcHJpdmF0ZSAqLyBfaGFzUGluZ0V4cGlyZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGluZ1RpbWVvdXRUaW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IGhhc0V4cGlyZWQgPSBEYXRlLm5vdygpID4gdGhpcy5fcGluZ1RpbWVvdXRUaW1lO1xuICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgZGVidWcoXCJ0aHJvdHRsZWQgdGltZXIgZGV0ZWN0ZWQsIHNjaGVkdWxpbmcgY29ubmVjdGlvbiBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0VGltZSA9IDA7XG4gICAgICAgICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25DbG9zZShcInBpbmcgdGltZW91dFwiKTtcbiAgICAgICAgICAgIH0sIHRoaXMuc2V0VGltZW91dEZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzRXhwaXJlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICB3cml0ZShtc2csIG9wdGlvbnMsIGZuKSB7XG4gICAgICAgIHRoaXMuX3NlbmRQYWNrZXQoXCJtZXNzYWdlXCIsIG1zZywgb3B0aW9ucywgZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlLiBBbGlhcyBvZiB7QGxpbmsgU29ja2V0I3dyaXRlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgc2VuZChtc2csIG9wdGlvbnMsIGZuKSB7XG4gICAgICAgIHRoaXMuX3NlbmRQYWNrZXQoXCJtZXNzYWdlXCIsIG1zZywgb3B0aW9ucywgZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZTogcGFja2V0IHR5cGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZW5kUGFja2V0KHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBmbiA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjbG9zaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0Q3JlYXRlXCIsIHBhY2tldCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICAgICAgICBpZiAoZm4pXG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJmbHVzaFwiLCBmbik7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2xvc2UoXCJmb3JjZWQgY2xvc2VcIik7XG4gICAgICAgICAgICBkZWJ1ZyhcInNvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2VcIik7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwQW5kQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9mZihcInVwZ3JhZGVcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwidXBncmFkZUVycm9yXCIsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB3YWl0Rm9yVXBncmFkZSA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJ1cGdyYWRlXCIsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJ1cGdyYWRlRXJyb3JcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgXCJvcGVuXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zaW5nXCI7XG4gICAgICAgICAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJkcmFpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25FcnJvcihlcnIpIHtcbiAgICAgICAgZGVidWcoXCJzb2NrZXQgZXJyb3IgJWpcIiwgZXJyKTtcbiAgICAgICAgU29ja2V0V2l0aG91dFVwZ3JhZGUucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdHMudHJ5QWxsVHJhbnNwb3J0cyAmJlxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuaW5nXCIpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJ5aW5nIG5leHQgdHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3BlbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgdGhpcy5fb25DbG9zZShcInRyYW5zcG9ydCBlcnJvclwiLCBlcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwiY2xvc2luZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgICAgICAgICAvLyBjbGVhciB0aW1lcnNcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0Rm4odGhpcy5fcGluZ1RpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycyhcImNsb3NlXCIpO1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBpZiAod2l0aEV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JlZm9yZXVubG9hZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCB0aGlzLl9iZWZvcmV1bmxvYWRFdmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZsaW5lRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpID0gT0ZGTElORV9FVkVOVF9MSVNURU5FUlMuaW5kZXhPZih0aGlzLl9vZmZsaW5lRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJyZW1vdmluZyBsaXN0ZW5lciBmb3IgdGhlICdvZmZsaW5lJyBldmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9GRkxJTkVfRVZFTlRfTElTVEVORVJTLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICAgICAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgICAgICAgICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjbG9zZVwiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgICAgICAgICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgICAgICB0aGlzLl9wcmV2QnVmZmVyTGVuID0gMDtcbiAgICAgICAgfVxuICAgIH1cbn1cblNvY2tldFdpdGhvdXRVcGdyYWRlLnByb3RvY29sID0gcHJvdG9jb2w7XG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYSBXZWJTb2NrZXQtbGlrZSBpbnRlcmZhY2UgdG8gY29ubmVjdCB0byBhbiBFbmdpbmUuSU8gc2VydmVyLiBUaGUgY29ubmVjdGlvbiB3aWxsIGJlIGVzdGFibGlzaGVkXG4gKiB3aXRoIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGxvdy1sZXZlbCB0cmFuc3BvcnRzLCBsaWtlIEhUVFAgbG9uZy1wb2xsaW5nLCBXZWJTb2NrZXQgb3IgV2ViVHJhbnNwb3J0LlxuICpcbiAqIFRoaXMgY2xhc3MgY29tZXMgd2l0aCBhbiB1cGdyYWRlIG1lY2hhbmlzbSwgd2hpY2ggbWVhbnMgdGhhdCBvbmNlIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIHdpdGggdGhlIGZpcnN0XG4gKiBsb3ctbGV2ZWwgdHJhbnNwb3J0LCBpdCB3aWxsIHRyeSB0byB1cGdyYWRlIHRvIGEgYmV0dGVyIHRyYW5zcG9ydC5cbiAqXG4gKiBJbiBvcmRlciB0byBhbGxvdyB0cmVlLXNoYWtpbmcsIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzIGluY2x1ZGVkLCB0aGF0J3Mgd2h5IHRoZSBgdHJhbnNwb3J0c2Agb3B0aW9uIGlzIG1hbmRhdG9yeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgU29ja2V0V2l0aFVwZ3JhZGUsIFdlYlNvY2tldCB9IGZyb20gXCJlbmdpbmUuaW8tY2xpZW50XCI7XG4gKlxuICogY29uc3Qgc29ja2V0ID0gbmV3IFNvY2tldFdpdGhVcGdyYWRlKHtcbiAqICAgdHJhbnNwb3J0czogW1dlYlNvY2tldF1cbiAqIH0pO1xuICpcbiAqIHNvY2tldC5vbihcIm9wZW5cIiwgKCkgPT4ge1xuICogICBzb2NrZXQuc2VuZChcImhlbGxvXCIpO1xuICogfSk7XG4gKlxuICogQHNlZSBTb2NrZXRXaXRob3V0VXBncmFkZVxuICogQHNlZSBTb2NrZXRcbiAqL1xuZXhwb3J0IGNsYXNzIFNvY2tldFdpdGhVcGdyYWRlIGV4dGVuZHMgU29ja2V0V2l0aG91dFVwZ3JhZGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl91cGdyYWRlcyA9IFtdO1xuICAgIH1cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIHN1cGVyLm9uT3BlbigpO1xuICAgICAgICBpZiAoXCJvcGVuXCIgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLm9wdHMudXBncmFkZSkge1xuICAgICAgICAgICAgZGVidWcoXCJzdGFydGluZyB1cGdyYWRlIHByb2Jlc1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdXBncmFkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9iZSh0aGlzLl91cGdyYWRlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0cmFuc3BvcnQgbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Byb2JlKG5hbWUpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICAgICAgICBsZXQgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSk7XG4gICAgICAgIGxldCBmYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgU29ja2V0V2l0aG91dFVwZ3JhZGUucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG9uVHJhbnNwb3J0T3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmYWlsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiBcInBpbmdcIiwgZGF0YTogXCJwcm9iZVwiIH1dKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vbmNlKFwicGFja2V0XCIsIChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKFwicG9uZ1wiID09PSBtc2cudHlwZSAmJiBcInByb2JlXCIgPT09IG1zZy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGluZ1wiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYW5zcG9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgU29ja2V0V2l0aG91dFVwZ3JhZGUucHJpb3JXZWJzb2NrZXRTdWNjZXNzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2Vic29ja2V0XCIgPT09IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucGF1c2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZhaWxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJjbG9zZWRcIiA9PT0gdGhpcy5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwidXBncmFkZVwiIH1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwidXBncmFkZVwiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcInByb2JlIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJ1cGdyYWRlRXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuICAgICAgICAgICAgaWYgKGZhaWxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICAgICAgICBjb25zdCBvbmVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJwcm9iZSBlcnJvcjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGVFcnJvclwiLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKSB7XG4gICAgICAgICAgICBvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgICAgICAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICAgICAgICAgIG9uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gICAgICAgIGZ1bmN0aW9uIG9udXBncmFkZSh0bykge1xuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICAgICAgICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwib3BlblwiLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25lcnJvcik7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwiY2xvc2VcIiwgb25jbG9zZSk7XG4gICAgICAgICAgICB0aGlzLm9mZihcInVwZ3JhZGluZ1wiLCBvbnVwZ3JhZGUpO1xuICAgICAgICB9O1xuICAgICAgICB0cmFuc3BvcnQub25jZShcIm9wZW5cIiwgb25UcmFuc3BvcnRPcGVuKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJlcnJvclwiLCBvbmVycm9yKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJjbG9zZVwiLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgdGhpcy5vbmNlKFwiY2xvc2VcIiwgb25jbG9zZSk7XG4gICAgICAgIHRoaXMub25jZShcInVwZ3JhZGluZ1wiLCBvbnVwZ3JhZGUpO1xuICAgICAgICBpZiAodGhpcy5fdXBncmFkZXMuaW5kZXhPZihcIndlYnRyYW5zcG9ydFwiKSAhPT0gLTEgJiZcbiAgICAgICAgICAgIG5hbWUgIT09IFwid2VidHJhbnNwb3J0XCIpIHtcbiAgICAgICAgICAgIC8vIGZhdm9yIFdlYlRyYW5zcG9ydFxuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5vcGVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vcGVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25IYW5kc2hha2UoZGF0YSkge1xuICAgICAgICB0aGlzLl91cGdyYWRlcyA9IHRoaXMuX2ZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICAgICAgICBzdXBlci5vbkhhbmRzaGFrZShkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB1cGdyYWRlcyAtIHNlcnZlciB1cGdyYWRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbHRlclVwZ3JhZGVzKHVwZ3JhZGVzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cGdyYWRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKH50aGlzLnRyYW5zcG9ydHMuaW5kZXhPZih1cGdyYWRlc1tpXSkpXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYSBXZWJTb2NrZXQtbGlrZSBpbnRlcmZhY2UgdG8gY29ubmVjdCB0byBhbiBFbmdpbmUuSU8gc2VydmVyLiBUaGUgY29ubmVjdGlvbiB3aWxsIGJlIGVzdGFibGlzaGVkXG4gKiB3aXRoIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGxvdy1sZXZlbCB0cmFuc3BvcnRzLCBsaWtlIEhUVFAgbG9uZy1wb2xsaW5nLCBXZWJTb2NrZXQgb3IgV2ViVHJhbnNwb3J0LlxuICpcbiAqIFRoaXMgY2xhc3MgY29tZXMgd2l0aCBhbiB1cGdyYWRlIG1lY2hhbmlzbSwgd2hpY2ggbWVhbnMgdGhhdCBvbmNlIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIHdpdGggdGhlIGZpcnN0XG4gKiBsb3ctbGV2ZWwgdHJhbnNwb3J0LCBpdCB3aWxsIHRyeSB0byB1cGdyYWRlIHRvIGEgYmV0dGVyIHRyYW5zcG9ydC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgU29ja2V0IH0gZnJvbSBcImVuZ2luZS5pby1jbGllbnRcIjtcbiAqXG4gKiBjb25zdCBzb2NrZXQgPSBuZXcgU29ja2V0KCk7XG4gKlxuICogc29ja2V0Lm9uKFwib3BlblwiLCAoKSA9PiB7XG4gKiAgIHNvY2tldC5zZW5kKFwiaGVsbG9cIik7XG4gKiB9KTtcbiAqXG4gKiBAc2VlIFNvY2tldFdpdGhvdXRVcGdyYWRlXG4gKiBAc2VlIFNvY2tldFdpdGhVcGdyYWRlXG4gKi9cbmV4cG9ydCBjbGFzcyBTb2NrZXQgZXh0ZW5kcyBTb2NrZXRXaXRoVXBncmFkZSB7XG4gICAgY29uc3RydWN0b3IodXJpLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgbyA9IHR5cGVvZiB1cmkgPT09IFwib2JqZWN0XCIgPyB1cmkgOiBvcHRzO1xuICAgICAgICBpZiAoIW8udHJhbnNwb3J0cyB8fFxuICAgICAgICAgICAgKG8udHJhbnNwb3J0cyAmJiB0eXBlb2Ygby50cmFuc3BvcnRzWzBdID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgby50cmFuc3BvcnRzID0gKG8udHJhbnNwb3J0cyB8fCBbXCJwb2xsaW5nXCIsIFwid2Vic29ja2V0XCIsIFwid2VidHJhbnNwb3J0XCJdKVxuICAgICAgICAgICAgICAgIC5tYXAoKHRyYW5zcG9ydE5hbWUpID0+IERFRkFVTFRfVFJBTlNQT1JUU1t0cmFuc3BvcnROYW1lXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh0KSA9PiAhIXQpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHVyaSwgbyk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInRyYW5zcG9ydHMiLCJERUZBVUxUX1RSQU5TUE9SVFMiLCJpbnN0YWxsVGltZXJGdW5jdGlvbnMiLCJieXRlTGVuZ3RoIiwiZGVjb2RlIiwicGFyc2UiLCJFbWl0dGVyIiwicHJvdG9jb2wiLCJjcmVhdGVDb29raWVKYXIiLCJkZWZhdWx0QmluYXJ5VHlwZSIsIm5leHRUaWNrIiwiZGVidWdNb2R1bGUiLCJkZWJ1ZyIsIndpdGhFdmVudExpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiT0ZGTElORV9FVkVOVF9MSVNURU5FUlMiLCJsZW5ndGgiLCJmb3JFYWNoIiwibGlzdGVuZXIiLCJTb2NrZXRXaXRob3V0VXBncmFkZSIsImNvbnN0cnVjdG9yIiwidXJpIiwib3B0cyIsImJpbmFyeVR5cGUiLCJ3cml0ZUJ1ZmZlciIsIl9wcmV2QnVmZmVyTGVuIiwiX3BpbmdJbnRlcnZhbCIsIl9waW5nVGltZW91dCIsIl9tYXhQYXlsb2FkIiwiX3BpbmdUaW1lb3V0VGltZSIsIkluZmluaXR5IiwicGFyc2VkVXJpIiwiaG9zdG5hbWUiLCJob3N0Iiwic2VjdXJlIiwicG9ydCIsInF1ZXJ5IiwibG9jYXRpb24iLCJfdHJhbnNwb3J0c0J5TmFtZSIsInQiLCJ0cmFuc3BvcnROYW1lIiwicHJvdG90eXBlIiwibmFtZSIsInB1c2giLCJPYmplY3QiLCJhc3NpZ24iLCJwYXRoIiwiYWdlbnQiLCJ3aXRoQ3JlZGVudGlhbHMiLCJ1cGdyYWRlIiwidGltZXN0YW1wUGFyYW0iLCJyZW1lbWJlclVwZ3JhZGUiLCJhZGRUcmFpbGluZ1NsYXNoIiwicmVqZWN0VW5hdXRob3JpemVkIiwicGVyTWVzc2FnZURlZmxhdGUiLCJ0aHJlc2hvbGQiLCJ0cmFuc3BvcnRPcHRpb25zIiwiY2xvc2VPbkJlZm9yZXVubG9hZCIsInJlcGxhY2UiLCJfYmVmb3JldW5sb2FkRXZlbnRMaXN0ZW5lciIsInRyYW5zcG9ydCIsInJlbW92ZUFsbExpc3RlbmVycyIsImNsb3NlIiwiX29mZmxpbmVFdmVudExpc3RlbmVyIiwiX29uQ2xvc2UiLCJkZXNjcmlwdGlvbiIsIl9jb29raWVKYXIiLCJfb3BlbiIsImNyZWF0ZVRyYW5zcG9ydCIsIkVJTyIsImlkIiwic2lkIiwic29ja2V0Iiwic2V0VGltZW91dEZuIiwiZW1pdFJlc2VydmVkIiwicHJpb3JXZWJzb2NrZXRTdWNjZXNzIiwiaW5kZXhPZiIsInJlYWR5U3RhdGUiLCJvcGVuIiwic2V0VHJhbnNwb3J0Iiwib24iLCJfb25EcmFpbiIsImJpbmQiLCJfb25QYWNrZXQiLCJfb25FcnJvciIsInJlYXNvbiIsIm9uT3BlbiIsImZsdXNoIiwicGFja2V0IiwidHlwZSIsImRhdGEiLCJvbkhhbmRzaGFrZSIsIkpTT04iLCJfc2VuZFBhY2tldCIsIl9yZXNldFBpbmdUaW1lb3V0IiwiZXJyIiwiRXJyb3IiLCJjb2RlIiwicGluZ0ludGVydmFsIiwicGluZ1RpbWVvdXQiLCJtYXhQYXlsb2FkIiwiY2xlYXJUaW1lb3V0Rm4iLCJfcGluZ1RpbWVvdXRUaW1lciIsImRlbGF5IiwiRGF0ZSIsIm5vdyIsImF1dG9VbnJlZiIsInVucmVmIiwic3BsaWNlIiwid3JpdGFibGUiLCJ1cGdyYWRpbmciLCJwYWNrZXRzIiwiX2dldFdyaXRhYmxlUGFja2V0cyIsInNlbmQiLCJzaG91bGRDaGVja1BheWxvYWRTaXplIiwicGF5bG9hZFNpemUiLCJpIiwic2xpY2UiLCJfaGFzUGluZ0V4cGlyZWQiLCJoYXNFeHBpcmVkIiwid3JpdGUiLCJtc2ciLCJvcHRpb25zIiwiZm4iLCJ1bmRlZmluZWQiLCJjb21wcmVzcyIsIm9uY2UiLCJjbGVhbnVwQW5kQ2xvc2UiLCJvZmYiLCJ3YWl0Rm9yVXBncmFkZSIsInRyeUFsbFRyYW5zcG9ydHMiLCJzaGlmdCIsIlNvY2tldFdpdGhVcGdyYWRlIiwiYXJndW1lbnRzIiwiX3VwZ3JhZGVzIiwiX3Byb2JlIiwiZmFpbGVkIiwib25UcmFuc3BvcnRPcGVuIiwicGF1c2UiLCJjbGVhbnVwIiwiZnJlZXplVHJhbnNwb3J0Iiwib25lcnJvciIsImVycm9yIiwib25UcmFuc3BvcnRDbG9zZSIsIm9uY2xvc2UiLCJvbnVwZ3JhZGUiLCJ0byIsInJlbW92ZUxpc3RlbmVyIiwiX2ZpbHRlclVwZ3JhZGVzIiwidXBncmFkZXMiLCJmaWx0ZXJlZFVwZ3JhZGVzIiwiU29ja2V0IiwibyIsIm1hcCIsImZpbHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/socket.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/transport.js":
/*!*********************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/transport.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transport: () => (/* binding */ Transport),\n/* harmony export */   TransportError: () => (/* binding */ TransportError)\n/* harmony export */ });\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine.io-parser */ \"(ssr)/../node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @socket.io/component-emitter */ \"(ssr)/../node_modules/@socket.io/component-emitter/lib/esm/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/util.js\");\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contrib/parseqs.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/contrib/parseqs.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! debug */ \"(ssr)/../node_modules/engine.io-client/node_modules/debug/src/index.js\");\n\n\n\n\n // debug()\nconst debug = debug__WEBPACK_IMPORTED_MODULE_4__(\"engine.io-client:transport\"); // debug()\nclass TransportError extends Error {\n    constructor(reason, description, context){\n        super(reason);\n        this.description = description;\n        this.context = context;\n        this.type = \"TransportError\";\n    }\n}\nclass Transport extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__.Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */ constructor(opts){\n        super();\n        this.writable = false;\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.socket = opts.socket;\n        this.supportsBinary = !opts.forceBase64;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */ onError(reason, description, context) {\n        super.emitReserved(\"error\", new TransportError(reason, description, context));\n        return this;\n    }\n    /**\n     * Opens the transport.\n     */ open() {\n        this.readyState = \"opening\";\n        this.doOpen();\n        return this;\n    }\n    /**\n     * Closes the transport.\n     */ close() {\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     */ send(packets) {\n        if (this.readyState === \"open\") {\n            this.write(packets);\n        } else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n            debug(\"transport is not open, discarding packets\");\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @protected\n     */ onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emitReserved(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @protected\n     */ onData(data) {\n        const packet = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_0__.decodePacket)(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @protected\n     */ onPacket(packet) {\n        super.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @protected\n     */ onClose(details) {\n        this.readyState = \"closed\";\n        super.emitReserved(\"close\", details);\n    }\n    /**\n     * Pauses the transport, in order not to lose packets during an upgrade.\n     *\n     * @param onPause\n     */ pause(onPause) {}\n    createUri(schema, query = {}) {\n        return schema + \"://\" + this._hostname() + this._port() + this.opts.path + this._query(query);\n    }\n    _hostname() {\n        const hostname = this.opts.hostname;\n        return hostname.indexOf(\":\") === -1 ? hostname : \"[\" + hostname + \"]\";\n    }\n    _port() {\n        if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {\n            return \":\" + this.opts.port;\n        } else {\n            return \"\";\n        }\n    }\n    _query(query) {\n        const encodedQuery = (0,_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_3__.encode)(query);\n        return encodedQuery.length ? \"?\" + encodedQuery : \"\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3RyYW5zcG9ydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWdEO0FBQ087QUFDTDtBQUNKO0FBQ2QsQ0FBQyxVQUFVO0FBQzNDLE1BQU1LLFFBQVFELGtDQUFXQSxDQUFDLCtCQUErQixVQUFVO0FBQzVELE1BQU1FLHVCQUF1QkM7SUFDaENDLFlBQVlDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxPQUFPLENBQUU7UUFDdEMsS0FBSyxDQUFDRjtRQUNOLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTUMsa0JBQWtCWixpRUFBT0E7SUFDbEM7Ozs7O0tBS0MsR0FDRE8sWUFBWU0sSUFBSSxDQUFFO1FBQ2QsS0FBSztRQUNMLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCYiwrREFBcUJBLENBQUMsSUFBSSxFQUFFWTtRQUM1QixJQUFJLENBQUNBLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNFLEtBQUssR0FBR0YsS0FBS0UsS0FBSztRQUN2QixJQUFJLENBQUNDLE1BQU0sR0FBR0gsS0FBS0csTUFBTTtRQUN6QixJQUFJLENBQUNDLGNBQWMsR0FBRyxDQUFDSixLQUFLSyxXQUFXO0lBQzNDO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDREMsUUFBUVgsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLE9BQU8sRUFBRTtRQUNsQyxLQUFLLENBQUNVLGFBQWEsU0FBUyxJQUFJZixlQUFlRyxRQUFRQyxhQUFhQztRQUNwRSxPQUFPLElBQUk7SUFDZjtJQUNBOztLQUVDLEdBQ0RXLE9BQU87UUFDSCxJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLE1BQU07UUFDWCxPQUFPLElBQUk7SUFDZjtJQUNBOztLQUVDLEdBQ0RDLFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQ0YsVUFBVSxLQUFLLGFBQWEsSUFBSSxDQUFDQSxVQUFVLEtBQUssUUFBUTtZQUM3RCxJQUFJLENBQUNHLE9BQU87WUFDWixJQUFJLENBQUNDLE9BQU87UUFDaEI7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBOzs7O0tBSUMsR0FDREMsS0FBS0MsT0FBTyxFQUFFO1FBQ1YsSUFBSSxJQUFJLENBQUNOLFVBQVUsS0FBSyxRQUFRO1lBQzVCLElBQUksQ0FBQ08sS0FBSyxDQUFDRDtRQUNmLE9BQ0s7WUFDRCwyRkFBMkY7WUFDM0Z4QixNQUFNO1FBQ1Y7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRDBCLFNBQVM7UUFDTCxJQUFJLENBQUNSLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNSLFFBQVEsR0FBRztRQUNoQixLQUFLLENBQUNNLGFBQWE7SUFDdkI7SUFDQTs7Ozs7S0FLQyxHQUNEVyxPQUFPQyxJQUFJLEVBQUU7UUFDVCxNQUFNQyxTQUFTbEMsOERBQVlBLENBQUNpQyxNQUFNLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ2tCLFVBQVU7UUFDeEQsSUFBSSxDQUFDQyxRQUFRLENBQUNGO0lBQ2xCO0lBQ0E7Ozs7S0FJQyxHQUNERSxTQUFTRixNQUFNLEVBQUU7UUFDYixLQUFLLENBQUNiLGFBQWEsVUFBVWE7SUFDakM7SUFDQTs7OztLQUlDLEdBQ0RQLFFBQVFVLE9BQU8sRUFBRTtRQUNiLElBQUksQ0FBQ2QsVUFBVSxHQUFHO1FBQ2xCLEtBQUssQ0FBQ0YsYUFBYSxTQUFTZ0I7SUFDaEM7SUFDQTs7OztLQUlDLEdBQ0RDLE1BQU1DLE9BQU8sRUFBRSxDQUFFO0lBQ2pCQyxVQUFVQyxNQUFNLEVBQUV6QixRQUFRLENBQUMsQ0FBQyxFQUFFO1FBQzFCLE9BQVF5QixTQUNKLFFBQ0EsSUFBSSxDQUFDQyxTQUFTLEtBQ2QsSUFBSSxDQUFDQyxLQUFLLEtBQ1YsSUFBSSxDQUFDN0IsSUFBSSxDQUFDOEIsSUFBSSxHQUNkLElBQUksQ0FBQ0MsTUFBTSxDQUFDN0I7SUFDcEI7SUFDQTBCLFlBQVk7UUFDUixNQUFNSSxXQUFXLElBQUksQ0FBQ2hDLElBQUksQ0FBQ2dDLFFBQVE7UUFDbkMsT0FBT0EsU0FBU0MsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJRCxXQUFXLE1BQU1BLFdBQVc7SUFDdEU7SUFDQUgsUUFBUTtRQUNKLElBQUksSUFBSSxDQUFDN0IsSUFBSSxDQUFDa0MsSUFBSSxJQUNiLEtBQUssQ0FBQ2xDLElBQUksQ0FBQ21DLE1BQU0sSUFBSUMsT0FBTyxJQUFJLENBQUNwQyxJQUFJLENBQUNrQyxJQUFJLEtBQUssUUFDM0MsQ0FBQyxJQUFJLENBQUNsQyxJQUFJLENBQUNtQyxNQUFNLElBQUlDLE9BQU8sSUFBSSxDQUFDcEMsSUFBSSxDQUFDa0MsSUFBSSxNQUFNLEVBQUUsR0FBSTtZQUMzRCxPQUFPLE1BQU0sSUFBSSxDQUFDbEMsSUFBSSxDQUFDa0MsSUFBSTtRQUMvQixPQUNLO1lBQ0QsT0FBTztRQUNYO0lBQ0o7SUFDQUgsT0FBTzdCLEtBQUssRUFBRTtRQUNWLE1BQU1tQyxlQUFlaEQsMkRBQU1BLENBQUNhO1FBQzVCLE9BQU9tQyxhQUFhQyxNQUFNLEdBQUcsTUFBTUQsZUFBZTtJQUN0RDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdHNhcHAtYWktY3JtLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS1kZWJ1Zy90cmFuc3BvcnQuanM/NWU1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWNvZGVQYWNrZXQgfSBmcm9tIFwiZW5naW5lLmlvLXBhcnNlclwiO1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gXCJAc29ja2V0LmlvL2NvbXBvbmVudC1lbWl0dGVyXCI7XG5pbXBvcnQgeyBpbnN0YWxsVGltZXJGdW5jdGlvbnMgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGUgfSBmcm9tIFwiLi9jb250cmliL3BhcnNlcXMuanNcIjtcbmltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjsgLy8gZGVidWcoKVxuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImVuZ2luZS5pby1jbGllbnQ6dHJhbnNwb3J0XCIpOyAvLyBkZWJ1ZygpXG5leHBvcnQgY2xhc3MgVHJhbnNwb3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVhc29uLCBkZXNjcmlwdGlvbiwgY29udGV4dCkge1xuICAgICAgICBzdXBlcihyZWFzb24pO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiVHJhbnNwb3J0RXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHJhbnNwb3J0IGV4dGVuZHMgRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBpbnN0YWxsVGltZXJGdW5jdGlvbnModGhpcywgb3B0cyk7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICAgICAgICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICAgICAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gIW9wdHMuZm9yY2VCYXNlNjQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSBjb250ZXh0IC0gdGhlIGVycm9yIGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkVycm9yKHJlYXNvbiwgZGVzY3JpcHRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgbmV3IFRyYW5zcG9ydEVycm9yKHJlYXNvbiwgZGVzY3JpcHRpb24sIGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gICAgICovXG4gICAgb3BlbigpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7XG4gICAgICAgIHRoaXMuZG9PcGVuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuaW5nXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAgICAgKi9cbiAgICBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGhhcHBlbiBpZiB0aGUgdHJhbnNwb3J0IHdhcyBzaWxlbnRseSBjbG9zZWQgaW4gdGhlIGJlZm9yZXVubG9hZCBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBpcyBub3Qgb3BlbiwgZGlzY2FyZGluZyBwYWNrZXRzXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIG9wZW5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwib3BlblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IGRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUGFja2V0KHBhY2tldCkge1xuICAgICAgICBzdXBlci5lbWl0UmVzZXJ2ZWQoXCJwYWNrZXRcIiwgcGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25DbG9zZShkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImNsb3NlXCIsIGRldGFpbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHRyYW5zcG9ydCwgaW4gb3JkZXIgbm90IHRvIGxvc2UgcGFja2V0cyBkdXJpbmcgYW4gdXBncmFkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvblBhdXNlXG4gICAgICovXG4gICAgcGF1c2Uob25QYXVzZSkgeyB9XG4gICAgY3JlYXRlVXJpKHNjaGVtYSwgcXVlcnkgPSB7fSkge1xuICAgICAgICByZXR1cm4gKHNjaGVtYSArXG4gICAgICAgICAgICBcIjovL1wiICtcbiAgICAgICAgICAgIHRoaXMuX2hvc3RuYW1lKCkgK1xuICAgICAgICAgICAgdGhpcy5fcG9ydCgpICtcbiAgICAgICAgICAgIHRoaXMub3B0cy5wYXRoICtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXJ5KHF1ZXJ5KSk7XG4gICAgfVxuICAgIF9ob3N0bmFtZSgpIHtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSB0aGlzLm9wdHMuaG9zdG5hbWU7XG4gICAgICAgIHJldHVybiBob3N0bmFtZS5pbmRleE9mKFwiOlwiKSA9PT0gLTEgPyBob3N0bmFtZSA6IFwiW1wiICsgaG9zdG5hbWUgKyBcIl1cIjtcbiAgICB9XG4gICAgX3BvcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMucG9ydCAmJlxuICAgICAgICAgICAgKCh0aGlzLm9wdHMuc2VjdXJlICYmIE51bWJlcih0aGlzLm9wdHMucG9ydCAhPT0gNDQzKSkgfHxcbiAgICAgICAgICAgICAgICAoIXRoaXMub3B0cy5zZWN1cmUgJiYgTnVtYmVyKHRoaXMub3B0cy5wb3J0KSAhPT0gODApKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiOlwiICsgdGhpcy5vcHRzLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcXVlcnkocXVlcnkpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlZFF1ZXJ5ID0gZW5jb2RlKHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIGVuY29kZWRRdWVyeS5sZW5ndGggPyBcIj9cIiArIGVuY29kZWRRdWVyeSA6IFwiXCI7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbImRlY29kZVBhY2tldCIsIkVtaXR0ZXIiLCJpbnN0YWxsVGltZXJGdW5jdGlvbnMiLCJlbmNvZGUiLCJkZWJ1Z01vZHVsZSIsImRlYnVnIiwiVHJhbnNwb3J0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwicmVhc29uIiwiZGVzY3JpcHRpb24iLCJjb250ZXh0IiwidHlwZSIsIlRyYW5zcG9ydCIsIm9wdHMiLCJ3cml0YWJsZSIsInF1ZXJ5Iiwic29ja2V0Iiwic3VwcG9ydHNCaW5hcnkiLCJmb3JjZUJhc2U2NCIsIm9uRXJyb3IiLCJlbWl0UmVzZXJ2ZWQiLCJvcGVuIiwicmVhZHlTdGF0ZSIsImRvT3BlbiIsImNsb3NlIiwiZG9DbG9zZSIsIm9uQ2xvc2UiLCJzZW5kIiwicGFja2V0cyIsIndyaXRlIiwib25PcGVuIiwib25EYXRhIiwiZGF0YSIsInBhY2tldCIsImJpbmFyeVR5cGUiLCJvblBhY2tldCIsImRldGFpbHMiLCJwYXVzZSIsIm9uUGF1c2UiLCJjcmVhdGVVcmkiLCJzY2hlbWEiLCJfaG9zdG5hbWUiLCJfcG9ydCIsInBhdGgiLCJfcXVlcnkiLCJob3N0bmFtZSIsImluZGV4T2YiLCJwb3J0Iiwic2VjdXJlIiwiTnVtYmVyIiwiZW5jb2RlZFF1ZXJ5IiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/transport.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/index.js":
/*!****************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/transports/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transports: () => (/* binding */ transports)\n/* harmony export */ });\n/* harmony import */ var _polling_xhr_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polling-xhr.node.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.node.js\");\n/* harmony import */ var _websocket_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./websocket.node.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/websocket.node.js\");\n/* harmony import */ var _webtransport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webtransport.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/webtransport.js\");\n\n\n\nconst transports = {\n    websocket: _websocket_node_js__WEBPACK_IMPORTED_MODULE_1__.WS,\n    webtransport: _webtransport_js__WEBPACK_IMPORTED_MODULE_2__.WT,\n    polling: _polling_xhr_node_js__WEBPACK_IMPORTED_MODULE_0__.XHR\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3RyYW5zcG9ydHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0QztBQUNIO0FBQ0Y7QUFDaEMsTUFBTUcsYUFBYTtJQUN0QkMsV0FBV0gsa0RBQUVBO0lBQ2JJLGNBQWNILGdEQUFFQTtJQUNoQkksU0FBU04scURBQUdBO0FBQ2hCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3RyYW5zcG9ydHMvaW5kZXguanM/ZjRmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBYSFIgfSBmcm9tIFwiLi9wb2xsaW5nLXhoci5ub2RlLmpzXCI7XG5pbXBvcnQgeyBXUyB9IGZyb20gXCIuL3dlYnNvY2tldC5ub2RlLmpzXCI7XG5pbXBvcnQgeyBXVCB9IGZyb20gXCIuL3dlYnRyYW5zcG9ydC5qc1wiO1xuZXhwb3J0IGNvbnN0IHRyYW5zcG9ydHMgPSB7XG4gICAgd2Vic29ja2V0OiBXUyxcbiAgICB3ZWJ0cmFuc3BvcnQ6IFdULFxuICAgIHBvbGxpbmc6IFhIUixcbn07XG4iXSwibmFtZXMiOlsiWEhSIiwiV1MiLCJXVCIsInRyYW5zcG9ydHMiLCJ3ZWJzb2NrZXQiLCJ3ZWJ0cmFuc3BvcnQiLCJwb2xsaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling-fetch.js":
/*!************************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/transports/polling-fetch.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fetch: () => (/* binding */ Fetch)\n/* harmony export */ });\n/* harmony import */ var _polling_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polling.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling.js\");\n\n/**\n * HTTP long-polling based on the built-in `fetch()` method.\n *\n * Usage: browser, Node.js (since v18), Deno, Bun\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/fetch\n * @see https://caniuse.com/fetch\n * @see https://nodejs.org/api/globals.html#fetch\n */ class Fetch extends _polling_js__WEBPACK_IMPORTED_MODULE_0__.Polling {\n    doPoll() {\n        this._fetch().then((res)=>{\n            if (!res.ok) {\n                return this.onError(\"fetch read error\", res.status, res);\n            }\n            res.text().then((data)=>this.onData(data));\n        }).catch((err)=>{\n            this.onError(\"fetch read error\", err);\n        });\n    }\n    doWrite(data, callback) {\n        this._fetch(data).then((res)=>{\n            if (!res.ok) {\n                return this.onError(\"fetch write error\", res.status, res);\n            }\n            callback();\n        }).catch((err)=>{\n            this.onError(\"fetch write error\", err);\n        });\n    }\n    _fetch(data) {\n        var _a;\n        const isPost = data !== undefined;\n        const headers = new Headers(this.opts.extraHeaders);\n        if (isPost) {\n            headers.set(\"content-type\", \"text/plain;charset=UTF-8\");\n        }\n        (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);\n        return fetch(this.uri(), {\n            method: isPost ? \"POST\" : \"GET\",\n            body: isPost ? data : null,\n            headers,\n            credentials: this.opts.withCredentials ? \"include\" : \"omit\"\n        }).then((res)=>{\n            var _a;\n            // @ts-ignore getSetCookie() was added in Node.js v19.7.0\n            (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(res.headers.getSetCookie());\n            return res;\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3RyYW5zcG9ydHMvcG9sbGluZy1mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1QztBQUN2Qzs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU1DLGNBQWNELGdEQUFPQTtJQUM5QkUsU0FBUztRQUNMLElBQUksQ0FBQ0MsTUFBTSxHQUNOQyxJQUFJLENBQUMsQ0FBQ0M7WUFDUCxJQUFJLENBQUNBLElBQUlDLEVBQUUsRUFBRTtnQkFDVCxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDLG9CQUFvQkYsSUFBSUcsTUFBTSxFQUFFSDtZQUN4RDtZQUNBQSxJQUFJSSxJQUFJLEdBQUdMLElBQUksQ0FBQyxDQUFDTSxPQUFTLElBQUksQ0FBQ0MsTUFBTSxDQUFDRDtRQUMxQyxHQUNLRSxLQUFLLENBQUMsQ0FBQ0M7WUFDUixJQUFJLENBQUNOLE9BQU8sQ0FBQyxvQkFBb0JNO1FBQ3JDO0lBQ0o7SUFDQUMsUUFBUUosSUFBSSxFQUFFSyxRQUFRLEVBQUU7UUFDcEIsSUFBSSxDQUFDWixNQUFNLENBQUNPLE1BQ1BOLElBQUksQ0FBQyxDQUFDQztZQUNQLElBQUksQ0FBQ0EsSUFBSUMsRUFBRSxFQUFFO2dCQUNULE9BQU8sSUFBSSxDQUFDQyxPQUFPLENBQUMscUJBQXFCRixJQUFJRyxNQUFNLEVBQUVIO1lBQ3pEO1lBQ0FVO1FBQ0osR0FDS0gsS0FBSyxDQUFDLENBQUNDO1lBQ1IsSUFBSSxDQUFDTixPQUFPLENBQUMscUJBQXFCTTtRQUN0QztJQUNKO0lBQ0FWLE9BQU9PLElBQUksRUFBRTtRQUNULElBQUlNO1FBQ0osTUFBTUMsU0FBU1AsU0FBU1E7UUFDeEIsTUFBTUMsVUFBVSxJQUFJQyxRQUFRLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxZQUFZO1FBQ2xELElBQUlMLFFBQVE7WUFDUkUsUUFBUUksR0FBRyxDQUFDLGdCQUFnQjtRQUNoQztRQUNDUCxDQUFBQSxLQUFLLElBQUksQ0FBQ1EsTUFBTSxDQUFDQyxVQUFVLE1BQU0sUUFBUVQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHVSxhQUFhLENBQUNQO1FBQ3BGLE9BQU9RLE1BQU0sSUFBSSxDQUFDQyxHQUFHLElBQUk7WUFDckJDLFFBQVFaLFNBQVMsU0FBUztZQUMxQmEsTUFBTWIsU0FBU1AsT0FBTztZQUN0QlM7WUFDQVksYUFBYSxJQUFJLENBQUNWLElBQUksQ0FBQ1csZUFBZSxHQUFHLFlBQVk7UUFDekQsR0FBRzVCLElBQUksQ0FBQyxDQUFDQztZQUNMLElBQUlXO1lBQ0oseURBQXlEO1lBQ3hEQSxDQUFBQSxLQUFLLElBQUksQ0FBQ1EsTUFBTSxDQUFDQyxVQUFVLE1BQU0sUUFBUVQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaUIsWUFBWSxDQUFDNUIsSUFBSWMsT0FBTyxDQUFDZSxZQUFZO1lBQzNHLE9BQU83QjtRQUNYO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3doYXRzYXBwLWFpLWNybS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9lc20tZGVidWcvdHJhbnNwb3J0cy9wb2xsaW5nLWZldGNoLmpzP2ZjYzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9sbGluZyB9IGZyb20gXCIuL3BvbGxpbmcuanNcIjtcbi8qKlxuICogSFRUUCBsb25nLXBvbGxpbmcgYmFzZWQgb24gdGhlIGJ1aWx0LWluIGBmZXRjaCgpYCBtZXRob2QuXG4gKlxuICogVXNhZ2U6IGJyb3dzZXIsIE5vZGUuanMgKHNpbmNlIHYxOCksIERlbm8sIEJ1blxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2ZldGNoXG4gKiBAc2VlIGh0dHBzOi8vY2FuaXVzZS5jb20vZmV0Y2hcbiAqIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9nbG9iYWxzLmh0bWwjZmV0Y2hcbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoIGV4dGVuZHMgUG9sbGluZyB7XG4gICAgZG9Qb2xsKCkge1xuICAgICAgICB0aGlzLl9mZXRjaCgpXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRXJyb3IoXCJmZXRjaCByZWFkIGVycm9yXCIsIHJlcy5zdGF0dXMsIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMudGV4dCgpLnRoZW4oKGRhdGEpID0+IHRoaXMub25EYXRhKGRhdGEpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJmZXRjaCByZWFkIGVycm9yXCIsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb1dyaXRlKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2ZldGNoKGRhdGEpXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRXJyb3IoXCJmZXRjaCB3cml0ZSBlcnJvclwiLCByZXMuc3RhdHVzLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJmZXRjaCB3cml0ZSBlcnJvclwiLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ZldGNoKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBpc1Bvc3QgPSBkYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyh0aGlzLm9wdHMuZXh0cmFIZWFkZXJzKTtcbiAgICAgICAgaWYgKGlzUG9zdCkge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIik7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5zb2NrZXQuX2Nvb2tpZUphcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFwcGVuZENvb2tpZXMoaGVhZGVycyk7XG4gICAgICAgIHJldHVybiBmZXRjaCh0aGlzLnVyaSgpLCB7XG4gICAgICAgICAgICBtZXRob2Q6IGlzUG9zdCA/IFwiUE9TVFwiIDogXCJHRVRcIixcbiAgICAgICAgICAgIGJvZHk6IGlzUG9zdCA/IGRhdGEgOiBudWxsLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLm9wdHMud2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcIm9taXRcIixcbiAgICAgICAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIGdldFNldENvb2tpZSgpIHdhcyBhZGRlZCBpbiBOb2RlLmpzIHYxOS43LjBcbiAgICAgICAgICAgIChfYSA9IHRoaXMuc29ja2V0Ll9jb29raWVKYXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJzZUNvb2tpZXMocmVzLmhlYWRlcnMuZ2V0U2V0Q29va2llKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIlBvbGxpbmciLCJGZXRjaCIsImRvUG9sbCIsIl9mZXRjaCIsInRoZW4iLCJyZXMiLCJvayIsIm9uRXJyb3IiLCJzdGF0dXMiLCJ0ZXh0IiwiZGF0YSIsIm9uRGF0YSIsImNhdGNoIiwiZXJyIiwiZG9Xcml0ZSIsImNhbGxiYWNrIiwiX2EiLCJpc1Bvc3QiLCJ1bmRlZmluZWQiLCJoZWFkZXJzIiwiSGVhZGVycyIsIm9wdHMiLCJleHRyYUhlYWRlcnMiLCJzZXQiLCJzb2NrZXQiLCJfY29va2llSmFyIiwiYXBwZW5kQ29va2llcyIsImZldGNoIiwidXJpIiwibWV0aG9kIiwiYm9keSIsImNyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwicGFyc2VDb29raWVzIiwiZ2V0U2V0Q29va2llIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling-fetch.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseXHR: () => (/* binding */ BaseXHR),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   XHR: () => (/* binding */ XHR)\n/* harmony export */ });\n/* harmony import */ var _polling_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polling.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @socket.io/component-emitter */ \"(ssr)/../node_modules/@socket.io/component-emitter/lib/esm/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/util.js\");\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../globals.node.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/globals.node.js\");\n/* harmony import */ var _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../contrib/has-cors.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/contrib/has-cors.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! debug */ \"(ssr)/../node_modules/engine.io-client/node_modules/debug/src/index.js\");\n\n\n\n\n\n // debug()\nconst debug = debug__WEBPACK_IMPORTED_MODULE_5__(\"engine.io-client:polling\"); // debug()\nfunction empty() {}\nclass BaseXHR extends _polling_js__WEBPACK_IMPORTED_MODULE_0__.Polling {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */ constructor(opts){\n        super(opts);\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd = typeof location !== \"undefined\" && opts.hostname !== location.hostname || port !== opts.port;\n        }\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @private\n     */ doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", (xhrStatus, context)=>{\n            this.onError(\"xhr post error\", xhrStatus, context);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @private\n     */ doPoll() {\n        debug(\"xhr poll\");\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", (xhrStatus, context)=>{\n            this.onError(\"xhr poll error\", xhrStatus, context);\n        });\n        this.pollXhr = req;\n    }\n}\nclass Request extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__.Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */ constructor(createRequest, uri, opts){\n        super();\n        this.createRequest = createRequest;\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.installTimerFunctions)(this, opts);\n        this._opts = opts;\n        this._method = opts.method || \"GET\";\n        this._uri = uri;\n        this._data = undefined !== opts.data ? opts.data : null;\n        this._create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */ _create() {\n        var _a;\n        const opts = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.pick)(this._opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this._opts.xd;\n        const xhr = this._xhr = this.createRequest(opts);\n        try {\n            debug(\"xhr open %s: %s\", this._method, this._uri);\n            xhr.open(this._method, this._uri, true);\n            try {\n                if (this._opts.extraHeaders) {\n                    // @ts-ignore\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for(let i in this._opts.extraHeaders){\n                        if (this._opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            } catch (e) {}\n            if (\"POST\" === this._method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                } catch (e) {}\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            } catch (e) {}\n            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this._opts.withCredentials;\n            }\n            if (this._opts.requestTimeout) {\n                xhr.timeout = this._opts.requestTimeout;\n            }\n            xhr.onreadystatechange = ()=>{\n                var _a;\n                if (xhr.readyState === 3) {\n                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(// @ts-ignore\n                    xhr.getResponseHeader(\"set-cookie\"));\n                }\n                if (4 !== xhr.readyState) return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this._onLoad();\n                } else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(()=>{\n                        this._onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            debug(\"xhr data %s\", this._data);\n            xhr.send(this._data);\n        } catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(()=>{\n                this._onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this._index = Request.requestsCount++;\n            Request.requests[this._index] = this;\n        }\n    }\n    /**\n     * Called upon error.\n     *\n     * @private\n     */ _onError(err) {\n        this.emitReserved(\"error\", err, this._xhr);\n        this._cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @private\n     */ _cleanup(fromError) {\n        if (\"undefined\" === typeof this._xhr || null === this._xhr) {\n            return;\n        }\n        this._xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this._xhr.abort();\n            } catch (e) {}\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this._index];\n        }\n        this._xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @private\n     */ _onLoad() {\n        const data = this._xhr.responseText;\n        if (data !== null) {\n            this.emitReserved(\"data\", data);\n            this.emitReserved(\"success\");\n            this._cleanup();\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @package\n     */ abort() {\n        this._cleanup();\n    }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */ if (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    } else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in _globals_node_js__WEBPACK_IMPORTED_MODULE_3__.globalThisShim ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for(let i in Request.requests){\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\nconst hasXHR2 = function() {\n    const xhr = newRequest({\n        xdomain: false\n    });\n    return xhr && xhr.responseType !== null;\n}();\n/**\n * HTTP long-polling based on the built-in `XMLHttpRequest` object.\n *\n * Usage: browser\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n */ class XHR extends BaseXHR {\n    constructor(opts){\n        super(opts);\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    request(opts = {}) {\n        Object.assign(opts, {\n            xd: this.xd\n        }, this.opts);\n        return new Request(newRequest, this.uri(), opts);\n    }\n}\nfunction newRequest(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_4__.hasCORS)) {\n            return new XMLHttpRequest();\n        }\n    } catch (e) {}\n    if (!xdomain) {\n        try {\n            return new _globals_node_js__WEBPACK_IMPORTED_MODULE_3__.globalThisShim[[\n                \"Active\"\n            ].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        } catch (e) {}\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ2dCO0FBQ0U7QUFDUztBQUNqQjtBQUNqQixDQUFDLFVBQVU7QUFDM0MsTUFBTVEsUUFBUUQsa0NBQVdBLENBQUMsNkJBQTZCLFVBQVU7QUFDakUsU0FBU0UsU0FBVTtBQUNaLE1BQU1DLGdCQUFnQlYsZ0RBQU9BO0lBQ2hDOzs7OztLQUtDLEdBQ0RXLFlBQVlDLElBQUksQ0FBRTtRQUNkLEtBQUssQ0FBQ0E7UUFDTixJQUFJLE9BQU9DLGFBQWEsYUFBYTtZQUNqQyxNQUFNQyxRQUFRLGFBQWFELFNBQVNFLFFBQVE7WUFDNUMsSUFBSUMsT0FBT0gsU0FBU0csSUFBSTtZQUN4Qiw4Q0FBOEM7WUFDOUMsSUFBSSxDQUFDQSxNQUFNO2dCQUNQQSxPQUFPRixRQUFRLFFBQVE7WUFDM0I7WUFDQSxJQUFJLENBQUNHLEVBQUUsR0FDSCxPQUFRSixhQUFhLGVBQ2pCRCxLQUFLTSxRQUFRLEtBQUtMLFNBQVNLLFFBQVEsSUFDbkNGLFNBQVNKLEtBQUtJLElBQUk7UUFDOUI7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNERyxRQUFRQyxJQUFJLEVBQUVDLEVBQUUsRUFBRTtRQUNkLE1BQU1DLE1BQU0sSUFBSSxDQUFDQyxPQUFPLENBQUM7WUFDckJDLFFBQVE7WUFDUkosTUFBTUE7UUFDVjtRQUNBRSxJQUFJRyxFQUFFLENBQUMsV0FBV0o7UUFDbEJDLElBQUlHLEVBQUUsQ0FBQyxTQUFTLENBQUNDLFdBQVdDO1lBQ3hCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLGtCQUFrQkYsV0FBV0M7UUFDOUM7SUFDSjtJQUNBOzs7O0tBSUMsR0FDREUsU0FBUztRQUNMckIsTUFBTTtRQUNOLE1BQU1jLE1BQU0sSUFBSSxDQUFDQyxPQUFPO1FBQ3hCRCxJQUFJRyxFQUFFLENBQUMsUUFBUSxJ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QUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdHNhcHAtYWktY3JtLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS1kZWJ1Zy90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzPzYyN2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9sbGluZyB9IGZyb20gXCIuL3BvbGxpbmcuanNcIjtcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tIFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiO1xuaW1wb3J0IHsgaW5zdGFsbFRpbWVyRnVuY3Rpb25zLCBwaWNrIH0gZnJvbSBcIi4uL3V0aWwuanNcIjtcbmltcG9ydCB7IGdsb2JhbFRoaXNTaGltIGFzIGdsb2JhbFRoaXMgfSBmcm9tIFwiLi4vZ2xvYmFscy5ub2RlLmpzXCI7XG5pbXBvcnQgeyBoYXNDT1JTIH0gZnJvbSBcIi4uL2NvbnRyaWIvaGFzLWNvcnMuanNcIjtcbmltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjsgLy8gZGVidWcoKVxuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImVuZ2luZS5pby1jbGllbnQ6cG9sbGluZ1wiKTsgLy8gZGVidWcoKVxuZnVuY3Rpb24gZW1wdHkoKSB7IH1cbmV4cG9ydCBjbGFzcyBCYXNlWEhSIGV4dGVuZHMgUG9sbGluZyB7XG4gICAgLyoqXG4gICAgICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc3QgaXNTU0wgPSBcImh0dHBzOlwiID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgICAgIGxldCBwb3J0ID0gbG9jYXRpb24ucG9ydDtcbiAgICAgICAgICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICAgICAgICAgIGlmICghcG9ydCkge1xuICAgICAgICAgICAgICAgIHBvcnQgPSBpc1NTTCA/IFwiNDQzXCIgOiBcIjgwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnhkID1cbiAgICAgICAgICAgICAgICAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgIG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb1dyaXRlKGRhdGEsIGZuKSB7XG4gICAgICAgIGNvbnN0IHJlcSA9IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vbihcInN1Y2Nlc3NcIiwgZm4pO1xuICAgICAgICByZXEub24oXCJlcnJvclwiLCAoeGhyU3RhdHVzLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJ4aHIgcG9zdCBlcnJvclwiLCB4aHJTdGF0dXMsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZG9Qb2xsKCkge1xuICAgICAgICBkZWJ1ZyhcInhociBwb2xsXCIpO1xuICAgICAgICBjb25zdCByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgICAgICAgcmVxLm9uKFwiZGF0YVwiLCB0aGlzLm9uRGF0YS5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgKHhoclN0YXR1cywgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwieGhyIHBvbGwgZXJyb3JcIiwgeGhyU3RhdHVzLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9sbFhociA9IHJlcTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVxdWVzdCBleHRlbmRzIEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjcmVhdGVSZXF1ZXN0LCB1cmksIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVSZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdDtcbiAgICAgICAgaW5zdGFsbFRpbWVyRnVuY3Rpb25zKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLl9vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gb3B0cy5tZXRob2QgfHwgXCJHRVRcIjtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICAgICAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHBpY2sodGhpcy5fb3B0cywgXCJhZ2VudFwiLCBcInBmeFwiLCBcImtleVwiLCBcInBhc3NwaHJhc2VcIiwgXCJjZXJ0XCIsIFwiY2FcIiwgXCJjaXBoZXJzXCIsIFwicmVqZWN0VW5hdXRob3JpemVkXCIsIFwiYXV0b1VucmVmXCIpO1xuICAgICAgICBvcHRzLnhkb21haW4gPSAhIXRoaXMuX29wdHMueGQ7XG4gICAgICAgIGNvbnN0IHhociA9ICh0aGlzLl94aHIgPSB0aGlzLmNyZWF0ZVJlcXVlc3Qob3B0cykpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVidWcoXCJ4aHIgb3BlbiAlczogJXNcIiwgdGhpcy5fbWV0aG9kLCB0aGlzLl91cmkpO1xuICAgICAgICAgICAgeGhyLm9wZW4odGhpcy5fbWV0aG9kLCB0aGlzLl91cmksIHRydWUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0cy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5fb3B0cy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuX29wdHMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIGlmIChcIlBPU1RcIiA9PT0gdGhpcy5fbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCIqLypcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9vcHRzLmNvb2tpZUphcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZENvb2tpZXMoeGhyKTtcbiAgICAgICAgICAgIC8vIGllNiBjaGVja1xuICAgICAgICAgICAgaWYgKFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyKSB7XG4gICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMuX29wdHMud2l0aENyZWRlbnRpYWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdHMucmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB4aHIudGltZW91dCA9IHRoaXMuX29wdHMucmVxdWVzdFRpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5fb3B0cy5jb29raWVKYXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJzZUNvb2tpZXMoXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwic2V0LWNvb2tpZVwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICgyMDAgPT09IHhoci5zdGF0dXMgfHwgMTIyMyA9PT0geGhyLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dEZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IodHlwZW9mIHhoci5zdGF0dXMgPT09IFwibnVtYmVyXCIgPyB4aHIuc3RhdHVzIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWJ1ZyhcInhociBkYXRhICVzXCIsIHRoaXMuX2RhdGEpO1xuICAgICAgICAgICAgeGhyLnNlbmQodGhpcy5fZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmcm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgICAgICAgICAvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cbiAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dEZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkVycm9yKGUpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5faW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICAgICAgICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5faW5kZXhdID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uRXJyb3IoZXJyKSB7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyLCB0aGlzLl94aHIpO1xuICAgICAgICB0aGlzLl9jbGVhbnVwKHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgaG91c2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhbnVwKGZyb21FcnJvcikge1xuICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHRoaXMuX3hociB8fCBudWxsID09PSB0aGlzLl94aHIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl94aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gICAgICAgIGlmIChmcm9tRXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5faW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3hociA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGxvYWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkxvYWQoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl94aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkYXRhXCIsIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJzdWNjZXNzXCIpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgYWJvcnQoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICB9XG59XG5SZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0eXBlb2YgYXR0YWNoRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGF0dGFjaEV2ZW50KFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgdGVybWluYXRpb25FdmVudCA9IFwib25wYWdlaGlkZVwiIGluIGdsb2JhbFRoaXMgPyBcInBhZ2VoaWRlXCIgOiBcInVubG9hZFwiO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKHRlcm1pbmF0aW9uRXZlbnQsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICAgIGZvciAobGV0IGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgICAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgaGFzWEhSMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgeGhyID0gbmV3UmVxdWVzdCh7XG4gICAgICAgIHhkb21haW46IGZhbHNlLFxuICAgIH0pO1xuICAgIHJldHVybiB4aHIgJiYgeGhyLnJlc3BvbnNlVHlwZSAhPT0gbnVsbDtcbn0pKCk7XG4vKipcbiAqIEhUVFAgbG9uZy1wb2xsaW5nIGJhc2VkIG9uIHRoZSBidWlsdC1pbiBgWE1MSHR0cFJlcXVlc3RgIG9iamVjdC5cbiAqXG4gKiBVc2FnZTogYnJvd3NlclxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0XG4gKi9cbmV4cG9ydCBjbGFzcyBYSFIgZXh0ZW5kcyBCYXNlWEhSIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICBjb25zdCBmb3JjZUJhc2U2NCA9IG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NDtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGhhc1hIUjIgJiYgIWZvcmNlQmFzZTY0O1xuICAgIH1cbiAgICByZXF1ZXN0KG9wdHMgPSB7fSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIHsgeGQ6IHRoaXMueGQgfSwgdGhpcy5vcHRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KG5ld1JlcXVlc3QsIHRoaXMudXJpKCksIG9wdHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5ld1JlcXVlc3Qob3B0cykge1xuICAgIGNvbnN0IHhkb21haW4gPSBvcHRzLnhkb21haW47XG4gICAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgaWYgKCF4ZG9tYWluKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGdsb2JhbFRoaXNbW1wiQWN0aXZlXCJdLmNvbmNhdChcIk9iamVjdFwiKS5qb2luKFwiWFwiKV0oXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIlBvbGxpbmciLCJFbWl0dGVyIiwiaW5zdGFsbFRpbWVyRnVuY3Rpb25zIiwicGljayIsImdsb2JhbFRoaXNTaGltIiwiZ2xvYmFsVGhpcyIsImhhc0NPUlMiLCJkZWJ1Z01vZHVsZSIsImRlYnVnIiwiZW1wdHkiLCJCYXNlWEhSIiwiY29uc3RydWN0b3IiLCJvcHRzIiwibG9jYXRpb24iLCJpc1NTTCIsInByb3RvY29sIiwicG9ydCIsInhkIiwiaG9zdG5hbWUiLCJkb1dyaXRlIiwiZGF0YSIsImZuIiwicmVxIiwicmVxdWVzdCIsIm1ldGhvZCIsIm9uIiwieGhyU3RhdHVzIiwiY29udGV4dCIsIm9uRXJyb3IiLCJkb1BvbGwiLCJvbkRhdGEiLCJiaW5kIiwicG9sbFhociIsIlJlcXVlc3QiLCJjcmVhdGVSZXF1ZXN0IiwidXJpIiwiX29wdHMiLCJfbWV0aG9kIiwiX3VyaSIsIl9kYXRhIiwidW5kZWZpbmVkIiwiX2NyZWF0ZSIsIl9hIiwieGRvbWFpbiIsInhociIsIl94aHIiLCJvcGVuIiwiZXh0cmFIZWFkZXJzIiwic2V0RGlzYWJsZUhlYWRlckNoZWNrIiwiaSIsImhhc093blByb3BlcnR5Iiwic2V0UmVxdWVzdEhlYWRlciIsImUiLCJjb29raWVKYXIiLCJhZGRDb29raWVzIiwid2l0aENyZWRlbnRpYWxzIiwicmVxdWVzdFRpbWVvdXQiLCJ0aW1lb3V0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsInBhcnNlQ29va2llcyIsImdldFJlc3BvbnNlSGVhZGVyIiwic3RhdHVzIiwiX29uTG9hZCIsInNldFRpbWVvdXRGbiIsIl9vbkVycm9yIiwic2VuZCIsImRvY3VtZW50IiwiX2luZGV4IiwicmVxdWVzdHNDb3VudCIsInJlcXVlc3RzIiwiZXJyIiwiZW1pdFJlc2VydmVkIiwiX2NsZWFudXAiLCJmcm9tRXJyb3IiLCJhYm9ydCIsInJlc3BvbnNlVGV4dCIsImF0dGFjaEV2ZW50IiwidW5sb2FkSGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0ZXJtaW5hdGlvbkV2ZW50IiwiaGFzWEhSMiIsIm5ld1JlcXVlc3QiLCJyZXNwb25zZVR5cGUiLCJYSFIiLCJmb3JjZUJhc2U2NCIsInN1cHBvcnRzQmluYXJ5IiwiT2JqZWN0IiwiYXNzaWduIiwiWE1MSHR0cFJlcXVlc3QiLCJjb25jYXQiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.node.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.node.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var xmlhttprequest_ssl__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XHR: () => (/* binding */ XHR)\n/* harmony export */ });\n/* harmony import */ var xmlhttprequest_ssl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xmlhttprequest-ssl */ \"(ssr)/../node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js\");\n/* harmony import */ var _polling_xhr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polling-xhr.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.js\");\n\n\nconst XMLHttpRequest = xmlhttprequest_ssl__WEBPACK_IMPORTED_MODULE_0__ || /*#__PURE__*/ (xmlhttprequest_ssl__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (xmlhttprequest_ssl__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(xmlhttprequest_ssl__WEBPACK_IMPORTED_MODULE_0__, 2)));\n/**\n * HTTP long-polling based on the `XMLHttpRequest` object provided by the `xmlhttprequest-ssl` package.\n *\n * Usage: Node.js, Deno (compat), Bun (compat)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n */ class XHR extends _polling_xhr_js__WEBPACK_IMPORTED_MODULE_1__.BaseXHR {\n    request(opts = {}) {\n        var _a;\n        Object.assign(opts, {\n            xd: this.xd,\n            cookieJar: (_a = this.socket) === null || _a === void 0 ? void 0 : _a._cookieJar\n        }, this.opts);\n        return new _polling_xhr_js__WEBPACK_IMPORTED_MODULE_1__.Request((opts)=>new XMLHttpRequest(opts), this.uri(), opts);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3RyYW5zcG9ydHMvcG9sbGluZy14aHIubm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJEO0FBQ1A7QUFDcEQsTUFBTUcsaUJBQWlCSCwrQ0FBNEIsSUFBSUEsZ09BQW9CQTtBQUMzRTs7Ozs7O0NBTUMsR0FDTSxNQUFNSyxZQUFZSixvREFBT0E7SUFDNUJLLFFBQVFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDZixJQUFJQztRQUNKQyxPQUFPQyxNQUFNLENBQUNILE1BQU07WUFBRUksSUFBSSxJQUFJLENBQUNBLEVBQUU7WUFBRUMsV0FBVyxDQUFDSixLQUFLLElBQUksQ0FBQ0ssTUFBTSxNQUFNLFFBQVFMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR00sVUFBVTtRQUFDLEdBQUcsSUFBSSxDQUFDUCxJQUFJO1FBQ2hJLE9BQU8sSUFBSUwsb0RBQU9BLENBQUMsQ0FBQ0ssT0FBUyxJQUFJSixlQUFlSSxPQUFPLElBQUksQ0FBQ1EsR0FBRyxJQUFJUjtJQUN2RTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdHNhcHAtYWktY3JtLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS1kZWJ1Zy90cmFuc3BvcnRzL3BvbGxpbmcteGhyLm5vZGUuanM/ZGQ1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBYTUxIdHRwUmVxdWVzdE1vZHVsZSBmcm9tIFwieG1saHR0cHJlcXVlc3Qtc3NsXCI7XG5pbXBvcnQgeyBCYXNlWEhSLCBSZXF1ZXN0IH0gZnJvbSBcIi4vcG9sbGluZy14aHIuanNcIjtcbmNvbnN0IFhNTEh0dHBSZXF1ZXN0ID0gWE1MSHR0cFJlcXVlc3RNb2R1bGUuZGVmYXVsdCB8fCBYTUxIdHRwUmVxdWVzdE1vZHVsZTtcbi8qKlxuICogSFRUUCBsb25nLXBvbGxpbmcgYmFzZWQgb24gdGhlIGBYTUxIdHRwUmVxdWVzdGAgb2JqZWN0IHByb3ZpZGVkIGJ5IHRoZSBgeG1saHR0cHJlcXVlc3Qtc3NsYCBwYWNrYWdlLlxuICpcbiAqIFVzYWdlOiBOb2RlLmpzLCBEZW5vIChjb21wYXQpLCBCdW4gKGNvbXBhdClcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdFxuICovXG5leHBvcnQgY2xhc3MgWEhSIGV4dGVuZHMgQmFzZVhIUiB7XG4gICAgcmVxdWVzdChvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIHsgeGQ6IHRoaXMueGQsIGNvb2tpZUphcjogKF9hID0gdGhpcy5zb2NrZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fY29va2llSmFyIH0sIHRoaXMub3B0cyk7XG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCgob3B0cykgPT4gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpLCB0aGlzLnVyaSgpLCBvcHRzKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiWE1MSHR0cFJlcXVlc3RNb2R1bGUiLCJCYXNlWEhSIiwiUmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0IiwiZGVmYXVsdCIsIlhIUiIsInJlcXVlc3QiLCJvcHRzIiwiX2EiLCJPYmplY3QiLCJhc3NpZ24iLCJ4ZCIsImNvb2tpZUphciIsInNvY2tldCIsIl9jb29raWVKYXIiLCJ1cmkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.node.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling.js":
/*!******************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/transports/polling.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polling: () => (/* binding */ Polling)\n/* harmony export */ });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transport.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/util.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! engine.io-parser */ \"(ssr)/../node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! debug */ \"(ssr)/../node_modules/engine.io-client/node_modules/debug/src/index.js\");\n\n\n\n // debug()\nconst debug = debug__WEBPACK_IMPORTED_MODULE_3__(\"engine.io-client:polling\"); // debug()\nclass Polling extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {\n    constructor(){\n        super(...arguments);\n        this._polling = false;\n    }\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @protected\n     */ doOpen() {\n        this._poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n     * @package\n     */ pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = ()=>{\n            debug(\"paused\");\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this._polling || !this.writable) {\n            let total = 0;\n            if (this._polling) {\n                debug(\"we are currently polling - waiting to pause\");\n                total++;\n                this.once(\"pollComplete\", function() {\n                    debug(\"pre-pause polling complete\");\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                debug(\"we are currently writing - waiting to pause\");\n                total++;\n                this.once(\"drain\", function() {\n                    debug(\"pre-pause writing complete\");\n                    --total || pause();\n                });\n            }\n        } else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @private\n     */ _poll() {\n        debug(\"polling\");\n        this._polling = true;\n        this.doPoll();\n        this.emitReserved(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @protected\n     */ onData(data) {\n        debug(\"polling got data %s\", data);\n        const callback = (packet)=>{\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose({\n                    description: \"transport closed by the server\"\n                });\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.decodePayload)(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this._polling = false;\n            this.emitReserved(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this._poll();\n            } else {\n                debug('ignoring poll - transport state \"%s\"', this.readyState);\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @protected\n     */ doClose() {\n        const close = ()=>{\n            debug(\"writing close packet\");\n            this.write([\n                {\n                    type: \"close\"\n                }\n            ]);\n        };\n        if (\"open\" === this.readyState) {\n            debug(\"transport open - closing\");\n            close();\n        } else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            debug(\"transport not open - deferring close\");\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} packets - data packets\n     * @protected\n     */ write(packets) {\n        this.writable = false;\n        (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.encodePayload)(packets, (data)=>{\n            this.doWrite(data, ()=>{\n                this.writable = true;\n                this.emitReserved(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */ uri() {\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        const query = this.query || {};\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.randomString)();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE0QztBQUNGO0FBQ3NCO0FBQ2hDLENBQUMsVUFBVTtBQUMzQyxNQUFNSyxRQUFRRCxrQ0FBV0EsQ0FBQyw2QkFBNkIsVUFBVTtBQUMxRCxNQUFNRSxnQkFBZ0JOLG9EQUFTQTtJQUNsQ08sYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNwQjtJQUNBLElBQUlDLE9BQU87UUFDUCxPQUFPO0lBQ1g7SUFDQTs7Ozs7S0FLQyxHQUNEQyxTQUFTO1FBQ0wsSUFBSSxDQUFDQyxLQUFLO0lBQ2Q7SUFDQTs7Ozs7S0FLQyxHQUNEQyxNQUFNQyxPQUFPLEVBQUU7UUFDWCxJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixNQUFNRixRQUFRO1lBQ1ZSLE1BQU07WUFDTixJQUFJLENBQUNVLFVBQVUsR0FBRztZQUNsQkQ7UUFDSjtRQUNBLElBQUksSUFBSSxDQUFDTCxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUNPLFFBQVEsRUFBRTtZQUNqQyxJQUFJQyxRQUFRO1lBQ1osSUFBSSxJQUFJLENBQUNSLFFBQVEsRUFBRTtnQkFDZkosTUFBTTtnQkFDTlk7Z0JBQ0EsSUFBSSxDQUFDQyxJQUFJLENBQUMsZ0JBQWdCO29CQUN0QmIsTUFBTTtvQkFDTixFQUFFWSxTQUFTSjtnQkFDZjtZQUNKO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ0csUUFBUSxFQUFFO2dCQUNoQlgsTUFBTTtnQkFDTlk7Z0JBQ0EsSUFBSSxDQUFDQyxJQUFJLENBQUMsU0FBUztvQkFDZmIsTUFBTTtvQkFDTixFQUFFWSxTQUFTSjtnQkFDZjtZQUNKO1FBQ0osT0FDSztZQUNEQTtRQUNKO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RELFFBQVE7UUFDSlAsTUFBTTtRQUNOLElBQUksQ0FBQ0ksUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ1UsTUFBTTtRQUNYLElBQUksQ0FBQ0MsWUFBWSxDQUFDO0lBQ3RCO0lBQ0E7Ozs7S0FJQyxHQUNEQyxPQUFPQyxJQUFJLEVBQUU7UUFDVGpCLE1BQU0sdUJBQXVCaUI7UUFDN0IsTUFBTUMsV0FBVyxDQUFDQztZQUNkLDBEQUEwRDtZQUMxRCxJQUFJLGNBQWMsSUFBSSxDQUFDVCxVQUFVLElBQUlTLE9BQU9DLElBQUksS0FBSyxRQUFRO2dCQUN6RCxJQUFJLENBQUNDLE1BQU07WUFDZjtZQUNBLHVEQUF1RDtZQUN2RCxJQUFJLFlBQVlGLE9BQU9DLElBQUksRUFBRTtnQkFDekIsSUFBSSxDQUFDRSxPQUFPLENBQUM7b0JBQUVDLGFBQWE7Z0JBQWlDO2dCQUM3RCxPQUFPO1lBQ1g7WUFDQSxpREFBaUQ7WUFDakQsSUFBSSxDQUFDQyxRQUFRLENBQUNMO1FBQ2xCO1FBQ0EsaUJBQWlCO1FBQ2pCckIsK0RBQWFBLENBQUNtQixNQUFNLElBQUksQ0FBQ1EsTUFBTSxDQUFDQyxVQUFVLEVBQUVDLE9BQU8sQ0FBQ1Q7UUFDcEQsc0NBQXNDO1FBQ3RDLElBQUksYUFBYSxJQUFJLENBQUNSLFVBQVUsRUFBRTtZQUM5QixtQ0FBbUM7WUFDbkMsSUFBSSxDQUFDTixRQUFRLEdBQUc7WUFDaEIsSUFBSSxDQUFDVyxZQUFZLENBQUM7WUFDbEIsSUFBSSxXQUFXLElBQUksQ0FBQ0wsVUFBVSxFQUFFO2dCQUM1QixJQUFJLENBQUNILEtBQUs7WUFDZCxPQUNLO2dCQUNEUCxNQUFNLHdDQUF3QyxJQUFJLENBQUNVLFVBQVU7WUFDakU7UUFDSjtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNEa0IsVUFBVTtRQUNOLE1BQU1DLFFBQVE7WUFDVjdCLE1BQU07WUFDTixJQUFJLENBQUM4QixLQUFLLENBQUM7Z0JBQUM7b0JBQUVWLE1BQU07Z0JBQVE7YUFBRTtRQUNsQztRQUNBLElBQUksV0FBVyxJQUFJLENBQUNWLFVBQVUsRUFBRTtZQUM1QlYsTUFBTTtZQUNONkI7UUFDSixPQUNLO1lBQ0Qsc0NBQXNDO1lBQ3RDLHNDQUFzQztZQUN0QzdCLE1BQU07WUFDTixJQUFJLENBQUNhLElBQUksQ0FBQyxRQUFRZ0I7UUFDdEI7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0RDLE1BQU1DLE9BQU8sRUFBRTtRQUNYLElBQUksQ0FBQ3BCLFFBQVEsR0FBRztRQUNoQmQsK0RBQWFBLENBQUNrQyxTQUFTLENBQUNkO1lBQ3BCLElBQUksQ0FBQ2UsT0FBTyxDQUFDZixNQUFNO2dCQUNmLElBQUksQ0FBQ04sUUFBUSxHQUFHO2dCQUNoQixJQUFJLENBQUNJLFlBQVksQ0FBQztZQUN0QjtRQUNKO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RrQixNQUFNO1FBQ0YsTUFBTUMsU0FBUyxJQUFJLENBQUNDLElBQUksQ0FBQ0MsTUFBTSxHQUFHLFVBQVU7UUFDNUMsTUFBTUMsUUFBUSxJQUFJLENBQUNBLEtBQUssSUFBSSxDQUFDO1FBQzdCLDBCQUEwQjtRQUMxQixJQUFJLFVBQVUsSUFBSSxDQUFDRixJQUFJLENBQUNHLGlCQUFpQixFQUFFO1lBQ3ZDRCxLQUFLLENBQUMsSUFBSSxDQUFDRixJQUFJLENBQUNJLGNBQWMsQ0FBQyxHQUFHM0Msc0RBQVlBO1FBQ2xEO1FBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQzRDLGNBQWMsSUFBSSxDQUFDSCxNQUFNSSxHQUFHLEVBQUU7WUFDcENKLE1BQU1LLEdBQUcsR0FBRztRQUNoQjtRQUNBLE9BQU8sSUFBSSxDQUFDQyxTQUFTLENBQUNULFFBQVFHO0lBQ2xDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93aGF0c2FwcC1haS1jcm0tZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3RyYW5zcG9ydHMvcG9sbGluZy5qcz8xNzI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zcG9ydCB9IGZyb20gXCIuLi90cmFuc3BvcnQuanNcIjtcbmltcG9ydCB7IHJhbmRvbVN0cmluZyB9IGZyb20gXCIuLi91dGlsLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGVQYXlsb2FkLCBkZWNvZGVQYXlsb2FkIH0gZnJvbSBcImVuZ2luZS5pby1wYXJzZXJcIjtcbmltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjsgLy8gZGVidWcoKVxuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImVuZ2luZS5pby1jbGllbnQ6cG9sbGluZ1wiKTsgLy8gZGVidWcoKVxuZXhwb3J0IGNsYXNzIFBvbGxpbmcgZXh0ZW5kcyBUcmFuc3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wb2xsaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJwb2xsaW5nXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAgICAgKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkb09wZW4oKSB7XG4gICAgICAgIHRoaXMuX3BvbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHBvbGxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblBhdXNlIC0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBwYXVzZShvblBhdXNlKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwicGF1c2luZ1wiO1xuICAgICAgICBjb25zdCBwYXVzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwicGF1c2VkXCIpO1xuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJwYXVzZWRcIjtcbiAgICAgICAgICAgIG9uUGF1c2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3BvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9sbGluZykge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwid2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZVwiKTtcbiAgICAgICAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcInBvbGxDb21wbGV0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwid2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZVwiKTtcbiAgICAgICAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImRyYWluXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF1c2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BvbGwoKSB7XG4gICAgICAgIGRlYnVnKFwicG9sbGluZ1wiKTtcbiAgICAgICAgdGhpcy5fcG9sbGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZG9Qb2xsKCk7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicG9sbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgZGVidWcoXCJwb2xsaW5nIGdvdCBkYXRhICVzXCIsIGRhdGEpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICAgICAgICAgIGlmIChcIm9wZW5pbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHBhY2tldC50eXBlID09PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgICAgIHRoaXMub25PcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgICAgICAgICBpZiAoXCJjbG9zZVwiID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSh7IGRlc2NyaXB0aW9uOiBcInRyYW5zcG9ydCBjbG9zZWQgYnkgdGhlIHNlcnZlclwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRoaXMub25QYWNrZXQocGFja2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZGVjb2RlIHBheWxvYWRcbiAgICAgICAgZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICAgICAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgICAgICAgaWYgKFwiY2xvc2VkXCIgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgZ290IGRhdGEgd2UncmUgbm90IHBvbGxpbmdcbiAgICAgICAgICAgIHRoaXMuX3BvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicG9sbENvbXBsZXRlXCIpO1xuICAgICAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2xsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGRvQ2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJ3cml0aW5nIGNsb3NlIHBhY2tldFwiKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoW3sgdHlwZTogXCJjbG9zZVwiIH1dKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nXCIpO1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgICAgICAgICAvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2VcIik7XG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJvcGVuXCIsIGNsb3NlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzIC0gZGF0YSBwYWNrZXRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHdyaXRlKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBlbmNvZGVQYXlsb2FkKHBhY2tldHMsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvV3JpdGUoZGF0YSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZHJhaW5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVyaSgpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5vcHRzLnNlY3VyZSA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiO1xuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gICAgICAgIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gICAgICAgIGlmIChmYWxzZSAhPT0gdGhpcy5vcHRzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgICAgICAgICBxdWVyeVt0aGlzLm9wdHMudGltZXN0YW1wUGFyYW1dID0gcmFuZG9tU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICAgICAgICAgIHF1ZXJ5LmI2NCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVXJpKHNjaGVtYSwgcXVlcnkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJUcmFuc3BvcnQiLCJyYW5kb21TdHJpbmciLCJlbmNvZGVQYXlsb2FkIiwiZGVjb2RlUGF5bG9hZCIsImRlYnVnTW9kdWxlIiwiZGVidWciLCJQb2xsaW5nIiwiY29uc3RydWN0b3IiLCJhcmd1bWVudHMiLCJfcG9sbGluZyIsIm5hbWUiLCJkb09wZW4iLCJfcG9sbCIsInBhdXNlIiwib25QYXVzZSIsInJlYWR5U3RhdGUiLCJ3cml0YWJsZSIsInRvdGFsIiwib25jZSIsImRvUG9sbCIsImVtaXRSZXNlcnZlZCIsIm9uRGF0YSIsImRhdGEiLCJjYWxsYmFjayIsInBhY2tldCIsInR5cGUiLCJvbk9wZW4iLCJvbkNsb3NlIiwiZGVzY3JpcHRpb24iLCJvblBhY2tldCIsInNvY2tldCIsImJpbmFyeVR5cGUiLCJmb3JFYWNoIiwiZG9DbG9zZSIsImNsb3NlIiwid3JpdGUiLCJwYWNrZXRzIiwiZG9Xcml0ZSIsInVyaSIsInNjaGVtYSIsIm9wdHMiLCJzZWN1cmUiLCJxdWVyeSIsInRpbWVzdGFtcFJlcXVlc3RzIiwidGltZXN0YW1wUGFyYW0iLCJzdXBwb3J0c0JpbmFyeSIsInNpZCIsImI2NCIsImNyZWF0ZVVyaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/polling.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/websocket.js":
/*!********************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/transports/websocket.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWS: () => (/* binding */ BaseWS),\n/* harmony export */   WS: () => (/* binding */ WS)\n/* harmony export */ });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transport.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/util.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! engine.io-parser */ \"(ssr)/../node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../globals.node.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/globals.node.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! debug */ \"(ssr)/../node_modules/engine.io-client/node_modules/debug/src/index.js\");\n\n\n\n\n // debug()\nconst debug = debug__WEBPACK_IMPORTED_MODULE_4__(\"engine.io-client:websocket\"); // debug()\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" && typeof navigator.product === \"string\" && navigator.product.toLowerCase() === \"reactnative\";\nclass BaseWS extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {\n    get name() {\n        return \"websocket\";\n    }\n    doOpen() {\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative ? {} : (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.pick)(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws = this.createSocket(uri, protocols, opts);\n        } catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @private\n     */ addEventListeners() {\n        this.ws.onopen = ()=>{\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = (closeEvent)=>this.onClose({\n                description: \"websocket connection closed\",\n                context: closeEvent\n            });\n        this.ws.onmessage = (ev)=>this.onData(ev.data);\n        this.ws.onerror = (e)=>this.onError(\"websocket error\", e);\n    }\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for(let i = 0; i < packets.length; i++){\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.encodePacket)(packet, this.supportsBinary, (data)=>{\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    this.doWrite(packet, data);\n                } catch (e) {\n                    debug(\"websocket closed before onclose event\");\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    (0,_globals_node_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(()=>{\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.onerror = ()=>{};\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */ uri() {\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        const query = this.query || {};\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.randomString)();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n}\nconst WebSocketCtor = _globals_node_js__WEBPACK_IMPORTED_MODULE_3__.globalThisShim.WebSocket || _globals_node_js__WEBPACK_IMPORTED_MODULE_3__.globalThisShim.MozWebSocket;\n/**\n * WebSocket transport based on the built-in `WebSocket` object.\n *\n * Usage: browser, Node.js (since v21), Deno, Bun\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n * @see https://caniuse.com/mdn-api_websocket\n * @see https://nodejs.org/api/globals.html#websocket\n */ class WS extends BaseWS {\n    createSocket(uri, protocols, opts) {\n        return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);\n    }\n    doWrite(_packet, data) {\n        this.ws.send(data);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEM7QUFDSTtBQUNBO0FBQzRCO0FBQzVDLENBQUMsVUFBVTtBQUMzQyxNQUFNUSxRQUFRRCxrQ0FBV0EsQ0FBQywrQkFBK0IsVUFBVTtBQUNuRSxpQ0FBaUM7QUFDakMsTUFBTUUsZ0JBQWdCLE9BQU9DLGNBQWMsZUFDdkMsT0FBT0EsVUFBVUMsT0FBTyxLQUFLLFlBQzdCRCxVQUFVQyxPQUFPLENBQUNDLFdBQVcsT0FBTztBQUNqQyxNQUFNQyxlQUFlYixvREFBU0E7SUFDakMsSUFBSWMsT0FBTztRQUNQLE9BQU87SUFDWDtJQUNBQyxTQUFTO1FBQ0wsTUFBTUMsTUFBTSxJQUFJLENBQUNBLEdBQUc7UUFDcEIsTUFBTUMsWUFBWSxJQUFJLENBQUNDLElBQUksQ0FBQ0QsU0FBUztRQUNyQyx1R0FBdUc7UUFDdkcsTUFBTUMsT0FBT1QsZ0JBQ1AsQ0FBQyxJQUNEUiw4Q0FBSUEsQ0FBQyxJQUFJLENBQUNpQixJQUFJLEVBQUUsU0FBUyxxQkFBcUIsT0FBTyxPQUFPLGNBQWMsUUFBUSxNQUFNLFdBQVcsc0JBQXNCLGdCQUFnQixtQkFBbUIsVUFBVSxjQUFjLFVBQVU7UUFDcE0sSUFBSSxJQUFJLENBQUNBLElBQUksQ0FBQ0MsWUFBWSxFQUFFO1lBQ3hCRCxLQUFLRSxPQUFPLEdBQUcsSUFBSSxDQUFDRixJQUFJLENBQUNDLFlBQVk7UUFDekM7UUFDQSxJQUFJO1lBQ0EsSUFBSSxDQUFDRSxFQUFFLEdBQUcsSUFBSSxDQUFDQyxZQUFZLENBQUNOLEtBQUtDLFdBQVdDO1FBQ2hELEVBQ0EsT0FBT0ssS0FBSztZQUNSLE9BQU8sSUFBSSxDQUFDQyxZQUFZLENBQUMsU0FBU0Q7UUFDdEM7UUFDQSxJQUFJLENBQUNGLEVBQUUsQ0FBQ0ksVUFBVSxHQUFHLElBQUksQ0FBQ0MsTUFBTSxD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QixJQUFJK0MsY0FBY2hELE9BQ3RCLElBQUlnRCxjQUFjaEQsS0FBS0MsV0FBV0M7SUFDNUM7SUFDQW1DLFFBQVFlLE9BQU8sRUFBRTNCLElBQUksRUFBRTtRQUNuQixJQUFJLENBQUNwQixFQUFFLENBQUNnRCxJQUFJLENBQUM1QjtJQUNqQjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdHNhcHAtYWktY3JtLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS1kZWJ1Zy90cmFuc3BvcnRzL3dlYnNvY2tldC5qcz82NTUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zcG9ydCB9IGZyb20gXCIuLi90cmFuc3BvcnQuanNcIjtcbmltcG9ydCB7IHBpY2ssIHJhbmRvbVN0cmluZyB9IGZyb20gXCIuLi91dGlsLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGVQYWNrZXQgfSBmcm9tIFwiZW5naW5lLmlvLXBhcnNlclwiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpc1NoaW0gYXMgZ2xvYmFsVGhpcywgbmV4dFRpY2sgfSBmcm9tIFwiLi4vZ2xvYmFscy5ub2RlLmpzXCI7XG5pbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7IC8vIGRlYnVnKClcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldFwiKTsgLy8gZGVidWcoKVxuLy8gZGV0ZWN0IFJlYWN0TmF0aXZlIGVudmlyb25tZW50XG5jb25zdCBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09IFwicmVhY3RuYXRpdmVcIjtcbmV4cG9ydCBjbGFzcyBCYXNlV1MgZXh0ZW5kcyBUcmFuc3BvcnQge1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJzb2NrZXRcIjtcbiAgICB9XG4gICAgZG9PcGVuKCkge1xuICAgICAgICBjb25zdCB1cmkgPSB0aGlzLnVyaSgpO1xuICAgICAgICBjb25zdCBwcm90b2NvbHMgPSB0aGlzLm9wdHMucHJvdG9jb2xzO1xuICAgICAgICAvLyBSZWFjdCBOYXRpdmUgb25seSBzdXBwb3J0cyB0aGUgJ2hlYWRlcnMnIG9wdGlvbiwgYW5kIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIGFueXRoaW5nIGVsc2UgaXMgcGFzc2VkXG4gICAgICAgIGNvbnN0IG9wdHMgPSBpc1JlYWN0TmF0aXZlXG4gICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICA6IHBpY2sodGhpcy5vcHRzLCBcImFnZW50XCIsIFwicGVyTWVzc2FnZURlZmxhdGVcIiwgXCJwZnhcIiwgXCJrZXlcIiwgXCJwYXNzcGhyYXNlXCIsIFwiY2VydFwiLCBcImNhXCIsIFwiY2lwaGVyc1wiLCBcInJlamVjdFVuYXV0aG9yaXplZFwiLCBcImxvY2FsQWRkcmVzc1wiLCBcInByb3RvY29sVmVyc2lvblwiLCBcIm9yaWdpblwiLCBcIm1heFBheWxvYWRcIiwgXCJmYW1pbHlcIiwgXCJjaGVja1NlcnZlcklkZW50aXR5XCIpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gdGhpcy5vcHRzLmV4dHJhSGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53cyA9IHRoaXMuY3JlYXRlU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9IHRoaXMuc29ja2V0LmJpbmFyeVR5cGU7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmF1dG9VbnJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMud3MuX3NvY2tldC51bnJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gKGNsb3NlRXZlbnQpID0+IHRoaXMub25DbG9zZSh7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiBjbG9zZWRcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IGNsb3NlRXZlbnQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IChldikgPT4gdGhpcy5vbkRhdGEoZXYuZGF0YSk7XG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IChlKSA9PiB0aGlzLm9uRXJyb3IoXCJ3ZWJzb2NrZXQgZXJyb3JcIiwgZSk7XG4gICAgfVxuICAgIHdyaXRlKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAgICAgICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gcGFja2V0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RQYWNrZXQgPSBpID09PSBwYWNrZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBlbmNvZGVQYWNrZXQocGFja2V0LCB0aGlzLnN1cHBvcnRzQmluYXJ5LCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9Xcml0ZShwYWNrZXQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIndlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZha2UgZHJhaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZHJhaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuc2V0VGltZW91dEZuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb0Nsb3NlKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMud3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3Mub25lcnJvciA9ICgpID0+IHsgfTtcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMud3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVyaSgpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5vcHRzLnNlY3VyZSA/IFwid3NzXCIgOiBcIndzXCI7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgICAgICAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgICAgICAgaWYgKHRoaXMub3B0cy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgICAgICAgICAgcXVlcnlbdGhpcy5vcHRzLnRpbWVzdGFtcFBhcmFtXSA9IHJhbmRvbVN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgICAgIHF1ZXJ5LmI2NCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVXJpKHNjaGVtYSwgcXVlcnkpO1xuICAgIH1cbn1cbmNvbnN0IFdlYlNvY2tldEN0b3IgPSBnbG9iYWxUaGlzLldlYlNvY2tldCB8fCBnbG9iYWxUaGlzLk1veldlYlNvY2tldDtcbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBiYXNlZCBvbiB0aGUgYnVpbHQtaW4gYFdlYlNvY2tldGAgb2JqZWN0LlxuICpcbiAqIFVzYWdlOiBicm93c2VyLCBOb2RlLmpzIChzaW5jZSB2MjEpLCBEZW5vLCBCdW5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXRcbiAqIEBzZWUgaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tYXBpX3dlYnNvY2tldFxuICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2dsb2JhbHMuaHRtbCN3ZWJzb2NrZXRcbiAqL1xuZXhwb3J0IGNsYXNzIFdTIGV4dGVuZHMgQmFzZVdTIHtcbiAgICBjcmVhdGVTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuICFpc1JlYWN0TmF0aXZlXG4gICAgICAgICAgICA/IHByb3RvY29sc1xuICAgICAgICAgICAgICAgID8gbmV3IFdlYlNvY2tldEN0b3IodXJpLCBwcm90b2NvbHMpXG4gICAgICAgICAgICAgICAgOiBuZXcgV2ViU29ja2V0Q3Rvcih1cmkpXG4gICAgICAgICAgICA6IG5ldyBXZWJTb2NrZXRDdG9yKHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcbiAgICB9XG4gICAgZG9Xcml0ZShfcGFja2V0LCBkYXRhKSB7XG4gICAgICAgIHRoaXMud3Muc2VuZChkYXRhKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiVHJhbnNwb3J0IiwicGljayIsInJhbmRvbVN0cmluZyIsImVuY29kZVBhY2tldCIsImdsb2JhbFRoaXNTaGltIiwiZ2xvYmFsVGhpcyIsIm5leHRUaWNrIiwiZGVidWdNb2R1bGUiLCJkZWJ1ZyIsImlzUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwidG9Mb3dlckNhc2UiLCJCYXNlV1MiLCJuYW1lIiwiZG9PcGVuIiwidXJpIiwicHJvdG9jb2xzIiwib3B0cyIsImV4dHJhSGVhZGVycyIsImhlYWRlcnMiLCJ3cyIsImNyZWF0ZVNvY2tldCIsImVyciIsImVtaXRSZXNlcnZlZCIsImJpbmFyeVR5cGUiLCJzb2NrZXQiLCJhZGRFdmVudExpc3RlbmVycyIsIm9ub3BlbiIsImF1dG9VbnJlZiIsIl9zb2NrZXQiLCJ1bnJlZiIsIm9uT3BlbiIsIm9uY2xvc2UiLCJjbG9zZUV2ZW50Iiwib25DbG9zZSIsImRlc2NyaXB0aW9uIiwiY29udGV4dCIsIm9ubWVzc2FnZSIsImV2Iiwib25EYXRhIiwiZGF0YSIsIm9uZXJyb3IiLCJlIiwib25FcnJvciIsIndyaXRlIiwicGFja2V0cyIsIndyaXRhYmxlIiwiaSIsImxlbmd0aCIsInBhY2tldCIsImxhc3RQYWNrZXQiLCJzdXBwb3J0c0JpbmFyeSIsImRvV3JpdGUiLCJzZXRUaW1lb3V0Rm4iLCJkb0Nsb3NlIiwiY2xvc2UiLCJzY2hlbWEiLCJzZWN1cmUiLCJxdWVyeSIsInRpbWVzdGFtcFJlcXVlc3RzIiwidGltZXN0YW1wUGFyYW0iLCJiNjQiLCJjcmVhdGVVcmkiLCJXZWJTb2NrZXRDdG9yIiwiV2ViU29ja2V0IiwiTW96V2ViU29ja2V0IiwiV1MiLCJfcGFja2V0Iiwic2VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/websocket.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/websocket.node.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/transports/websocket.node.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WS: () => (/* binding */ WS)\n/* harmony export */ });\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/wrapper.mjs\");\n/* harmony import */ var _websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./websocket.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/websocket.js\");\n\n\n/**\n * WebSocket transport based on the `WebSocket` object provided by the `ws` package.\n *\n * Usage: Node.js, Deno (compat), Bun (compat)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n * @see https://caniuse.com/mdn-api_websocket\n */ class WS extends _websocket_js__WEBPACK_IMPORTED_MODULE_1__.BaseWS {\n    createSocket(uri, protocols, opts) {\n        var _a;\n        if ((_a = this.socket) === null || _a === void 0 ? void 0 : _a._cookieJar) {\n            opts.headers = opts.headers || {};\n            opts.headers.cookie = typeof opts.headers.cookie === \"string\" ? [\n                opts.headers.cookie\n            ] : opts.headers.cookie || [];\n            for (const [name, cookie] of this.socket._cookieJar.cookies){\n                opts.headers.cookie.push(`${name}=${cookie.value}`);\n            }\n        }\n        return new ws__WEBPACK_IMPORTED_MODULE_0__.WebSocket(uri, protocols, opts);\n    }\n    doWrite(packet, data) {\n        const opts = {};\n        if (packet.options) {\n            opts.compress = packet.options.compress;\n        }\n        if (this.opts.perMessageDeflate) {\n            const len = // @ts-ignore\n            \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n            if (len < this.opts.perMessageDeflate.threshold) {\n                opts.compress = false;\n            }\n        }\n        this.ws.send(data, opts);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3RyYW5zcG9ydHMvd2Vic29ja2V0Lm5vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlCO0FBQ2U7QUFDeEM7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU1FLFdBQVdELGlEQUFNQTtJQUMxQkUsYUFBYUMsR0FBRyxFQUFFQyxTQUFTLEVBQUVDLElBQUksRUFBRTtRQUMvQixJQUFJQztRQUNKLElBQUksQ0FBQ0EsS0FBSyxJQUFJLENBQUNDLE1BQU0sTUFBTSxRQUFRRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdFLFVBQVUsRUFBRTtZQUN2RUgsS0FBS0ksT0FBTyxHQUFHSixLQUFLSSxPQUFPLElBQUksQ0FBQztZQUNoQ0osS0FBS0ksT0FBTyxDQUFDQyxNQUFNLEdBQ2YsT0FBT0wsS0FBS0ksT0FBTyxDQUFDQyxNQUFNLEtBQUssV0FDekI7Z0JBQUNMLEtBQUtJLE9BQU8sQ0FBQ0MsTUFBTTthQUFDLEdBQ3JCTCxLQUFLSSxPQUFPLENBQUNDLE1BQU0sSUFBSSxFQUFFO1lBQ25DLEtBQUssTUFBTSxDQUFDQyxNQUFNRCxPQUFPLElBQUksSUFBSSxDQUFDSCxNQUFNLENBQUNDLFVBQVUsQ0FBQ0ksT0FBTyxDQUFFO2dCQUN6RFAsS0FBS0ksT0FBTyxDQUFDQyxNQUFNLENBQUNHLElBQUksQ0FBQyxDQUFDLEVBQUVGLEtBQUssQ0FBQyxFQUFFRCxPQUFPSSxLQUFLLENBQUMsQ0FBQztZQUN0RDtRQUNKO1FBQ0EsT0FBTyxJQUFJZix5Q0FBWSxDQUFDSSxLQUFLQyxXQUFXQztJQUM1QztJQUNBVyxRQUFRQyxNQUFNLEVBQUVDLElBQUksRUFBRTtRQUNsQixNQUFNYixPQUFPLENBQUM7UUFDZCxJQUFJWSxPQUFPRSxPQUFPLEVBQUU7WUFDaEJkLEtBQUtlLFFBQVEsR0FBR0gsT0FBT0UsT0FBTyxDQUFDQyxRQUFRO1FBQzNDO1FBQ0EsSUFBSSxJQUFJLENBQUNmLElBQUksQ0FBQ2dCLGlCQUFpQixFQUFFO1lBQzdCLE1BQU1DLE1BQ04sYUFBYTtZQUNiLGFBQWEsT0FBT0osT0FBT0ssT0FBT0MsVUFBVSxDQUFDTixRQUFRQSxLQUFLTyxNQUFNO1lBQ2hFLElBQUlILE1BQU0sSUFBSSxDQUFDakIsSUFBSSxDQUFDZ0IsaUJBQWlCLENBQUNLLFNBQVMsRUFBRTtnQkFDN0NyQixLQUFLZSxRQUFRLEdBQUc7WUFDcEI7UUFDSjtRQUNBLElBQUksQ0FBQ3JCLEVBQUUsQ0FBQzRCLElBQUksQ0FBQ1QsTUFBTWI7SUFDdkI7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3doYXRzYXBwLWFpLWNybS1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9lc20tZGVidWcvdHJhbnNwb3J0cy93ZWJzb2NrZXQubm9kZS5qcz9iOWMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHdzIGZyb20gXCJ3c1wiO1xuaW1wb3J0IHsgQmFzZVdTIH0gZnJvbSBcIi4vd2Vic29ja2V0LmpzXCI7XG4vKipcbiAqIFdlYlNvY2tldCB0cmFuc3BvcnQgYmFzZWQgb24gdGhlIGBXZWJTb2NrZXRgIG9iamVjdCBwcm92aWRlZCBieSB0aGUgYHdzYCBwYWNrYWdlLlxuICpcbiAqIFVzYWdlOiBOb2RlLmpzLCBEZW5vIChjb21wYXQpLCBCdW4gKGNvbXBhdClcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXRcbiAqIEBzZWUgaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tYXBpX3dlYnNvY2tldFxuICovXG5leHBvcnQgY2xhc3MgV1MgZXh0ZW5kcyBCYXNlV1Mge1xuICAgIGNyZWF0ZVNvY2tldCh1cmksIHByb3RvY29scywgb3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9jb29raWVKYXIpIHtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgICAgIG9wdHMuaGVhZGVycy5jb29raWUgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRzLmhlYWRlcnMuY29va2llID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gW29wdHMuaGVhZGVycy5jb29raWVdXG4gICAgICAgICAgICAgICAgICAgIDogb3B0cy5oZWFkZXJzLmNvb2tpZSB8fCBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGNvb2tpZV0gb2YgdGhpcy5zb2NrZXQuX2Nvb2tpZUphci5jb29raWVzKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzLmNvb2tpZS5wdXNoKGAke25hbWV9PSR7Y29va2llLnZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgd3MuV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcbiAgICB9XG4gICAgZG9Xcml0ZShwYWNrZXQsIGRhdGEpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBkYXRhID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPCB0aGlzLm9wdHMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud3Muc2VuZChkYXRhLCBvcHRzKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsid3MiLCJCYXNlV1MiLCJXUyIsImNyZWF0ZVNvY2tldCIsInVyaSIsInByb3RvY29scyIsIm9wdHMiLCJfYSIsInNvY2tldCIsIl9jb29raWVKYXIiLCJoZWFkZXJzIiwiY29va2llIiwibmFtZSIsImNvb2tpZXMiLCJwdXNoIiwidmFsdWUiLCJXZWJTb2NrZXQiLCJkb1dyaXRlIiwicGFja2V0IiwiZGF0YSIsIm9wdGlvbnMiLCJjb21wcmVzcyIsInBlck1lc3NhZ2VEZWZsYXRlIiwibGVuIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsImxlbmd0aCIsInRocmVzaG9sZCIsInNlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/websocket.node.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/webtransport.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/transports/webtransport.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WT: () => (/* binding */ WT)\n/* harmony export */ });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/transport.js\");\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../globals.node.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/globals.node.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! engine.io-parser */ \"(ssr)/../node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! debug */ \"(ssr)/../node_modules/engine.io-client/node_modules/debug/src/index.js\");\n\n\n\n // debug()\nconst debug = debug__WEBPACK_IMPORTED_MODULE_3__(\"engine.io-client:webtransport\"); // debug()\n/**\n * WebTransport transport based on the built-in `WebTransport` object.\n *\n * Usage: browser, Node.js (with the `@fails-components/webtransport` package)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport\n * @see https://caniuse.com/webtransport\n */ class WT extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {\n    get name() {\n        return \"webtransport\";\n    }\n    doOpen() {\n        try {\n            // @ts-ignore\n            this._transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n        } catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this._transport.closed.then(()=>{\n            debug(\"transport closed gracefully\");\n            this.onClose();\n        }).catch((err)=>{\n            debug(\"transport closed due to %s\", err);\n            this.onError(\"webtransport error\", err);\n        });\n        // note: we could have used async/await, but that would require some additional polyfills\n        this._transport.ready.then(()=>{\n            this._transport.createBidirectionalStream().then((stream)=>{\n                const decoderStream = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n                const reader = stream.readable.pipeThrough(decoderStream).getReader();\n                const encoderStream = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.createPacketEncoderStream)();\n                encoderStream.readable.pipeTo(stream.writable);\n                this._writer = encoderStream.writable.getWriter();\n                const read = ()=>{\n                    reader.read().then(({ done, value })=>{\n                        if (done) {\n                            debug(\"session is closed\");\n                            return;\n                        }\n                        debug(\"received chunk: %o\", value);\n                        this.onPacket(value);\n                        read();\n                    }).catch((err)=>{\n                        debug(\"an error occurred while reading: %s\", err);\n                    });\n                };\n                read();\n                const packet = {\n                    type: \"open\"\n                };\n                if (this.query.sid) {\n                    packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n                }\n                this._writer.write(packet).then(()=>this.onOpen());\n            });\n        });\n    }\n    write(packets) {\n        this.writable = false;\n        for(let i = 0; i < packets.length; i++){\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            this._writer.write(packet).then(()=>{\n                if (lastPacket) {\n                    (0,_globals_node_js__WEBPACK_IMPORTED_MODULE_1__.nextTick)(()=>{\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        var _a;\n        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3RyYW5zcG9ydHMvd2VidHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTRDO0FBQ0U7QUFDMkM7QUFDekQsQ0FBQyxVQUFVO0FBQzNDLE1BQU1LLFFBQVFELGtDQUFXQSxDQUFDLGtDQUFrQyxVQUFVO0FBQ3RFOzs7Ozs7O0NBT0MsR0FDTSxNQUFNRSxXQUFXTixvREFBU0E7SUFDN0IsSUFBSU8sT0FBTztRQUNQLE9BQU87SUFDWDtJQUNBQyxTQUFTO1FBQ0wsSUFBSTtZQUNBLGFBQWE7WUFDYixJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJQyxhQUFhLElBQUksQ0FBQ0MsU0FBUyxDQUFDLFVBQVUsSUFBSSxDQUFDQyxJQUFJLENBQUNDLGdCQUFnQixDQUFDLElBQUksQ0FBQ04sSUFBSSxDQUFDO1FBQ3JHLEVBQ0EsT0FBT08sS0FBSztZQUNSLE9BQU8sSUFBSSxDQUFDQyxZQUFZLENBQUMsU0FBU0Q7UUFDdEM7UUFDQSxJQUFJLENBQUNMLFVBQVUsQ0FBQ08sTUFBTSxDQUNqQkMsSUFBSSxDQUFDO1lBQ05aLE1BQU07WUFDTixJQUFJLENBQUNhLE9BQU87UUFDaEIsR0FDS0MsS0FBSyxDQUFDLENBQUNMO1lBQ1JULE1BQU0sOEJBQThCUztZQUNwQyxJQUFJLENBQUNNLE9BQU8sQ0FBQyxzQkFBc0JOO1FBQ3ZDO1FBQ0EseUZBQXlGO1FBQ3pGLElBQUksQ0FBQ0wsVUFBVSxDQUFDWSxLQUFLLENBQUNKLElBQUksQ0FBQztZQUN2QixJQUFJLENBQUNSLFVBQVUsQ0FBQ2EseUJBQXlCLEdBQUdMLElBQUksQ0FBQyxDQUFDTTtnQkFDOUMsTUFBTUMsZ0JBQWdCdEIsMkVBQXlCQSxDQUFDdUIsT0FBT0MsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDQyxNQUFNLENBQUNDLFVBQVU7Z0JBQy9GLE1BQU1DLFNBQVNOLE9BQU9PLFFBQVEsQ0FBQ0MsV0FBVyxDQUFDUCxlQUFlUSxTQUFTO2dCQUNuRSxNQUFNQyxnQkFBZ0I5QiwyRUFBeUJBO2dCQUMvQzhCLGNBQWNILFFBQVEsQ0FBQ0ksTUFBTSxDQUFDWCxPQUFPWSxRQUFRO2dCQUM3QyxJQUFJLENBQUNDLE9BQU8sR0FBR0gsY0FBY0UsUUFBUSxDQUFDRSxTQUFTO2dCQUMvQyxNQUFNQyxPQUFPO29CQUNUVCxPQUNLUyxJQUFJLEdBQ0pyQixJQUFJLENBQUMsQ0FBQyxFQUFFc0IsSUFBSSxFQUFFQyxLQUFLLEVBQUU7d0JBQ3RCLElBQUlELE1BQU07NEJBQ05sQyxNQUFNOzRCQUNOO3dCQUNKO3dCQUNBQSxNQUFNLHNCQUFzQm1DO3dCQUM1QixJQUFJLENBQUNDLFFBQVEsQ0FBQ0Q7d0JBQ2RGO29CQUNKLEdBQ0tuQixLQUFLLENBQUMsQ0FBQ0w7d0JBQ1JULE1BQU0sdUNBQXVDUztvQkFDakQ7Z0JBQ0o7Z0JBQ0F3QjtnQkFDQSxNQUFNSSxTQUFTO29CQUFFQyxNQUFNO2dCQUFPO2dCQUM5QixJQUFJLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHLEVBQUU7b0JBQ2hCSCxPQUFPSSxJQUFJLEdBQUcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDRixLQUFLLENBQUNDLEdBQUcsQ0FBQyxFQUFFLENBQUM7Z0JBQy9DO2dCQUNBLElBQUksQ0FBQ1QsT0FBTyxDQUFDVyxLQUFLLENBQUNMLFFBQVF6QixJQUFJLENBQUMsSUFBTSxJQUFJLENBQUMrQixNQUFNO1lBQ3JEO1FBQ0o7SUFDSjtJQUNBRCxNQUFNRSxPQUFPLEVBQUU7UUFDWCxJQUFJLENBQUNkLFFBQVEsR0FBRztRQUNoQixJQUFLLElBQUllLElBQUksR0FBR0EsSUFBSUQsUUFBUUUsTUFBTSxFQUFFRCxJQUFLO1lBQ3JDLE1BQU1SLFNBQVNPLE9BQU8sQ0FBQ0MsRUFBRTtZQUN6QixNQUFNRSxhQUFhRixNQUFNRCxRQUFRRSxNQUFNLEdBQUc7WUFDMUMsSUFBSSxDQUFDZixPQUFPLENBQUNXLEtBQUssQ0FBQ0wsUUFBUXpCLElBQUksQ0FBQztnQkFDNUIsSUFBSW1DLFlBQVk7b0JBQ1puRCwwREFBUUEsQ0FBQzt3QkFDTCxJQUFJLENBQUNrQyxRQUFRLEdBQUc7d0JBQ2hCLElBQUksQ0FBQ3BCLFlBQVksQ0FBQztvQkFDdEIsR0FBRyxJQUFJLENBQUNzQyxZQUFZO2dCQUN4QjtZQUNKO1FBQ0o7SUFDSjtJQUNBQyxVQUFVO1FBQ04sSUFBSUM7UUFDSEEsQ0FBQUEsS0FBSyxJQUFJLENBQUM5QyxVQUFVLE1BQU0sUUFBUThDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0MsS0FBSztJQUN4RTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdHNhcHAtYWktY3JtLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS1kZWJ1Zy90cmFuc3BvcnRzL3dlYnRyYW5zcG9ydC5qcz8wZjc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zcG9ydCB9IGZyb20gXCIuLi90cmFuc3BvcnQuanNcIjtcbmltcG9ydCB7IG5leHRUaWNrIH0gZnJvbSBcIi4uL2dsb2JhbHMubm9kZS5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlUGFja2V0RGVjb2RlclN0cmVhbSwgY3JlYXRlUGFja2V0RW5jb2RlclN0cmVhbSwgfSBmcm9tIFwiZW5naW5lLmlvLXBhcnNlclwiO1xuaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiOyAvLyBkZWJ1ZygpXG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZW5naW5lLmlvLWNsaWVudDp3ZWJ0cmFuc3BvcnRcIik7IC8vIGRlYnVnKClcbi8qKlxuICogV2ViVHJhbnNwb3J0IHRyYW5zcG9ydCBiYXNlZCBvbiB0aGUgYnVpbHQtaW4gYFdlYlRyYW5zcG9ydGAgb2JqZWN0LlxuICpcbiAqIFVzYWdlOiBicm93c2VyLCBOb2RlLmpzICh3aXRoIHRoZSBgQGZhaWxzLWNvbXBvbmVudHMvd2VidHJhbnNwb3J0YCBwYWNrYWdlKVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlRyYW5zcG9ydFxuICogQHNlZSBodHRwczovL2Nhbml1c2UuY29tL3dlYnRyYW5zcG9ydFxuICovXG5leHBvcnQgY2xhc3MgV1QgZXh0ZW5kcyBUcmFuc3BvcnQge1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJ0cmFuc3BvcnRcIjtcbiAgICB9XG4gICAgZG9PcGVuKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3IFdlYlRyYW5zcG9ydCh0aGlzLmNyZWF0ZVVyaShcImh0dHBzXCIpLCB0aGlzLm9wdHMudHJhbnNwb3J0T3B0aW9uc1t0aGlzLm5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZWRcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGNsb3NlZCBncmFjZWZ1bGx5XCIpO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgY2xvc2VkIGR1ZSB0byAlc1wiLCBlcnIpO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwid2VidHJhbnNwb3J0IGVycm9yXCIsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBub3RlOiB3ZSBjb3VsZCBoYXZlIHVzZWQgYXN5bmMvYXdhaXQsIGJ1dCB0aGF0IHdvdWxkIHJlcXVpcmUgc29tZSBhZGRpdGlvbmFsIHBvbHlmaWxsc1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQucmVhZHkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc3BvcnQuY3JlYXRlQmlkaXJlY3Rpb25hbFN0cmVhbSgpLnRoZW4oKHN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZXJTdHJlYW0gPSBjcmVhdGVQYWNrZXREZWNvZGVyU3RyZWFtKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0ucmVhZGFibGUucGlwZVRocm91Z2goZGVjb2RlclN0cmVhbSkuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlclN0cmVhbSA9IGNyZWF0ZVBhY2tldEVuY29kZXJTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICBlbmNvZGVyU3RyZWFtLnJlYWRhYmxlLnBpcGVUbyhzdHJlYW0ud3JpdGFibGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlciA9IGVuY29kZXJTdHJlYW0ud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVhZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwic2Vzc2lvbiBpcyBjbG9zZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJyZWNlaXZlZCBjaHVuazogJW9cIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblBhY2tldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJhbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZWFkaW5nOiAlc1wiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrZXQgPSB7IHR5cGU6IFwib3BlblwiIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkuc2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhY2tldC5kYXRhID0gYHtcInNpZFwiOlwiJHt0aGlzLnF1ZXJ5LnNpZH1cIn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZXIud3JpdGUocGFja2V0KS50aGVuKCgpID0+IHRoaXMub25PcGVuKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3cml0ZShwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYWNrZXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgbGFzdFBhY2tldCA9IGkgPT09IHBhY2tldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlci53cml0ZShwYWNrZXQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zZXRUaW1lb3V0Rm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvQ2xvc2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5fdHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiVHJhbnNwb3J0IiwibmV4dFRpY2siLCJjcmVhdGVQYWNrZXREZWNvZGVyU3RyZWFtIiwiY3JlYXRlUGFja2V0RW5jb2RlclN0cmVhbSIsImRlYnVnTW9kdWxlIiwiZGVidWciLCJXVCIsIm5hbWUiLCJkb09wZW4iLCJfdHJhbnNwb3J0IiwiV2ViVHJhbnNwb3J0IiwiY3JlYXRlVXJpIiwib3B0cyIsInRyYW5zcG9ydE9wdGlvbnMiLCJlcnIiLCJlbWl0UmVzZXJ2ZWQiLCJjbG9zZWQiLCJ0aGVuIiwib25DbG9zZSIsImNhdGNoIiwib25FcnJvciIsInJlYWR5IiwiY3JlYXRlQmlkaXJlY3Rpb25hbFN0cmVhbSIsInN0cmVhbSIsImRlY29kZXJTdHJlYW0iLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwic29ja2V0IiwiYmluYXJ5VHlwZSIsInJlYWRlciIsInJlYWRhYmxlIiwicGlwZVRocm91Z2giLCJnZXRSZWFkZXIiLCJlbmNvZGVyU3RyZWFtIiwicGlwZVRvIiwid3JpdGFibGUiLCJfd3JpdGVyIiwiZ2V0V3JpdGVyIiwicmVhZCIsImRvbmUiLCJ2YWx1ZSIsIm9uUGFja2V0IiwicGFja2V0IiwidHlwZSIsInF1ZXJ5Iiwic2lkIiwiZGF0YSIsIndyaXRlIiwib25PcGVuIiwicGFja2V0cyIsImkiLCJsZW5ndGgiLCJsYXN0UGFja2V0Iiwic2V0VGltZW91dEZuIiwiZG9DbG9zZSIsIl9hIiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/transports/webtransport.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/build/esm-debug/util.js":
/*!****************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm-debug/util.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   byteLength: () => (/* binding */ byteLength),\n/* harmony export */   installTimerFunctions: () => (/* binding */ installTimerFunctions),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   randomString: () => (/* binding */ randomString)\n/* harmony export */ });\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.node.js */ \"(ssr)/../node_modules/engine.io-client/build/esm-debug/globals.node.js\");\n\nfunction pick(obj, ...attr) {\n    return attr.reduce((acc, k)=>{\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = _globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = _globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.clearTimeout;\nfunction installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(_globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(_globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n    } else {\n        obj.setTimeoutFn = _globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.setTimeout.bind(_globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n        obj.clearTimeoutFn = _globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.clearTimeout.bind(_globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n    }\n}\n// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\nconst BASE64_OVERHEAD = 1.33;\n// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\nfunction byteLength(obj) {\n    if (typeof obj === \"string\") {\n        return utf8Length(obj);\n    }\n    // arraybuffer or blob\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(str) {\n    let c = 0, length = 0;\n    for(let i = 0, l = str.length; i < l; i++){\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        } else if (c < 0x800) {\n            length += 2;\n        } else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        } else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\n/**\n * Generates a random 8-characters string.\n */ function randomString() {\n    return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtLWRlYnVnL3V0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUU7QUFDMUQsU0FBU0UsS0FBS0MsR0FBRyxFQUFFLEdBQUdDLElBQUk7SUFDN0IsT0FBT0EsS0FBS0MsTUFBTSxDQUFDLENBQUNDLEtBQUtDO1FBQ3JCLElBQUlKLElBQUlLLGNBQWMsQ0FBQ0QsSUFBSTtZQUN2QkQsR0FBRyxDQUFDQyxFQUFFLEdBQUdKLEdBQUcsQ0FBQ0ksRUFBRTtRQUNuQjtRQUNBLE9BQU9EO0lBQ1gsR0FBRyxDQUFDO0FBQ1I7QUFDQSxxRkFBcUY7QUFDckYsTUFBTUcscUJBQXFCUiw0REFBVUEsQ0FBQ1MsVUFBVTtBQUNoRCxNQUFNQyx1QkFBdUJWLDREQUFVQSxDQUFDVyxZQUFZO0FBQzdDLFNBQVNDLHNCQUFzQlYsR0FBRyxFQUFFVyxJQUFJO0lBQzNDLElBQUlBLEtBQUtDLGVBQWUsRUFBRTtRQUN0QlosSUFBSWEsWUFBWSxHQUFHUCxtQkFBbUJRLElBQUksQ0FBQ2hCLDREQUFVQTtRQUNyREUsSUFBSWUsY0FBYyxHQUFHUCxxQkFBcUJNLElBQUksQ0FBQ2hCLDREQUFVQTtJQUM3RCxPQUNLO1FBQ0RFLElBQUlhLFlBQVksR0FBR2YsNERBQVVBLENBQUNTLFVBQVUsQ0FBQ08sSUFBSSxDQUFDaEIsNERBQVVBO1FBQ3hERSxJQUFJZSxjQUFjLEdBQUdqQiw0REFBVUEsQ0FBQ1csWUFBWSxDQUFDSyxJQUFJLENBQUNoQiw0REFBVUE7SUFDaEU7QUFDSjtBQUNBLHFGQUFxRjtBQUNyRixNQUFNa0Isa0JBQWtCO0FBQ3hCLGdGQUFnRjtBQUN6RSxTQUFTQyxXQUFXakIsR0FBRztJQUMxQixJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUN6QixPQUFPa0IsV0FBV2xCO0lBQ3RCO0lBQ0Esc0JBQXNCO0lBQ3RCLE9BQU9tQixLQUFLQyxJQUFJLENBQUMsQ0FBQ3BCLElBQUlpQixVQUFVLElBQUlqQixJQUFJcUIsSUFBSSxJQUFJTDtBQUNwRDtBQUNBLFNBQVNFLFdBQVdJLEdBQUc7SUFDbkIsSUFBSUMsSUFBSSxHQUFHQyxTQUFTO0lBQ3BCLElBQUssSUFBSUMsSUFBSSxHQUFHQyxJQUFJSixJQUFJRSxNQUFNLEVBQUVDLElBQUlDLEdBQUdELElBQUs7UUFDeENGLElBQUlELElBQUlLLFVBQVUsQ0FBQ0Y7UUFDbkIsSUFBSUYsSUFBSSxNQUFNO1lBQ1ZDLFVBQVU7UUFDZCxPQUNLLElBQUlELElBQUksT0FBTztZQUNoQkMsVUFBVTtRQUNkLE9BQ0ssSUFBSUQsSUFBSSxVQUFVQSxLQUFLLFFBQVE7WUFDaENDLFVBQVU7UUFDZCxPQUNLO1lBQ0RDO1lBQ0FELFVBQVU7UUFDZDtJQUNKO0lBQ0EsT0FBT0E7QUFDWDtBQUNBOztDQUVDLEdBQ00sU0FBU0k7SUFDWixPQUFRQyxLQUFLQyxHQUFHLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsS0FDdENiLEtBQUtjLE1BQU0sR0FBR0YsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHO0FBQ2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdHNhcHAtYWktY3JtLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS1kZWJ1Zy91dGlsLmpzPzdhZjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2xvYmFsVGhpc1NoaW0gYXMgZ2xvYmFsVGhpcyB9IGZyb20gXCIuL2dsb2JhbHMubm9kZS5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBpY2sob2JqLCAuLi5hdHRyKSB7XG4gICAgcmV0dXJuIGF0dHIucmVkdWNlKChhY2MsIGspID0+IHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgYWNjW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufVxuLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgcmVhbCB0aW1lb3V0IGZ1bmN0aW9ucyBzbyB0aGV5IGNhbiBiZSB1c2VkIHdoZW4gb3ZlcnJpZGRlblxuY29uc3QgTkFUSVZFX1NFVF9USU1FT1VUID0gZ2xvYmFsVGhpcy5zZXRUaW1lb3V0O1xuY29uc3QgTkFUSVZFX0NMRUFSX1RJTUVPVVQgPSBnbG9iYWxUaGlzLmNsZWFyVGltZW91dDtcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsVGltZXJGdW5jdGlvbnMob2JqLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMudXNlTmF0aXZlVGltZXJzKSB7XG4gICAgICAgIG9iai5zZXRUaW1lb3V0Rm4gPSBOQVRJVkVfU0VUX1RJTUVPVVQuYmluZChnbG9iYWxUaGlzKTtcbiAgICAgICAgb2JqLmNsZWFyVGltZW91dEZuID0gTkFUSVZFX0NMRUFSX1RJTUVPVVQuYmluZChnbG9iYWxUaGlzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9iai5zZXRUaW1lb3V0Rm4gPSBnbG9iYWxUaGlzLnNldFRpbWVvdXQuYmluZChnbG9iYWxUaGlzKTtcbiAgICAgICAgb2JqLmNsZWFyVGltZW91dEZuID0gZ2xvYmFsVGhpcy5jbGVhclRpbWVvdXQuYmluZChnbG9iYWxUaGlzKTtcbiAgICB9XG59XG4vLyBiYXNlNjQgZW5jb2RlZCBidWZmZXJzIGFyZSBhYm91dCAzMyUgYmlnZ2VyIChodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQpXG5jb25zdCBCQVNFNjRfT1ZFUkhFQUQgPSAxLjMzO1xuLy8gd2UgY291bGQgYWxzbyBoYXZlIHVzZWQgYG5ldyBCbG9iKFtvYmpdKS5zaXplYCwgYnV0IGl0IGlzbid0IHN1cHBvcnRlZCBpbiBJRTlcbmV4cG9ydCBmdW5jdGlvbiBieXRlTGVuZ3RoKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB1dGY4TGVuZ3RoKG9iaik7XG4gICAgfVxuICAgIC8vIGFycmF5YnVmZmVyIG9yIGJsb2JcbiAgICByZXR1cm4gTWF0aC5jZWlsKChvYmouYnl0ZUxlbmd0aCB8fCBvYmouc2l6ZSkgKiBCQVNFNjRfT1ZFUkhFQUQpO1xufVxuZnVuY3Rpb24gdXRmOExlbmd0aChzdHIpIHtcbiAgICBsZXQgYyA9IDAsIGxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGUwMDApIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgbGVuZ3RoICs9IDQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIDgtY2hhcmFjdGVycyBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21TdHJpbmcoKSB7XG4gICAgcmV0dXJuIChEYXRlLm5vdygpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMykgK1xuICAgICAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgNSkpO1xufVxuIl0sIm5hbWVzIjpbImdsb2JhbFRoaXNTaGltIiwiZ2xvYmFsVGhpcyIsInBpY2siLCJvYmoiLCJhdHRyIiwicmVkdWNlIiwiYWNjIiwiayIsImhhc093blByb3BlcnR5IiwiTkFUSVZFX1NFVF9USU1FT1VUIiwic2V0VGltZW91dCIsIk5BVElWRV9DTEVBUl9USU1FT1VUIiwiY2xlYXJUaW1lb3V0IiwiaW5zdGFsbFRpbWVyRnVuY3Rpb25zIiwib3B0cyIsInVzZU5hdGl2ZVRpbWVycyIsInNldFRpbWVvdXRGbiIsImJpbmQiLCJjbGVhclRpbWVvdXRGbiIsIkJBU0U2NF9PVkVSSEVBRCIsImJ5dGVMZW5ndGgiLCJ1dGY4TGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJzaXplIiwic3RyIiwiYyIsImxlbmd0aCIsImkiLCJsIiwiY2hhckNvZGVBdCIsInJhbmRvbVN0cmluZyIsIkRhdGUiLCJub3ciLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInJhbmRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/build/esm-debug/util.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/engine.io-client/node_modules/ws/wrapper.mjs":
/*!********************************************************************!*\
  !*** ../node_modules/engine.io-client/node_modules/ws/wrapper.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/stream.js\");\n/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/receiver.js\");\n/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/sender.js\");\n/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/websocket.js\");\n/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ \"(ssr)/../node_modules/engine.io-client/node_modules/ws/lib/websocket-server.js\");\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3dzL3dyYXBwZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ1g7QUFDSjtBQUNNO0FBQ2E7QUFFdUI7QUFDL0UsaUVBQWVHLDhDQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2hhdHNhcHAtYWktY3JtLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy93cy93cmFwcGVyLm1qcz9mNjRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVXZWJTb2NrZXRTdHJlYW0gZnJvbSAnLi9saWIvc3RyZWFtLmpzJztcbmltcG9ydCBSZWNlaXZlciBmcm9tICcuL2xpYi9yZWNlaXZlci5qcyc7XG5pbXBvcnQgU2VuZGVyIGZyb20gJy4vbGliL3NlbmRlci5qcyc7XG5pbXBvcnQgV2ViU29ja2V0IGZyb20gJy4vbGliL3dlYnNvY2tldC5qcyc7XG5pbXBvcnQgV2ViU29ja2V0U2VydmVyIGZyb20gJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMnO1xuXG5leHBvcnQgeyBjcmVhdGVXZWJTb2NrZXRTdHJlYW0sIFJlY2VpdmVyLCBTZW5kZXIsIFdlYlNvY2tldCwgV2ViU29ja2V0U2VydmVyIH07XG5leHBvcnQgZGVmYXVsdCBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOlsiY3JlYXRlV2ViU29ja2V0U3RyZWFtIiwiUmVjZWl2ZXIiLCJTZW5kZXIiLCJXZWJTb2NrZXQiLCJXZWJTb2NrZXRTZXJ2ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/engine.io-client/node_modules/ws/wrapper.mjs\n");

/***/ })

};
;